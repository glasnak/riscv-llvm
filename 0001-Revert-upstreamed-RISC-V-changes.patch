From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Bradbury <asb@lowrisc.org>
Subject: Revert upstreamed RISC-V changes

This allows the patch series to be maintained and modified on an ongoing
basis.
---
 docs/CompilerWriterInfo.rst                        |    4 -
 include/llvm/ADT/Triple.h                          |    2 -
 include/llvm/BinaryFormat/ELF.h                    |   17 -
 include/llvm/BinaryFormat/ELFRelocs/RISCV.def      |   59 -
 include/llvm/Object/ELFObjectFile.h                |   15 -
 include/llvm/module.modulemap                      |    1 -
 lib/Object/ELF.cpp                                 |    7 -
 lib/Object/ELFObjectFile.cpp                       |   13 -
 lib/ObjectYAML/ELFYAML.cpp                         |   12 -
 lib/Support/Triple.cpp                             |   21 -
 lib/Target/LLVMBuild.txt                           |    1 -
 lib/Target/RISCV/AsmParser/CMakeLists.txt          |    3 -
 lib/Target/RISCV/AsmParser/LLVMBuild.txt           |   23 -
 lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp      |  967 ----------------
 lib/Target/RISCV/CMakeLists.txt                    |   31 -
 lib/Target/RISCV/Disassembler/CMakeLists.txt       |    3 -
 lib/Target/RISCV/Disassembler/LLVMBuild.txt        |   24 -
 .../RISCV/Disassembler/RISCVDisassembler.cpp       |  285 -----
 lib/Target/RISCV/InstPrinter/CMakeLists.txt        |    3 -
 lib/Target/RISCV/InstPrinter/LLVMBuild.txt         |   23 -
 lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp  |   90 --
 lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h    |   53 -
 lib/Target/RISCV/LLVMBuild.txt                     |   35 -
 lib/Target/RISCV/MCTargetDesc/CMakeLists.txt       |   10 -
 lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt        |   23 -
 lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp  |  326 ------
 lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h      |  110 --
 .../RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp    |   79 --
 lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp |   39 -
 lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h   |   24 -
 lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h    |   58 -
 lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp   |   25 -
 lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h     |   31 -
 .../RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp      |  209 ----
 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp      |  102 --
 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h        |   76 --
 .../RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp       |   92 --
 lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h  |   62 --
 .../RISCV/MCTargetDesc/RISCVTargetStreamer.cpp     |   18 -
 .../RISCV/MCTargetDesc/RISCVTargetStreamer.h       |   22 -
 lib/Target/RISCV/RISCV.h                           |   37 -
 lib/Target/RISCV/RISCV.td                          |   96 --
 lib/Target/RISCV/RISCVAsmPrinter.cpp               |  127 ---
 lib/Target/RISCV/RISCVCallingConv.td               |   20 -
 lib/Target/RISCV/RISCVFrameLowering.cpp            |  248 -----
 lib/Target/RISCV/RISCVFrameLowering.h              |   60 -
 lib/Target/RISCV/RISCVISelDAGToDAG.cpp             |  124 ---
 lib/Target/RISCV/RISCVISelLowering.cpp             | 1080 ------------------
 lib/Target/RISCV/RISCVISelLowering.h               |   94 --
 lib/Target/RISCV/RISCVInstrFormats.td              |  285 -----
 lib/Target/RISCV/RISCVInstrFormatsC.td             |  147 ---
 lib/Target/RISCV/RISCVInstrInfo.cpp                |  368 ------
 lib/Target/RISCV/RISCVInstrInfo.h                  |   79 --
 lib/Target/RISCV/RISCVInstrInfo.td                 |  652 -----------
 lib/Target/RISCV/RISCVInstrInfoA.td                |   77 --
 lib/Target/RISCV/RISCVInstrInfoC.td                |  444 --------
 lib/Target/RISCV/RISCVInstrInfoD.td                |  174 ---
 lib/Target/RISCV/RISCVInstrInfoF.td                |  222 ----
 lib/Target/RISCV/RISCVInstrInfoM.td                |   51 -
 lib/Target/RISCV/RISCVMCInstLower.cpp              |  105 --
 lib/Target/RISCV/RISCVMachineFunctionInfo.h        |   44 -
 lib/Target/RISCV/RISCVRegisterInfo.cpp             |  110 --
 lib/Target/RISCV/RISCVRegisterInfo.h               |   57 -
 lib/Target/RISCV/RISCVRegisterInfo.td              |  206 ----
 lib/Target/RISCV/RISCVSubtarget.cpp                |   48 -
 lib/Target/RISCV/RISCVSubtarget.h                  |   85 --
 lib/Target/RISCV/RISCVTargetMachine.cpp            |   92 --
 lib/Target/RISCV/RISCVTargetMachine.h              |   46 -
 lib/Target/RISCV/TargetInfo/CMakeLists.txt         |    3 -
 lib/Target/RISCV/TargetInfo/LLVMBuild.txt          |   23 -
 lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp    |   30 -
 test/CodeGen/RISCV/addc-adde-sube-subc.ll          |   30 -
 test/CodeGen/RISCV/alloca.ll                       |   65 --
 test/CodeGen/RISCV/alu32.ll                        |  186 ----
 test/CodeGen/RISCV/analyze-branch.ll               |   85 --
 test/CodeGen/RISCV/bare-select.ll                  |   17 -
 test/CodeGen/RISCV/blockaddress.ll                 |   30 -
 test/CodeGen/RISCV/branch-relaxation.ll            |   65 --
 test/CodeGen/RISCV/branch.ll                       |  110 --
 test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll        |  569 ----------
 test/CodeGen/RISCV/byval.ll                        |   51 -
 test/CodeGen/RISCV/calling-conv-sext-zext.ll       |  380 -------
 test/CodeGen/RISCV/calling-conv.ll                 | 1132 -------------------
 test/CodeGen/RISCV/calls.ll                        |  158 ---
 test/CodeGen/RISCV/div.ll                          |  241 ----
 test/CodeGen/RISCV/fp128.ll                        |  128 ---
 test/CodeGen/RISCV/frame.ll                        |   58 -
 test/CodeGen/RISCV/frameaddr-returnaddr.ll         |   92 --
 test/CodeGen/RISCV/get-setcc-result-type.ll        |   35 -
 test/CodeGen/RISCV/i32-icmp.ll                     |  114 --
 test/CodeGen/RISCV/imm.ll                          |   47 -
 test/CodeGen/RISCV/indirectbr.ll                   |   40 -
 test/CodeGen/RISCV/inline-asm.ll                   |   55 -
 test/CodeGen/RISCV/jumptable.ll                    |   58 -
 test/CodeGen/RISCV/large-stack.ll                  |  172 ---
 test/CodeGen/RISCV/lit.local.cfg                   |    2 -
 test/CodeGen/RISCV/mem.ll                          |  202 ----
 test/CodeGen/RISCV/mul.ll                          |  189 ----
 test/CodeGen/RISCV/rem.ll                          |   45 -
 test/CodeGen/RISCV/rotl-rotr.ll                    |   38 -
 test/CodeGen/RISCV/select-cc.ll                    |  100 --
 test/CodeGen/RISCV/sext-zext-trunc.ll              |  285 -----
 test/CodeGen/RISCV/shifts.ll                       |   51 -
 test/CodeGen/RISCV/vararg.ll                       | 1171 --------------------
 test/CodeGen/RISCV/wide-mem.ll                     |   34 -
 test/MC/RISCV/cnop.s                               |   26 -
 test/MC/RISCV/csr-aliases.s                        |  117 --
 test/MC/RISCV/elf-flags.s                          |   13 -
 test/MC/RISCV/elf-header.s                         |   42 -
 test/MC/RISCV/fixups-compressed.s                  |   25 -
 test/MC/RISCV/fixups-diagnostics.s                 |   18 -
 test/MC/RISCV/fixups.s                             |   50 -
 test/MC/RISCV/hilo-constaddr.s                     |   39 -
 test/MC/RISCV/lit.local.cfg                        |    3 -
 test/MC/RISCV/priv-invalid.s                       |    7 -
 test/MC/RISCV/priv-valid.s                         |   34 -
 test/MC/RISCV/relocations.s                        |   97 --
 test/MC/RISCV/rv32-relaxation.s                    |   75 --
 test/MC/RISCV/rv32a-invalid.s                      |   17 -
 test/MC/RISCV/rv32a-valid.s                        |  148 ---
 test/MC/RISCV/rv32c-invalid.s                      |   83 --
 test/MC/RISCV/rv32c-only-valid.s                   |   15 -
 test/MC/RISCV/rv32c-valid.s                        |  105 --
 test/MC/RISCV/rv32d-invalid.s                      |   21 -
 test/MC/RISCV/rv32d-valid.s                        |  161 ---
 test/MC/RISCV/rv32dc-invalid.s                     |   12 -
 test/MC/RISCV/rv32dc-valid.s                       |   29 -
 test/MC/RISCV/rv32f-invalid.s                      |   34 -
 test/MC/RISCV/rv32f-valid.s                        |  166 ---
 test/MC/RISCV/rv32fc-invalid.s                     |   12 -
 test/MC/RISCV/rv32fc-valid.s                       |   33 -
 test/MC/RISCV/rv32i-aliases-invalid.s              |    8 -
 test/MC/RISCV/rv32i-aliases-valid.s                |   20 -
 test/MC/RISCV/rv32i-invalid.s                      |  148 ---
 test/MC/RISCV/rv32i-valid.s                        |  240 ----
 test/MC/RISCV/rv32m-invalid.s                      |    9 -
 test/MC/RISCV/rv32m-valid.s                        |   35 -
 test/MC/RISCV/rv64-relaxation.s                    |   64 --
 test/MC/RISCV/rv64a-invalid.s                      |   14 -
 test/MC/RISCV/rv64a-valid.s                        |  190 ----
 test/MC/RISCV/rv64c-invalid.s                      |   29 -
 test/MC/RISCV/rv64c-valid.s                        |   58 -
 test/MC/RISCV/rv64d-aliases-valid.s                |   27 -
 test/MC/RISCV/rv64d-invalid.s                      |   11 -
 test/MC/RISCV/rv64d-valid.s                        |   50 -
 test/MC/RISCV/rv64dc-valid.s                       |   29 -
 test/MC/RISCV/rv64f-aliases-valid.s                |   27 -
 test/MC/RISCV/rv64f-invalid.s                      |    9 -
 test/MC/RISCV/rv64f-valid.s                        |   38 -
 test/MC/RISCV/rv64i-aliases-invalid.s              |    6 -
 test/MC/RISCV/rv64i-aliases-valid.s                |   20 -
 test/MC/RISCV/rv64i-invalid.s                      |   20 -
 test/MC/RISCV/rv64i-valid.s                        |   99 --
 test/MC/RISCV/rv64m-valid.s                        |   21 -
 test/MC/RISCV/rvd-aliases-valid.s                  |   78 --
 test/MC/RISCV/rvf-aliases-valid.s                  |  125 ---
 test/MC/RISCV/rvi-aliases-valid.s                  |  145 ---
 test/Object/RISCV/elf-flags.yaml                   |   24 -
 test/Object/RISCV/lit.local.cfg                    |    2 -
 tools/llvm-objdump/llvm-objdump.cpp                |    1 -
 tools/llvm-readobj/ELFDumper.cpp                   |   11 -
 unittests/ADT/TripleTest.cpp                       |   36 -
 utils/UpdateTestChecks/asm.py                      |   18 -
 163 files changed, 17261 deletions(-)
 delete mode 100644 include/llvm/BinaryFormat/ELFRelocs/RISCV.def
 delete mode 100644 lib/Target/RISCV/AsmParser/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/AsmParser/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
 delete mode 100644 lib/Target/RISCV/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/Disassembler/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/Disassembler/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
 delete mode 100644 lib/Target/RISCV/InstPrinter/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/InstPrinter/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp
 delete mode 100644 lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h
 delete mode 100644 lib/Target/RISCV/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
 delete mode 100644 lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h
 delete mode 100644 lib/Target/RISCV/RISCV.h
 delete mode 100644 lib/Target/RISCV/RISCV.td
 delete mode 100644 lib/Target/RISCV/RISCVAsmPrinter.cpp
 delete mode 100644 lib/Target/RISCV/RISCVCallingConv.td
 delete mode 100644 lib/Target/RISCV/RISCVFrameLowering.cpp
 delete mode 100644 lib/Target/RISCV/RISCVFrameLowering.h
 delete mode 100644 lib/Target/RISCV/RISCVISelDAGToDAG.cpp
 delete mode 100644 lib/Target/RISCV/RISCVISelLowering.cpp
 delete mode 100644 lib/Target/RISCV/RISCVISelLowering.h
 delete mode 100644 lib/Target/RISCV/RISCVInstrFormats.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrFormatsC.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfo.cpp
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfo.h
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfo.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoA.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoC.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoD.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoF.td
 delete mode 100644 lib/Target/RISCV/RISCVInstrInfoM.td
 delete mode 100644 lib/Target/RISCV/RISCVMCInstLower.cpp
 delete mode 100644 lib/Target/RISCV/RISCVMachineFunctionInfo.h
 delete mode 100644 lib/Target/RISCV/RISCVRegisterInfo.cpp
 delete mode 100644 lib/Target/RISCV/RISCVRegisterInfo.h
 delete mode 100644 lib/Target/RISCV/RISCVRegisterInfo.td
 delete mode 100644 lib/Target/RISCV/RISCVSubtarget.cpp
 delete mode 100644 lib/Target/RISCV/RISCVSubtarget.h
 delete mode 100644 lib/Target/RISCV/RISCVTargetMachine.cpp
 delete mode 100644 lib/Target/RISCV/RISCVTargetMachine.h
 delete mode 100644 lib/Target/RISCV/TargetInfo/CMakeLists.txt
 delete mode 100644 lib/Target/RISCV/TargetInfo/LLVMBuild.txt
 delete mode 100644 lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp
 delete mode 100644 test/CodeGen/RISCV/addc-adde-sube-subc.ll
 delete mode 100644 test/CodeGen/RISCV/alloca.ll
 delete mode 100644 test/CodeGen/RISCV/alu32.ll
 delete mode 100644 test/CodeGen/RISCV/analyze-branch.ll
 delete mode 100644 test/CodeGen/RISCV/bare-select.ll
 delete mode 100644 test/CodeGen/RISCV/blockaddress.ll
 delete mode 100644 test/CodeGen/RISCV/branch-relaxation.ll
 delete mode 100644 test/CodeGen/RISCV/branch.ll
 delete mode 100644 test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll
 delete mode 100644 test/CodeGen/RISCV/byval.ll
 delete mode 100644 test/CodeGen/RISCV/calling-conv-sext-zext.ll
 delete mode 100644 test/CodeGen/RISCV/calling-conv.ll
 delete mode 100644 test/CodeGen/RISCV/calls.ll
 delete mode 100644 test/CodeGen/RISCV/div.ll
 delete mode 100644 test/CodeGen/RISCV/fp128.ll
 delete mode 100644 test/CodeGen/RISCV/frame.ll
 delete mode 100644 test/CodeGen/RISCV/frameaddr-returnaddr.ll
 delete mode 100644 test/CodeGen/RISCV/get-setcc-result-type.ll
 delete mode 100644 test/CodeGen/RISCV/i32-icmp.ll
 delete mode 100644 test/CodeGen/RISCV/imm.ll
 delete mode 100644 test/CodeGen/RISCV/indirectbr.ll
 delete mode 100644 test/CodeGen/RISCV/inline-asm.ll
 delete mode 100644 test/CodeGen/RISCV/jumptable.ll
 delete mode 100644 test/CodeGen/RISCV/large-stack.ll
 delete mode 100644 test/CodeGen/RISCV/lit.local.cfg
 delete mode 100644 test/CodeGen/RISCV/mem.ll
 delete mode 100644 test/CodeGen/RISCV/mul.ll
 delete mode 100644 test/CodeGen/RISCV/rem.ll
 delete mode 100644 test/CodeGen/RISCV/rotl-rotr.ll
 delete mode 100644 test/CodeGen/RISCV/select-cc.ll
 delete mode 100644 test/CodeGen/RISCV/sext-zext-trunc.ll
 delete mode 100644 test/CodeGen/RISCV/shifts.ll
 delete mode 100644 test/CodeGen/RISCV/vararg.ll
 delete mode 100644 test/CodeGen/RISCV/wide-mem.ll
 delete mode 100644 test/MC/RISCV/cnop.s
 delete mode 100644 test/MC/RISCV/csr-aliases.s
 delete mode 100644 test/MC/RISCV/elf-flags.s
 delete mode 100644 test/MC/RISCV/elf-header.s
 delete mode 100644 test/MC/RISCV/fixups-compressed.s
 delete mode 100644 test/MC/RISCV/fixups-diagnostics.s
 delete mode 100644 test/MC/RISCV/fixups.s
 delete mode 100644 test/MC/RISCV/hilo-constaddr.s
 delete mode 100644 test/MC/RISCV/lit.local.cfg
 delete mode 100644 test/MC/RISCV/priv-invalid.s
 delete mode 100644 test/MC/RISCV/priv-valid.s
 delete mode 100644 test/MC/RISCV/relocations.s
 delete mode 100644 test/MC/RISCV/rv32-relaxation.s
 delete mode 100644 test/MC/RISCV/rv32a-invalid.s
 delete mode 100644 test/MC/RISCV/rv32a-valid.s
 delete mode 100644 test/MC/RISCV/rv32c-invalid.s
 delete mode 100644 test/MC/RISCV/rv32c-only-valid.s
 delete mode 100644 test/MC/RISCV/rv32c-valid.s
 delete mode 100644 test/MC/RISCV/rv32d-invalid.s
 delete mode 100644 test/MC/RISCV/rv32d-valid.s
 delete mode 100644 test/MC/RISCV/rv32dc-invalid.s
 delete mode 100644 test/MC/RISCV/rv32dc-valid.s
 delete mode 100644 test/MC/RISCV/rv32f-invalid.s
 delete mode 100644 test/MC/RISCV/rv32f-valid.s
 delete mode 100644 test/MC/RISCV/rv32fc-invalid.s
 delete mode 100644 test/MC/RISCV/rv32fc-valid.s
 delete mode 100644 test/MC/RISCV/rv32i-aliases-invalid.s
 delete mode 100644 test/MC/RISCV/rv32i-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv32i-invalid.s
 delete mode 100644 test/MC/RISCV/rv32i-valid.s
 delete mode 100644 test/MC/RISCV/rv32m-invalid.s
 delete mode 100644 test/MC/RISCV/rv32m-valid.s
 delete mode 100644 test/MC/RISCV/rv64-relaxation.s
 delete mode 100644 test/MC/RISCV/rv64a-invalid.s
 delete mode 100644 test/MC/RISCV/rv64a-valid.s
 delete mode 100644 test/MC/RISCV/rv64c-invalid.s
 delete mode 100644 test/MC/RISCV/rv64c-valid.s
 delete mode 100644 test/MC/RISCV/rv64d-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64d-invalid.s
 delete mode 100644 test/MC/RISCV/rv64d-valid.s
 delete mode 100644 test/MC/RISCV/rv64dc-valid.s
 delete mode 100644 test/MC/RISCV/rv64f-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64f-invalid.s
 delete mode 100644 test/MC/RISCV/rv64f-valid.s
 delete mode 100644 test/MC/RISCV/rv64i-aliases-invalid.s
 delete mode 100644 test/MC/RISCV/rv64i-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rv64i-invalid.s
 delete mode 100644 test/MC/RISCV/rv64i-valid.s
 delete mode 100644 test/MC/RISCV/rv64m-valid.s
 delete mode 100644 test/MC/RISCV/rvd-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rvf-aliases-valid.s
 delete mode 100644 test/MC/RISCV/rvi-aliases-valid.s
 delete mode 100644 test/Object/RISCV/elf-flags.yaml
 delete mode 100644 test/Object/RISCV/lit.local.cfg

diff --git a/docs/CompilerWriterInfo.rst b/docs/CompilerWriterInfo.rst
index 60f102472c6..4e5d8dc2026 100644
--- a/docs/CompilerWriterInfo.rst
+++ b/docs/CompilerWriterInfo.rst
@@ -74,10 +74,6 @@ AMDGPU
 
 Refer to :doc:`AMDGPUUsage` for additional documentation.
 
-RISC-V
-------
-* `RISC-V User-Level ISA Specification <https://riscv.org/specifications/>`_
-
 SPARC
 -----
 
diff --git a/include/llvm/ADT/Triple.h b/include/llvm/ADT/Triple.h
index 00fa9c08299..965bd246b83 100644
--- a/include/llvm/ADT/Triple.h
+++ b/include/llvm/ADT/Triple.h
@@ -66,8 +66,6 @@ public:
     ppc64le,        // PPC64LE: powerpc64le
     r600,           // R600: AMD GPUs HD2XXX - HD6XXX
     amdgcn,         // AMDGCN: AMD GCN GPUs
-    riscv32,        // RISC-V (32-bit): riscv32
-    riscv64,        // RISC-V (64-bit): riscv64
     sparc,          // Sparc: sparc
     sparcv9,        // Sparcv9: Sparcv9
     sparcel,        // Sparc: (endianness = little). NB: 'Sparcle' is a CPU variant
diff --git a/include/llvm/BinaryFormat/ELF.h b/include/llvm/BinaryFormat/ELF.h
index a2321e72c98..38090afb0c3 100644
--- a/include/llvm/BinaryFormat/ELF.h
+++ b/include/llvm/BinaryFormat/ELF.h
@@ -309,7 +309,6 @@ enum {
   EM_NORC = 218,          // Nanoradio Optimized RISC
   EM_CSR_KALIMBA = 219,   // CSR Kalimba architecture family
   EM_AMDGPU = 224,        // AMD GPU architecture
-  EM_RISCV = 243,         // RISC-V
   EM_LANAI = 244,         // Lanai 32-bit processor
   EM_BPF = 247,           // Linux kernel bpf virtual machine
 
@@ -618,22 +617,6 @@ enum {
 #include "ELFRelocs/Lanai.def"
 };
 
-// RISCV Specific e_flags
-enum : unsigned {
-  EF_RISCV_RVC = 0x0001,
-  EF_RISCV_FLOAT_ABI = 0x0006,
-  EF_RISCV_FLOAT_ABI_SOFT = 0x0000,
-  EF_RISCV_FLOAT_ABI_SINGLE = 0x0002,
-  EF_RISCV_FLOAT_ABI_DOUBLE = 0x0004,
-  EF_RISCV_FLOAT_ABI_QUAD = 0x0006,
-  EF_RISCV_RVE = 0x0008
-};
-
-// ELF Relocation types for RISC-V
-enum {
-#include "ELFRelocs/RISCV.def"
-};
-
 // ELF Relocation types for S390/zSeries
 enum {
 #include "ELFRelocs/SystemZ.def"
diff --git a/include/llvm/BinaryFormat/ELFRelocs/RISCV.def b/include/llvm/BinaryFormat/ELFRelocs/RISCV.def
deleted file mode 100644
index 5cc4c0ec302..00000000000
--- a/include/llvm/BinaryFormat/ELFRelocs/RISCV.def
+++ /dev/null
@@ -1,59 +0,0 @@
-
-#ifndef ELF_RELOC
-#error "ELF_RELOC must be defined"
-#endif
-
-ELF_RELOC(R_RISCV_NONE,               0)
-ELF_RELOC(R_RISCV_32,                 1)
-ELF_RELOC(R_RISCV_64,                 2)
-ELF_RELOC(R_RISCV_RELATIVE,           3)
-ELF_RELOC(R_RISCV_COPY,               4)
-ELF_RELOC(R_RISCV_JUMP_SLOT,          5)
-ELF_RELOC(R_RISCV_TLS_DTPMOD32,       6)
-ELF_RELOC(R_RISCV_TLS_DTPMOD64,       7)
-ELF_RELOC(R_RISCV_TLS_DTPREL32,       8)
-ELF_RELOC(R_RISCV_TLS_DTPREL64,       9)
-ELF_RELOC(R_RISCV_TLS_TPREL32,       10)
-ELF_RELOC(R_RISCV_TLS_TPREL64,       11)
-ELF_RELOC(R_RISCV_BRANCH,            16)
-ELF_RELOC(R_RISCV_JAL,               17)
-ELF_RELOC(R_RISCV_CALL,              18)
-ELF_RELOC(R_RISCV_CALL_PLT,          19)
-ELF_RELOC(R_RISCV_GOT_HI20,          20)
-ELF_RELOC(R_RISCV_TLS_GOT_HI20,      21)
-ELF_RELOC(R_RISCV_TLS_GD_HI20,       22)
-ELF_RELOC(R_RISCV_PCREL_HI20,        23)
-ELF_RELOC(R_RISCV_PCREL_LO12_I,      24)
-ELF_RELOC(R_RISCV_PCREL_LO12_S,      25)
-ELF_RELOC(R_RISCV_HI20,              26)
-ELF_RELOC(R_RISCV_LO12_I,            27)
-ELF_RELOC(R_RISCV_LO12_S,            28)
-ELF_RELOC(R_RISCV_TPREL_HI20,        29)
-ELF_RELOC(R_RISCV_TPREL_LO12_I,      30)
-ELF_RELOC(R_RISCV_TPREL_LO12_S,      31)
-ELF_RELOC(R_RISCV_TPREL_ADD,         32)
-ELF_RELOC(R_RISCV_ADD8,              33)
-ELF_RELOC(R_RISCV_ADD16,             34)
-ELF_RELOC(R_RISCV_ADD32,             35)
-ELF_RELOC(R_RISCV_ADD64,             36)
-ELF_RELOC(R_RISCV_SUB8,              37)
-ELF_RELOC(R_RISCV_SUB16,             38)
-ELF_RELOC(R_RISCV_SUB32,             39)
-ELF_RELOC(R_RISCV_SUB64,             40)
-ELF_RELOC(R_RISCV_GNU_VTINHERIT,     41)
-ELF_RELOC(R_RISCV_GNU_VTENTRY,       42)
-ELF_RELOC(R_RISCV_ALIGN,             43)
-ELF_RELOC(R_RISCV_RVC_BRANCH,        44)
-ELF_RELOC(R_RISCV_RVC_JUMP,          45)
-ELF_RELOC(R_RISCV_RVC_LUI,           46)
-ELF_RELOC(R_RISCV_GPREL_I,           47)
-ELF_RELOC(R_RISCV_GPREL_S,           48)
-ELF_RELOC(R_RISCV_TPREL_I,           49)
-ELF_RELOC(R_RISCV_TPREL_S,           50)
-ELF_RELOC(R_RISCV_RELAX,             51)
-ELF_RELOC(R_RISCV_SUB6,              52)
-ELF_RELOC(R_RISCV_SET6,              53)
-ELF_RELOC(R_RISCV_SET8,              54)
-ELF_RELOC(R_RISCV_SET16,             55)
-ELF_RELOC(R_RISCV_SET32,             56)
-ELF_RELOC(R_RISCV_32_PCREL,          57)
diff --git a/include/llvm/Object/ELFObjectFile.h b/include/llvm/Object/ELFObjectFile.h
index 4d001039238..5eda163acfc 100644
--- a/include/llvm/Object/ELFObjectFile.h
+++ b/include/llvm/Object/ELFObjectFile.h
@@ -80,8 +80,6 @@ public:
 
   SubtargetFeatures getARMFeatures() const;
 
-  SubtargetFeatures getRISCVFeatures() const;
-
   void setARMSubArch(Triple &TheTriple) const override;
 };
 
@@ -983,8 +981,6 @@ StringRef ELFObjectFile<ELFT>::getFileFormatName() const {
       return "ELF32-mips";
     case ELF::EM_PPC:
       return "ELF32-ppc";
-    case ELF::EM_RISCV:
-      return "ELF32-riscv";
     case ELF::EM_SPARC:
     case ELF::EM_SPARC32PLUS:
       return "ELF32-sparc";
@@ -1005,8 +1001,6 @@ StringRef ELFObjectFile<ELFT>::getFileFormatName() const {
       return (IsLittleEndian ? "ELF64-aarch64-little" : "ELF64-aarch64-big");
     case ELF::EM_PPC64:
       return "ELF64-ppc64";
-    case ELF::EM_RISCV:
-      return "ELF64-riscv";
     case ELF::EM_S390:
       return "ELF64-s390";
     case ELF::EM_SPARCV9:
@@ -1059,15 +1053,6 @@ template <class ELFT> Triple::ArchType ELFObjectFile<ELFT>::getArch() const {
     return Triple::ppc;
   case ELF::EM_PPC64:
     return IsLittleEndian ? Triple::ppc64le : Triple::ppc64;
-  case ELF::EM_RISCV:
-    switch (EF.getHeader()->e_ident[ELF::EI_CLASS]) {
-    case ELF::ELFCLASS32:
-      return Triple::riscv32;
-    case ELF::ELFCLASS64:
-      return Triple::riscv64;
-    default:
-      report_fatal_error("Invalid ELFCLASS!");
-    }
   case ELF::EM_S390:
     return Triple::systemz;
 
diff --git a/include/llvm/module.modulemap b/include/llvm/module.modulemap
index d8b07c4f54d..de27c5f62bd 100644
--- a/include/llvm/module.modulemap
+++ b/include/llvm/module.modulemap
@@ -56,7 +56,6 @@ module LLVM_BinaryFormat {
     textual header "BinaryFormat/ELFRelocs/Mips.def"
     textual header "BinaryFormat/ELFRelocs/PowerPC64.def"
     textual header "BinaryFormat/ELFRelocs/PowerPC.def"
-    textual header "BinaryFormat/ELFRelocs/RISCV.def"
     textual header "BinaryFormat/ELFRelocs/Sparc.def"
     textual header "BinaryFormat/ELFRelocs/SystemZ.def"
     textual header "BinaryFormat/ELFRelocs/x86_64.def"
diff --git a/lib/Object/ELF.cpp b/lib/Object/ELF.cpp
index 92a64f48924..2b9244c3c7c 100644
--- a/lib/Object/ELF.cpp
+++ b/lib/Object/ELF.cpp
@@ -102,13 +102,6 @@ StringRef llvm::object::getELFRelocationTypeName(uint32_t Machine,
       break;
     }
     break;
-  case ELF::EM_RISCV:
-    switch (Type) {
-#include "llvm/BinaryFormat/ELFRelocs/RISCV.def"
-    default:
-      break;
-    }
-    break;
   case ELF::EM_S390:
     switch (Type) {
 #include "llvm/BinaryFormat/ELFRelocs/SystemZ.def"
diff --git a/lib/Object/ELFObjectFile.cpp b/lib/Object/ELFObjectFile.cpp
index e806c8f28b1..3c1bdf5a1de 100644
--- a/lib/Object/ELFObjectFile.cpp
+++ b/lib/Object/ELFObjectFile.cpp
@@ -238,25 +238,12 @@ SubtargetFeatures ELFObjectFileBase::getARMFeatures() const {
   return Features;
 }
 
-SubtargetFeatures ELFObjectFileBase::getRISCVFeatures() const {
-  SubtargetFeatures Features;
-  unsigned PlatformFlags = getPlatformFlags();
-
-  if (PlatformFlags & ELF::EF_RISCV_RVC) {
-    Features.AddFeature("c");
-  }
-
-  return Features;
-}
-
 SubtargetFeatures ELFObjectFileBase::getFeatures() const {
   switch (getEMachine()) {
   case ELF::EM_MIPS:
     return getMIPSFeatures();
   case ELF::EM_ARM:
     return getARMFeatures();
-  case ELF::EM_RISCV:
-    return getRISCVFeatures();
   default:
     return SubtargetFeatures();
   }
diff --git a/lib/ObjectYAML/ELFYAML.cpp b/lib/ObjectYAML/ELFYAML.cpp
index 928b7b2b1c2..084eafc03c0 100644
--- a/lib/ObjectYAML/ELFYAML.cpp
+++ b/lib/ObjectYAML/ELFYAML.cpp
@@ -213,7 +213,6 @@ void ScalarEnumerationTraits<ELFYAML::ELF_EM>::enumeration(
   ECase(EM_78KOR);
   ECase(EM_56800EX);
   ECase(EM_AMDGPU);
-  ECase(EM_RISCV);
   ECase(EM_LANAI);
   ECase(EM_BPF);
 #undef ECase
@@ -360,14 +359,6 @@ void ScalarBitSetTraits<ELFYAML::ELF_EF>::bitset(IO &IO,
     BCase(EF_AVR_ARCH_XMEGA6);
     BCase(EF_AVR_ARCH_XMEGA7);
     break;
-  case ELF::EM_RISCV:
-    BCase(EF_RISCV_RVC);
-    BCaseMask(EF_RISCV_FLOAT_ABI_SOFT, EF_RISCV_FLOAT_ABI);
-    BCaseMask(EF_RISCV_FLOAT_ABI_SINGLE, EF_RISCV_FLOAT_ABI);
-    BCaseMask(EF_RISCV_FLOAT_ABI_DOUBLE, EF_RISCV_FLOAT_ABI);
-    BCaseMask(EF_RISCV_FLOAT_ABI_QUAD, EF_RISCV_FLOAT_ABI);
-    BCase(EF_RISCV_RVE);
-    break;
   case ELF::EM_AMDGPU:
     BCaseMask(EF_AMDGPU_MACH_NONE, EF_AMDGPU_MACH);
     BCaseMask(EF_AMDGPU_MACH_R600_R600, EF_AMDGPU_MACH);
@@ -625,9 +616,6 @@ void ScalarEnumerationTraits<ELFYAML::ELF_REL>::enumeration(
   case ELF::EM_ARC:
 #include "llvm/BinaryFormat/ELFRelocs/ARC.def"
     break;
-  case ELF::EM_RISCV:
-#include "llvm/BinaryFormat/ELFRelocs/RISCV.def"
-    break;
   case ELF::EM_LANAI:
 #include "llvm/BinaryFormat/ELFRelocs/Lanai.def"
     break;
diff --git a/lib/Support/Triple.cpp b/lib/Support/Triple.cpp
index 5062fc43266..9b1a739c911 100644
--- a/lib/Support/Triple.cpp
+++ b/lib/Support/Triple.cpp
@@ -41,8 +41,6 @@ StringRef Triple::getArchTypeName(ArchType Kind) {
   case ppc:            return "powerpc";
   case r600:           return "r600";
   case amdgcn:         return "amdgcn";
-  case riscv32:        return "riscv32";
-  case riscv64:        return "riscv64";
   case sparc:          return "sparc";
   case sparcv9:        return "sparcv9";
   case sparcel:        return "sparcel";
@@ -143,9 +141,6 @@ StringRef Triple::getArchTypePrefix(ArchType Kind) {
   case shave:       return "shave";
   case wasm32:
   case wasm64:      return "wasm";
-
-  case riscv32:
-  case riscv64:     return "riscv";
   }
 }
 
@@ -278,8 +273,6 @@ Triple::ArchType Triple::getArchTypeForLLVMName(StringRef Name) {
     .Case("ppc64le", ppc64le)
     .Case("r600", r600)
     .Case("amdgcn", amdgcn)
-    .Case("riscv32", riscv32)
-    .Case("riscv64", riscv64)
     .Case("hexagon", hexagon)
     .Case("sparc", sparc)
     .Case("sparcel", sparcel)
@@ -405,8 +398,6 @@ static Triple::ArchType parseArch(StringRef ArchName) {
     .Case("nios2", Triple::nios2)
     .Case("r600", Triple::r600)
     .Case("amdgcn", Triple::amdgcn)
-    .Case("riscv32", Triple::riscv32)
-    .Case("riscv64", Triple::riscv64)
     .Case("hexagon", Triple::hexagon)
     .Cases("s390x", "systemz", Triple::systemz)
     .Case("sparc", Triple::sparc)
@@ -656,8 +647,6 @@ static Triple::ObjectFormatType getDefaultFormat(const Triple &T) {
   case Triple::r600:
   case Triple::renderscript32:
   case Triple::renderscript64:
-  case Triple::riscv32:
-  case Triple::riscv64:
   case Triple::shave:
   case Triple::sparc:
   case Triple::sparcel:
@@ -1196,7 +1185,6 @@ static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
   case llvm::Triple::nvptx:
   case llvm::Triple::ppc:
   case llvm::Triple::r600:
-  case llvm::Triple::riscv32:
   case llvm::Triple::sparc:
   case llvm::Triple::sparcel:
   case llvm::Triple::tce:
@@ -1226,7 +1214,6 @@ static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
   case llvm::Triple::nvptx64:
   case llvm::Triple::ppc64:
   case llvm::Triple::ppc64le:
-  case llvm::Triple::riscv64:
   case llvm::Triple::sparcv9:
   case llvm::Triple::systemz:
   case llvm::Triple::x86_64:
@@ -1281,7 +1268,6 @@ Triple Triple::get32BitArchVariant() const {
   case Triple::nvptx:
   case Triple::ppc:
   case Triple::r600:
-  case Triple::riscv32:
   case Triple::sparc:
   case Triple::sparcel:
   case Triple::tce:
@@ -1305,7 +1291,6 @@ Triple Triple::get32BitArchVariant() const {
   case Triple::nvptx64:        T.setArch(Triple::nvptx);   break;
   case Triple::ppc64:          T.setArch(Triple::ppc);     break;
   case Triple::sparcv9:        T.setArch(Triple::sparc);   break;
-  case Triple::riscv64:        T.setArch(Triple::riscv32); break;
   case Triple::x86_64:         T.setArch(Triple::x86);     break;
   case Triple::amdil64:        T.setArch(Triple::amdil);   break;
   case Triple::hsail64:        T.setArch(Triple::hsail);   break;
@@ -1350,7 +1335,6 @@ Triple Triple::get64BitArchVariant() const {
   case Triple::nvptx64:
   case Triple::ppc64:
   case Triple::ppc64le:
-  case Triple::riscv64:
   case Triple::sparcv9:
   case Triple::systemz:
   case Triple::x86_64:
@@ -1367,7 +1351,6 @@ Triple Triple::get64BitArchVariant() const {
   case Triple::nvptx:           T.setArch(Triple::nvptx64);    break;
   case Triple::ppc:             T.setArch(Triple::ppc64);      break;
   case Triple::sparc:           T.setArch(Triple::sparcv9);    break;
-  case Triple::riscv32:         T.setArch(Triple::riscv64);    break;
   case Triple::x86:             T.setArch(Triple::x86_64);     break;
   case Triple::amdil:           T.setArch(Triple::amdil64);    break;
   case Triple::hsail:           T.setArch(Triple::hsail64);    break;
@@ -1402,8 +1385,6 @@ Triple Triple::getBigEndianArchVariant() const {
   case Triple::nvptx64:
   case Triple::nvptx:
   case Triple::r600:
-  case Triple::riscv32:
-  case Triple::riscv64:
   case Triple::shave:
   case Triple::spir64:
   case Triple::spir:
@@ -1490,8 +1471,6 @@ bool Triple::isLittleEndian() const {
   case Triple::nvptx:
   case Triple::ppc64le:
   case Triple::r600:
-  case Triple::riscv32:
-  case Triple::riscv64:
   case Triple::shave:
   case Triple::sparcel:
   case Triple::spir64:
diff --git a/lib/Target/LLVMBuild.txt b/lib/Target/LLVMBuild.txt
index 0d899a9c782..87d5ce11751 100644
--- a/lib/Target/LLVMBuild.txt
+++ b/lib/Target/LLVMBuild.txt
@@ -32,7 +32,6 @@ subdirectories =
  Mips
  Nios2
  PowerPC
- RISCV
  Sparc
  SystemZ
  WebAssembly
diff --git a/lib/Target/RISCV/AsmParser/CMakeLists.txt b/lib/Target/RISCV/AsmParser/CMakeLists.txt
deleted file mode 100644
index 10d0c89537c..00000000000
--- a/lib/Target/RISCV/AsmParser/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVAsmParser
-  RISCVAsmParser.cpp
-  )
diff --git a/lib/Target/RISCV/AsmParser/LLVMBuild.txt b/lib/Target/RISCV/AsmParser/LLVMBuild.txt
deleted file mode 100644
index a9ad92c872e..00000000000
--- a/lib/Target/RISCV/AsmParser/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/AsmParser/LLVMBuild.txt ---------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVAsmParser
-parent = RISCV
-required_libraries = MC MCParser RISCVDesc RISCVInfo Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp b/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
deleted file mode 100644
index 035c1ef6ac7..00000000000
--- a/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp
+++ /dev/null
@@ -1,967 +0,0 @@
-//===-- RISCVAsmParser.cpp - Parse RISCV assembly to MCInst instructions --===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVBaseInfo.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/StringSwitch.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCParser/MCAsmLexer.h"
-#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
-#include "llvm/MC/MCParser/MCTargetAsmParser.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/Support/Casting.h"
-#include "llvm/Support/TargetRegistry.h"
-
-using namespace llvm;
-
-namespace {
-struct RISCVOperand;
-
-class RISCVAsmParser : public MCTargetAsmParser {
-  SMLoc getLoc() const { return getParser().getTok().getLoc(); }
-  bool isRV64() const { return getSTI().hasFeature(RISCV::Feature64Bit); }
-
-  unsigned validateTargetOperandClass(MCParsedAsmOperand &Op,
-                                      unsigned Kind) override;
-
-  bool generateImmOutOfRangeError(OperandVector &Operands, uint64_t ErrorInfo,
-                                  int Lower, int Upper, Twine Msg);
-
-  bool MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
-                               OperandVector &Operands, MCStreamer &Out,
-                               uint64_t &ErrorInfo,
-                               bool MatchingInlineAsm) override;
-
-  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;
-
-  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
-                        SMLoc NameLoc, OperandVector &Operands) override;
-
-  bool ParseDirective(AsmToken DirectiveID) override;
-
-// Auto-generated instruction matching functions
-#define GET_ASSEMBLER_HEADER
-#include "RISCVGenAsmMatcher.inc"
-
-  OperandMatchResultTy parseImmediate(OperandVector &Operands);
-  OperandMatchResultTy parseRegister(OperandVector &Operands,
-                                     bool AllowParens = false);
-  OperandMatchResultTy parseMemOpBaseReg(OperandVector &Operands);
-  OperandMatchResultTy parseOperandWithModifier(OperandVector &Operands);
-
-  bool parseOperand(OperandVector &Operands);
-
-public:
-  enum RISCVMatchResultTy {
-    Match_Dummy = FIRST_TARGET_MATCH_RESULT_TY,
-#define GET_OPERAND_DIAGNOSTIC_TYPES
-#include "RISCVGenAsmMatcher.inc"
-#undef GET_OPERAND_DIAGNOSTIC_TYPES
-  };
-
-  static bool classifySymbolRef(const MCExpr *Expr,
-                                RISCVMCExpr::VariantKind &Kind,
-                                int64_t &Addend);
-
-  RISCVAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
-                 const MCInstrInfo &MII, const MCTargetOptions &Options)
-      : MCTargetAsmParser(Options, STI, MII) {
-    setAvailableFeatures(ComputeAvailableFeatures(STI.getFeatureBits()));
-  }
-};
-
-/// RISCVOperand - Instances of this class represent a parsed machine
-/// instruction
-struct RISCVOperand : public MCParsedAsmOperand {
-
-  enum KindTy {
-    Token,
-    Register,
-    Immediate,
-  } Kind;
-
-  bool IsRV64;
-
-  struct RegOp {
-    unsigned RegNum;
-  };
-
-  struct ImmOp {
-    const MCExpr *Val;
-  };
-
-  SMLoc StartLoc, EndLoc;
-  union {
-    StringRef Tok;
-    RegOp Reg;
-    ImmOp Imm;
-  };
-
-  RISCVOperand(KindTy K) : MCParsedAsmOperand(), Kind(K) {}
-
-public:
-  RISCVOperand(const RISCVOperand &o) : MCParsedAsmOperand() {
-    Kind = o.Kind;
-    IsRV64 = o.IsRV64;
-    StartLoc = o.StartLoc;
-    EndLoc = o.EndLoc;
-    switch (Kind) {
-    case Register:
-      Reg = o.Reg;
-      break;
-    case Immediate:
-      Imm = o.Imm;
-      break;
-    case Token:
-      Tok = o.Tok;
-      break;
-    }
-  }
-
-  bool isToken() const override { return Kind == Token; }
-  bool isReg() const override { return Kind == Register; }
-  bool isImm() const override { return Kind == Immediate; }
-  bool isMem() const override { return false; }
-
-  bool evaluateConstantImm(int64_t &Imm, RISCVMCExpr::VariantKind &VK) const {
-    const MCExpr *Val = getImm();
-    bool Ret = false;
-    if (auto *RE = dyn_cast<RISCVMCExpr>(Val)) {
-      Ret = RE->evaluateAsConstant(Imm);
-      VK = RE->getKind();
-    } else if (auto CE = dyn_cast<MCConstantExpr>(Val)) {
-      Ret = true;
-      VK = RISCVMCExpr::VK_RISCV_None;
-      Imm = CE->getValue();
-    }
-    return Ret;
-  }
-
-  // True if operand is a symbol with no modifiers, or a constant with no
-  // modifiers and isShiftedInt<N-1, 1>(Op).
-  template <int N> bool isBareSimmNLsb0() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    bool IsValid;
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = isShiftedInt<N - 1, 1>(Imm);
-    return IsValid && VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  // Predicate methods for AsmOperands defined in RISCVInstrInfo.td
-
-  /// Return true if the operand is a valid for the fence instruction e.g.
-  /// ('iorw').
-  bool isFenceArg() const {
-    if (!isImm())
-      return false;
-    const MCExpr *Val = getImm();
-    auto *SVal = dyn_cast<MCSymbolRefExpr>(Val);
-    if (!SVal || SVal->getKind() != MCSymbolRefExpr::VK_None)
-      return false;
-
-    StringRef Str = SVal->getSymbol().getName();
-    // Letters must be unique, taken from 'iorw', and in ascending order. This
-    // holds as long as each individual character is one of 'iorw' and is
-    // greater than the previous character.
-    char Prev = '\0';
-    for (char c : Str) {
-      if (c != 'i' && c != 'o' && c != 'r' && c != 'w')
-        return false;
-      if (c <= Prev)
-        return false;
-      Prev = c;
-    }
-    return true;
-  }
-
-  /// Return true if the operand is a valid floating point rounding mode.
-  bool isFRMArg() const {
-    if (!isImm())
-      return false;
-    const MCExpr *Val = getImm();
-    auto *SVal = dyn_cast<MCSymbolRefExpr>(Val);
-    if (!SVal || SVal->getKind() != MCSymbolRefExpr::VK_None)
-      return false;
-
-    StringRef Str = SVal->getSymbol().getName();
-
-    return RISCVFPRndMode::stringToRoundingMode(Str) != RISCVFPRndMode::Invalid;
-  }
-
-  bool isUImmLog2XLen() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    if (!evaluateConstantImm(Imm, VK) || VK != RISCVMCExpr::VK_RISCV_None)
-      return false;
-    return (isRV64() && isUInt<6>(Imm)) || isUInt<5>(Imm);
-  }
-
-  bool isUImmLog2XLenNonZero() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    if (!evaluateConstantImm(Imm, VK) || VK != RISCVMCExpr::VK_RISCV_None)
-      return false;
-    if (Imm == 0)
-      return false;
-    return (isRV64() && isUInt<6>(Imm)) || isUInt<5>(Imm);
-  }
-
-  bool isUImm5() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isUInt<5>(Imm) && VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm5NonZero() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isUInt<5>(Imm) && (Imm != 0) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm6() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = isInt<6>(Imm);
-    return IsValid &&
-           (VK == RISCVMCExpr::VK_RISCV_None || VK == RISCVMCExpr::VK_RISCV_LO);
-  }
-
-  bool isSImm6NonZero() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = ((Imm != 0) && isInt<6>(Imm));
-    return IsValid &&
-           (VK == RISCVMCExpr::VK_RISCV_None || VK == RISCVMCExpr::VK_RISCV_LO);
-  }
-
-  bool isCLUIImm() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && (Imm != 0) &&
-           (isUInt<5>(Imm) || (Imm >= 0xfffe0 && Imm <= 0xfffff)) &&
-            VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm7Lsb00() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isShiftedUInt<5, 2>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm8Lsb00() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isShiftedUInt<6, 2>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm8Lsb000() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isShiftedUInt<5, 3>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm9Lsb0() const { return isBareSimmNLsb0<9>(); }
-
-  bool isUImm9Lsb000() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isShiftedUInt<6, 3>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm10Lsb00NonZero() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isShiftedUInt<8, 2>(Imm) && (Imm != 0) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm12() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = isInt<12>(Imm);
-    return IsValid && (VK == RISCVMCExpr::VK_RISCV_None ||
-                       VK == RISCVMCExpr::VK_RISCV_LO ||
-                       VK == RISCVMCExpr::VK_RISCV_PCREL_LO);
-  }
-
-  bool isSImm12Lsb0() const { return isBareSimmNLsb0<12>(); }
-
-  bool isUImm12() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && isUInt<12>(Imm) && VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isSImm13Lsb0() const { return isBareSimmNLsb0<13>(); }
-
-  bool isSImm10Lsb0000NonZero() const {
-    int64_t Imm;
-    RISCVMCExpr::VariantKind VK;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    return IsConstantImm && (Imm != 0) && isShiftedInt<6, 4>(Imm) &&
-           VK == RISCVMCExpr::VK_RISCV_None;
-  }
-
-  bool isUImm20() const {
-    RISCVMCExpr::VariantKind VK;
-    int64_t Imm;
-    bool IsValid;
-    if (!isImm())
-      return false;
-    bool IsConstantImm = evaluateConstantImm(Imm, VK);
-    if (!IsConstantImm)
-      IsValid = RISCVAsmParser::classifySymbolRef(getImm(), VK, Imm);
-    else
-      IsValid = isUInt<20>(Imm);
-    return IsValid && (VK == RISCVMCExpr::VK_RISCV_None ||
-                       VK == RISCVMCExpr::VK_RISCV_HI ||
-                       VK == RISCVMCExpr::VK_RISCV_PCREL_HI);
-  }
-
-  bool isSImm21Lsb0() const { return isBareSimmNLsb0<21>(); }
-
-  /// getStartLoc - Gets location of the first token of this operand
-  SMLoc getStartLoc() const override { return StartLoc; }
-  /// getEndLoc - Gets location of the last token of this operand
-  SMLoc getEndLoc() const override { return EndLoc; }
-  /// True if this operand is for an RV64 instruction
-  bool isRV64() const { return IsRV64; }
-
-  unsigned getReg() const override {
-    assert(Kind == Register && "Invalid type access!");
-    return Reg.RegNum;
-  }
-
-  const MCExpr *getImm() const {
-    assert(Kind == Immediate && "Invalid type access!");
-    return Imm.Val;
-  }
-
-  StringRef getToken() const {
-    assert(Kind == Token && "Invalid type access!");
-    return Tok;
-  }
-
-  void print(raw_ostream &OS) const override {
-    switch (Kind) {
-    case Immediate:
-      OS << *getImm();
-      break;
-    case Register:
-      OS << "<register x";
-      OS << getReg() << ">";
-      break;
-    case Token:
-      OS << "'" << getToken() << "'";
-      break;
-    }
-  }
-
-  static std::unique_ptr<RISCVOperand> createToken(StringRef Str, SMLoc S,
-                                                   bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(Token);
-    Op->Tok = Str;
-    Op->StartLoc = S;
-    Op->EndLoc = S;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  static std::unique_ptr<RISCVOperand> createReg(unsigned RegNo, SMLoc S,
-                                                 SMLoc E, bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(Register);
-    Op->Reg.RegNum = RegNo;
-    Op->StartLoc = S;
-    Op->EndLoc = E;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  static std::unique_ptr<RISCVOperand> createImm(const MCExpr *Val, SMLoc S,
-                                                 SMLoc E, bool IsRV64) {
-    auto Op = make_unique<RISCVOperand>(Immediate);
-    Op->Imm.Val = Val;
-    Op->StartLoc = S;
-    Op->EndLoc = E;
-    Op->IsRV64 = IsRV64;
-    return Op;
-  }
-
-  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
-    assert(Expr && "Expr shouldn't be null!");
-    int64_t Imm = 0;
-    bool IsConstant = false;
-    if (auto *RE = dyn_cast<RISCVMCExpr>(Expr)) {
-      IsConstant = RE->evaluateAsConstant(Imm);
-    } else if (auto *CE = dyn_cast<MCConstantExpr>(Expr)) {
-      IsConstant = true;
-      Imm = CE->getValue();
-    }
-
-    if (IsConstant)
-      Inst.addOperand(MCOperand::createImm(Imm));
-    else
-      Inst.addOperand(MCOperand::createExpr(Expr));
-  }
-
-  // Used by the TableGen Code
-  void addRegOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    Inst.addOperand(MCOperand::createReg(getReg()));
-  }
-
-  void addImmOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    addExpr(Inst, getImm());
-  }
-
-  void addFenceArgOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    // isFenceArg has validated the operand, meaning this cast is safe
-    auto SE = cast<MCSymbolRefExpr>(getImm());
-
-    unsigned Imm = 0;
-    for (char c : SE->getSymbol().getName()) {
-      switch (c) {
-        default: llvm_unreachable("FenceArg must contain only [iorw]");
-        case 'i': Imm |= RISCVFenceField::I; break;
-        case 'o': Imm |= RISCVFenceField::O; break;
-        case 'r': Imm |= RISCVFenceField::R; break;
-        case 'w': Imm |= RISCVFenceField::W; break;
-      }
-    }
-    Inst.addOperand(MCOperand::createImm(Imm));
-  }
-
-  // Returns the rounding mode represented by this RISCVOperand. Should only
-  // be called after checking isFRMArg.
-  RISCVFPRndMode::RoundingMode getRoundingMode() const {
-    // isFRMArg has validated the operand, meaning this cast is safe.
-    auto SE = cast<MCSymbolRefExpr>(getImm());
-    RISCVFPRndMode::RoundingMode FRM =
-        RISCVFPRndMode::stringToRoundingMode(SE->getSymbol().getName());
-    assert(FRM != RISCVFPRndMode::Invalid && "Invalid rounding mode");
-    return FRM;
-  }
-
-  void addFRMArgOperands(MCInst &Inst, unsigned N) const {
-    assert(N == 1 && "Invalid number of operands!");
-    Inst.addOperand(MCOperand::createImm(getRoundingMode()));
-  }
-};
-} // end anonymous namespace.
-
-#define GET_REGISTER_MATCHER
-#define GET_MATCHER_IMPLEMENTATION
-#include "RISCVGenAsmMatcher.inc"
-
-// Return the matching FPR64 register for the given FPR32.
-// FIXME: Ideally this function could be removed in favour of using
-// information from TableGen.
-unsigned convertFPR32ToFPR64(unsigned Reg) {
-  switch (Reg) {
-    default:
-      llvm_unreachable("Not a recognised FPR32 register");
-    case RISCV::F0_32: return RISCV::F0_64;
-    case RISCV::F1_32: return RISCV::F1_64;
-    case RISCV::F2_32: return RISCV::F2_64;
-    case RISCV::F3_32: return RISCV::F3_64;
-    case RISCV::F4_32: return RISCV::F4_64;
-    case RISCV::F5_32: return RISCV::F5_64;
-    case RISCV::F6_32: return RISCV::F6_64;
-    case RISCV::F7_32: return RISCV::F7_64;
-    case RISCV::F8_32: return RISCV::F8_64;
-    case RISCV::F9_32: return RISCV::F9_64;
-    case RISCV::F10_32: return RISCV::F10_64;
-    case RISCV::F11_32: return RISCV::F11_64;
-    case RISCV::F12_32: return RISCV::F12_64;
-    case RISCV::F13_32: return RISCV::F13_64;
-    case RISCV::F14_32: return RISCV::F14_64;
-    case RISCV::F15_32: return RISCV::F15_64;
-    case RISCV::F16_32: return RISCV::F16_64;
-    case RISCV::F17_32: return RISCV::F17_64;
-    case RISCV::F18_32: return RISCV::F18_64;
-    case RISCV::F19_32: return RISCV::F19_64;
-    case RISCV::F20_32: return RISCV::F20_64;
-    case RISCV::F21_32: return RISCV::F21_64;
-    case RISCV::F22_32: return RISCV::F22_64;
-    case RISCV::F23_32: return RISCV::F23_64;
-    case RISCV::F24_32: return RISCV::F24_64;
-    case RISCV::F25_32: return RISCV::F25_64;
-    case RISCV::F26_32: return RISCV::F26_64;
-    case RISCV::F27_32: return RISCV::F27_64;
-    case RISCV::F28_32: return RISCV::F28_64;
-    case RISCV::F29_32: return RISCV::F29_64;
-    case RISCV::F30_32: return RISCV::F30_64;
-    case RISCV::F31_32: return RISCV::F31_64;
-  }
-}
-
-unsigned RISCVAsmParser::validateTargetOperandClass(MCParsedAsmOperand &AsmOp,
-                                                    unsigned Kind) {
-  RISCVOperand &Op = static_cast<RISCVOperand &>(AsmOp);
-  if (!Op.isReg())
-    return Match_InvalidOperand;
-
-  unsigned Reg = Op.getReg();
-  bool IsRegFPR32 =
-      RISCVMCRegisterClasses[RISCV::FPR32RegClassID].contains(Reg);
-  bool IsRegFPR32C =
-      RISCVMCRegisterClasses[RISCV::FPR32CRegClassID].contains(Reg);
-
-  // As the parser couldn't differentiate an FPR32 from an FPR64, coerce the
-  // register from FPR32 to FPR64 or FPR32C to FPR64C if necessary.
-  if ((IsRegFPR32 && Kind == MCK_FPR64) ||
-      (IsRegFPR32C && Kind == MCK_FPR64C)) {
-    Op.Reg.RegNum = convertFPR32ToFPR64(Reg);
-    return Match_Success;
-  }
-  return Match_InvalidOperand;
-}
-
-bool RISCVAsmParser::generateImmOutOfRangeError(
-    OperandVector &Operands, uint64_t ErrorInfo, int Lower, int Upper,
-    Twine Msg = "immediate must be an integer in the range") {
-  SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-  return Error(ErrorLoc, Msg + " [" + Twine(Lower) + ", " + Twine(Upper) + "]");
-}
-
-bool RISCVAsmParser::MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
-                                             OperandVector &Operands,
-                                             MCStreamer &Out,
-                                             uint64_t &ErrorInfo,
-                                             bool MatchingInlineAsm) {
-  MCInst Inst;
-
-  switch (MatchInstructionImpl(Operands, Inst, ErrorInfo, MatchingInlineAsm)) {
-  default:
-    break;
-  case Match_Success:
-    Inst.setLoc(IDLoc);
-    Out.EmitInstruction(Inst, getSTI());
-    return false;
-  case Match_MissingFeature:
-    return Error(IDLoc, "instruction use requires an option to be enabled");
-  case Match_MnemonicFail:
-    return Error(IDLoc, "unrecognized instruction mnemonic");
-  case Match_InvalidOperand: {
-    SMLoc ErrorLoc = IDLoc;
-    if (ErrorInfo != ~0U) {
-      if (ErrorInfo >= Operands.size())
-        return Error(ErrorLoc, "too few operands for instruction");
-
-      ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-      if (ErrorLoc == SMLoc())
-        ErrorLoc = IDLoc;
-    }
-    return Error(ErrorLoc, "invalid operand for instruction");
-  }
-  case Match_InvalidUImmLog2XLen:
-    if (isRV64())
-      return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 6) - 1);
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 5) - 1);
-  case Match_InvalidUImmLog2XLenNonZero:
-    if (isRV64())
-      return generateImmOutOfRangeError(Operands, ErrorInfo, 1, (1 << 6) - 1);
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 1, (1 << 5) - 1);
-  case Match_InvalidUImm5:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 5) - 1);
-  case Match_InvalidSImm6:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, -(1 << 5),
-                                      (1 << 5) - 1);
-  case Match_InvalidSImm6NonZero:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, -(1 << 5),
-                                      (1 << 5) - 1,
-        "immediate must be non-zero in the range");
-  case Match_InvalidCLUIImm:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 1, (1 << 5) - 1,
-        "immediate must be in [0xfffe0, 0xfffff] or");
-  case Match_InvalidUImm7Lsb00:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 7) - 4,
-        "immediate must be a multiple of 4 bytes in the range");
-  case Match_InvalidUImm8Lsb00:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 8) - 4,
-        "immediate must be a multiple of 4 bytes in the range");
-  case Match_InvalidUImm8Lsb000:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 8) - 8,
-        "immediate must be a multiple of 8 bytes in the range");
-  case Match_InvalidSImm9Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 8), (1 << 8) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidUImm9Lsb000:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 0, (1 << 9) - 8,
-        "immediate must be a multiple of 8 bytes in the range");
-  case Match_InvalidUImm10Lsb00NonZero:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, 4, (1 << 10) - 4,
-        "immediate must be a multiple of 4 bytes in the range");
-  case Match_InvalidSImm10Lsb0000NonZero:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 9), (1 << 9) - 16,
-        "immediate must be a multiple of 16 bytes and non-zero in the range");
-  case Match_InvalidSImm12:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, -(1 << 11),
-                                      (1 << 11) - 1);
-  case Match_InvalidSImm12Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 11), (1 << 11) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidUImm12:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 12) - 1);
-  case Match_InvalidSImm13Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 12), (1 << 12) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidUImm20:
-    return generateImmOutOfRangeError(Operands, ErrorInfo, 0, (1 << 20) - 1);
-  case Match_InvalidSImm21Lsb0:
-    return generateImmOutOfRangeError(
-        Operands, ErrorInfo, -(1 << 20), (1 << 20) - 2,
-        "immediate must be a multiple of 2 bytes in the range");
-  case Match_InvalidFenceArg: {
-    SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-    return Error(
-        ErrorLoc,
-        "operand must be formed of letters selected in-order from 'iorw'");
-  }
-  case Match_InvalidFRMArg: {
-    SMLoc ErrorLoc = ((RISCVOperand &)*Operands[ErrorInfo]).getStartLoc();
-    return Error(
-        ErrorLoc,
-        "operand must be a valid floating point rounding mode mnemonic");
-  }
-  }
-
-  llvm_unreachable("Unknown match type detected!");
-}
-
-bool RISCVAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc,
-                                   SMLoc &EndLoc) {
-  const AsmToken &Tok = getParser().getTok();
-  StartLoc = Tok.getLoc();
-  EndLoc = Tok.getEndLoc();
-  RegNo = 0;
-  StringRef Name = getLexer().getTok().getIdentifier();
-
-  if (!MatchRegisterName(Name) || !MatchRegisterAltName(Name)) {
-    getParser().Lex(); // Eat identifier token.
-    return false;
-  }
-
-  return Error(StartLoc, "invalid register name");
-}
-
-OperandMatchResultTy RISCVAsmParser::parseRegister(OperandVector &Operands,
-                                                   bool AllowParens) {
-  SMLoc FirstS = getLoc();
-  bool HadParens = false;
-  AsmToken Buf[2];
-
-  // If this a parenthesised register name is allowed, parse it atomically
-  if (AllowParens && getLexer().is(AsmToken::LParen)) {
-    size_t ReadCount = getLexer().peekTokens(Buf);
-    if (ReadCount == 2 && Buf[1].getKind() == AsmToken::RParen) {
-      HadParens = true;
-      getParser().Lex(); // Eat '('
-    }
-  }
-
-  switch (getLexer().getKind()) {
-  default:
-    return MatchOperand_NoMatch;
-  case AsmToken::Identifier:
-    StringRef Name = getLexer().getTok().getIdentifier();
-    unsigned RegNo = MatchRegisterName(Name);
-    if (RegNo == 0) {
-      RegNo = MatchRegisterAltName(Name);
-      if (RegNo == 0) {
-        if (HadParens)
-          getLexer().UnLex(Buf[0]);
-        return MatchOperand_NoMatch;
-      }
-    }
-    if (HadParens)
-      Operands.push_back(RISCVOperand::createToken("(", FirstS, isRV64()));
-    SMLoc S = getLoc();
-    SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-    getLexer().Lex();
-    Operands.push_back(RISCVOperand::createReg(RegNo, S, E, isRV64()));
-  }
-
-  if (HadParens) {
-    getParser().Lex(); // Eat ')'
-    Operands.push_back(RISCVOperand::createToken(")", getLoc(), isRV64()));
-  }
-
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy RISCVAsmParser::parseImmediate(OperandVector &Operands) {
-  SMLoc S = getLoc();
-  SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-  const MCExpr *Res;
-
-  switch (getLexer().getKind()) {
-  default:
-    return MatchOperand_NoMatch;
-  case AsmToken::LParen:
-  case AsmToken::Minus:
-  case AsmToken::Plus:
-  case AsmToken::Integer:
-  case AsmToken::String:
-    if (getParser().parseExpression(Res))
-      return MatchOperand_ParseFail;
-    break;
-  case AsmToken::Identifier: {
-    StringRef Identifier;
-    if (getParser().parseIdentifier(Identifier))
-      return MatchOperand_ParseFail;
-    MCSymbol *Sym = getContext().getOrCreateSymbol(Identifier);
-    Res = MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
-    break;
-  }
-  case AsmToken::Percent:
-    return parseOperandWithModifier(Operands);
-  }
-
-  Operands.push_back(RISCVOperand::createImm(Res, S, E, isRV64()));
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy
-RISCVAsmParser::parseOperandWithModifier(OperandVector &Operands) {
-  SMLoc S = getLoc();
-  SMLoc E = SMLoc::getFromPointer(S.getPointer() - 1);
-
-  if (getLexer().getKind() != AsmToken::Percent) {
-    Error(getLoc(), "expected '%' for operand modifier");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat '%'
-
-  if (getLexer().getKind() != AsmToken::Identifier) {
-    Error(getLoc(), "expected valid identifier for operand modifier");
-    return MatchOperand_ParseFail;
-  }
-  StringRef Identifier = getParser().getTok().getIdentifier();
-  RISCVMCExpr::VariantKind VK = RISCVMCExpr::getVariantKindForName(Identifier);
-  if (VK == RISCVMCExpr::VK_RISCV_Invalid) {
-    Error(getLoc(), "unrecognized operand modifier");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat the identifier
-  if (getLexer().getKind() != AsmToken::LParen) {
-    Error(getLoc(), "expected '('");
-    return MatchOperand_ParseFail;
-  }
-  getParser().Lex(); // Eat '('
-
-  const MCExpr *SubExpr;
-  if (getParser().parseParenExpression(SubExpr, E)) {
-    return MatchOperand_ParseFail;
-  }
-
-  const MCExpr *ModExpr = RISCVMCExpr::create(SubExpr, VK, getContext());
-  Operands.push_back(RISCVOperand::createImm(ModExpr, S, E, isRV64()));
-  return MatchOperand_Success;
-}
-
-OperandMatchResultTy
-RISCVAsmParser::parseMemOpBaseReg(OperandVector &Operands) {
-  if (getLexer().isNot(AsmToken::LParen)) {
-    Error(getLoc(), "expected '('");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat '('
-  Operands.push_back(RISCVOperand::createToken("(", getLoc(), isRV64()));
-
-  if (parseRegister(Operands) != MatchOperand_Success) {
-    Error(getLoc(), "expected register");
-    return MatchOperand_ParseFail;
-  }
-
-  if (getLexer().isNot(AsmToken::RParen)) {
-    Error(getLoc(), "expected ')'");
-    return MatchOperand_ParseFail;
-  }
-
-  getParser().Lex(); // Eat ')'
-  Operands.push_back(RISCVOperand::createToken(")", getLoc(), isRV64()));
-
-  return MatchOperand_Success;
-}
-
-/// Looks at a token type and creates the relevant operand
-/// from this information, adding to Operands.
-/// If operand was parsed, returns false, else true.
-bool RISCVAsmParser::parseOperand(OperandVector &Operands) {
-  // Attempt to parse token as register
-  if (parseRegister(Operands, true) == MatchOperand_Success)
-    return false;
-
-  // Attempt to parse token as an immediate
-  if (parseImmediate(Operands) == MatchOperand_Success) {
-    // Parse memory base register if present
-    if (getLexer().is(AsmToken::LParen))
-      return parseMemOpBaseReg(Operands) != MatchOperand_Success;
-    return false;
-  }
-
-  // Finally we have exhausted all options and must declare defeat.
-  Error(getLoc(), "unknown operand");
-  return true;
-}
-
-bool RISCVAsmParser::ParseInstruction(ParseInstructionInfo &Info,
-                                      StringRef Name, SMLoc NameLoc,
-                                      OperandVector &Operands) {
-  // First operand is token for instruction
-  Operands.push_back(RISCVOperand::createToken(Name, NameLoc, isRV64()));
-
-  // If there are no more operands, then finish
-  if (getLexer().is(AsmToken::EndOfStatement))
-    return false;
-
-  // Parse first operand
-  if (parseOperand(Operands))
-    return true;
-
-  // Parse until end of statement, consuming commas between operands
-  while (getLexer().is(AsmToken::Comma)) {
-    // Consume comma token
-    getLexer().Lex();
-
-    // Parse next operand
-    if (parseOperand(Operands))
-      return true;
-  }
-
-  if (getLexer().isNot(AsmToken::EndOfStatement)) {
-    SMLoc Loc = getLexer().getLoc();
-    getParser().eatToEndOfStatement();
-    return Error(Loc, "unexpected token");
-  }
-
-  getParser().Lex(); // Consume the EndOfStatement.
-  return false;
-}
-
-bool RISCVAsmParser::classifySymbolRef(const MCExpr *Expr,
-                                       RISCVMCExpr::VariantKind &Kind,
-                                       int64_t &Addend) {
-  Kind = RISCVMCExpr::VK_RISCV_None;
-  Addend = 0;
-
-  if (const RISCVMCExpr *RE = dyn_cast<RISCVMCExpr>(Expr)) {
-    Kind = RE->getKind();
-    Expr = RE->getSubExpr();
-  }
-
-  // It's a simple symbol reference or constant with no addend.
-  if (isa<MCConstantExpr>(Expr) || isa<MCSymbolRefExpr>(Expr))
-    return true;
-
-  const MCBinaryExpr *BE = dyn_cast<MCBinaryExpr>(Expr);
-  if (!BE)
-    return false;
-
-  if (!isa<MCSymbolRefExpr>(BE->getLHS()))
-    return false;
-
-  if (BE->getOpcode() != MCBinaryExpr::Add &&
-      BE->getOpcode() != MCBinaryExpr::Sub)
-    return false;
-
-  // We are able to support the subtraction of two symbol references
-  if (BE->getOpcode() == MCBinaryExpr::Sub &&
-      isa<MCSymbolRefExpr>(BE->getRHS()))
-    return true;
-
-  // See if the addend is is a constant, otherwise there's more going
-  // on here than we can deal with.
-  auto AddendExpr = dyn_cast<MCConstantExpr>(BE->getRHS());
-  if (!AddendExpr)
-    return false;
-
-  Addend = AddendExpr->getValue();
-  if (BE->getOpcode() == MCBinaryExpr::Sub)
-    Addend = -Addend;
-
-  // It's some symbol reference + a constant addend
-  return Kind != RISCVMCExpr::VK_RISCV_Invalid;
-}
-
-bool RISCVAsmParser::ParseDirective(AsmToken DirectiveID) { return true; }
-
-extern "C" void LLVMInitializeRISCVAsmParser() {
-  RegisterMCAsmParser<RISCVAsmParser> X(getTheRISCV32Target());
-  RegisterMCAsmParser<RISCVAsmParser> Y(getTheRISCV64Target());
-}
diff --git a/lib/Target/RISCV/CMakeLists.txt b/lib/Target/RISCV/CMakeLists.txt
deleted file mode 100644
index 66b50f8728e..00000000000
--- a/lib/Target/RISCV/CMakeLists.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-set(LLVM_TARGET_DEFINITIONS RISCV.td)
-
-tablegen(LLVM RISCVGenRegisterInfo.inc -gen-register-info)
-tablegen(LLVM RISCVGenInstrInfo.inc -gen-instr-info)
-tablegen(LLVM RISCVGenMCCodeEmitter.inc -gen-emitter)
-tablegen(LLVM RISCVGenMCPseudoLowering.inc -gen-pseudo-lowering)
-tablegen(LLVM RISCVGenAsmMatcher.inc -gen-asm-matcher)
-tablegen(LLVM RISCVGenAsmWriter.inc -gen-asm-writer)
-tablegen(LLVM RISCVGenDAGISel.inc -gen-dag-isel)
-tablegen(LLVM RISCVGenSubtargetInfo.inc -gen-subtarget)
-tablegen(LLVM RISCVGenDisassemblerTables.inc -gen-disassembler)
-
-add_public_tablegen_target(RISCVCommonTableGen)
-
-add_llvm_target(RISCVCodeGen
-  RISCVAsmPrinter.cpp
-  RISCVFrameLowering.cpp
-  RISCVInstrInfo.cpp
-  RISCVISelDAGToDAG.cpp
-  RISCVISelLowering.cpp
-  RISCVMCInstLower.cpp
-  RISCVRegisterInfo.cpp
-  RISCVSubtarget.cpp
-  RISCVTargetMachine.cpp
-  )
-
-add_subdirectory(AsmParser)
-add_subdirectory(Disassembler)
-add_subdirectory(InstPrinter)
-add_subdirectory(MCTargetDesc)
-add_subdirectory(TargetInfo)
diff --git a/lib/Target/RISCV/Disassembler/CMakeLists.txt b/lib/Target/RISCV/Disassembler/CMakeLists.txt
deleted file mode 100644
index 39bd2b7669f..00000000000
--- a/lib/Target/RISCV/Disassembler/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVDisassembler
-  RISCVDisassembler.cpp
-  )
diff --git a/lib/Target/RISCV/Disassembler/LLVMBuild.txt b/lib/Target/RISCV/Disassembler/LLVMBuild.txt
deleted file mode 100644
index 340e89d4cf3..00000000000
--- a/lib/Target/RISCV/Disassembler/LLVMBuild.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-;===- ./lib/Target/RISCV/Disassembler/LLVMBuild.txt ------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVDisassembler
-parent = RISCV
-required_libraries = MCDisassembler RISCVInfo Support
-add_to_library_groups = RISCV
-
diff --git a/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp b/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
deleted file mode 100644
index 91c72aa191d..00000000000
--- a/lib/Target/RISCV/Disassembler/RISCVDisassembler.cpp
+++ /dev/null
@@ -1,285 +0,0 @@
-//===-- RISCVDisassembler.cpp - Disassembler for RISCV --------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file implements the RISCVDisassembler class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCDisassembler/MCDisassembler.h"
-#include "llvm/MC/MCFixedLenDisassembler.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/Support/Endian.h"
-#include "llvm/Support/TargetRegistry.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-disassembler"
-
-typedef MCDisassembler::DecodeStatus DecodeStatus;
-
-namespace {
-class RISCVDisassembler : public MCDisassembler {
-
-public:
-  RISCVDisassembler(const MCSubtargetInfo &STI, MCContext &Ctx)
-      : MCDisassembler(STI, Ctx) {}
-
-  DecodeStatus getInstruction(MCInst &Instr, uint64_t &Size,
-                              ArrayRef<uint8_t> Bytes, uint64_t Address,
-                              raw_ostream &VStream,
-                              raw_ostream &CStream) const override;
-};
-} // end anonymous namespace
-
-static MCDisassembler *createRISCVDisassembler(const Target &T,
-                                               const MCSubtargetInfo &STI,
-                                               MCContext &Ctx) {
-  return new RISCVDisassembler(STI, Ctx);
-}
-
-extern "C" void LLVMInitializeRISCVDisassembler() {
-  // Register the disassembler for each target.
-  TargetRegistry::RegisterMCDisassembler(getTheRISCV32Target(),
-                                         createRISCVDisassembler);
-  TargetRegistry::RegisterMCDisassembler(getTheRISCV64Target(),
-                                         createRISCVDisassembler);
-}
-
-static const unsigned GPRDecoderTable[] = {
-  RISCV::X0,  RISCV::X1,  RISCV::X2,  RISCV::X3,
-  RISCV::X4,  RISCV::X5,  RISCV::X6,  RISCV::X7,
-  RISCV::X8,  RISCV::X9,  RISCV::X10, RISCV::X11,
-  RISCV::X12, RISCV::X13, RISCV::X14, RISCV::X15,
-  RISCV::X16, RISCV::X17, RISCV::X18, RISCV::X19,
-  RISCV::X20, RISCV::X21, RISCV::X22, RISCV::X23,
-  RISCV::X24, RISCV::X25, RISCV::X26, RISCV::X27,
-  RISCV::X28, RISCV::X29, RISCV::X30, RISCV::X31
-};
-
-static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                           uint64_t Address,
-                                           const void *Decoder) {
-  if (RegNo > sizeof(GPRDecoderTable))
-    return MCDisassembler::Fail;
-
-  // We must define our own mapping from RegNo to register identifier.
-  // Accessing index RegNo in the register class will work in the case that
-  // registers were added in ascending order, but not in general.
-  unsigned Reg = GPRDecoderTable[RegNo];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static const unsigned FPR32DecoderTable[] = {
-  RISCV::F0_32,  RISCV::F1_32,  RISCV::F2_32,  RISCV::F3_32,
-  RISCV::F4_32,  RISCV::F5_32,  RISCV::F6_32,  RISCV::F7_32,
-  RISCV::F8_32,  RISCV::F9_32,  RISCV::F10_32, RISCV::F11_32,
-  RISCV::F12_32, RISCV::F13_32, RISCV::F14_32, RISCV::F15_32,
-  RISCV::F16_32, RISCV::F17_32, RISCV::F18_32, RISCV::F19_32,
-  RISCV::F20_32, RISCV::F21_32, RISCV::F22_32, RISCV::F23_32,
-  RISCV::F24_32, RISCV::F25_32, RISCV::F26_32, RISCV::F27_32,
-  RISCV::F28_32, RISCV::F29_32, RISCV::F30_32, RISCV::F31_32
-};
-
-static DecodeStatus DecodeFPR32RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                             uint64_t Address,
-                                             const void *Decoder) {
-  if (RegNo > sizeof(FPR32DecoderTable))
-    return MCDisassembler::Fail;
-
-  // We must define our own mapping from RegNo to register identifier.
-  // Accessing index RegNo in the register class will work in the case that
-  // registers were added in ascending order, but not in general.
-  unsigned Reg = FPR32DecoderTable[RegNo];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus DecodeFPR32CRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                              uint64_t Address,
-                                              const void *Decoder) {
-  if (RegNo > 8) {
-    return MCDisassembler::Fail;
-  }
-  unsigned Reg = FPR32DecoderTable[RegNo + 8];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static const unsigned FPR64DecoderTable[] = {
-  RISCV::F0_64,  RISCV::F1_64,  RISCV::F2_64,  RISCV::F3_64,
-  RISCV::F4_64,  RISCV::F5_64,  RISCV::F6_64,  RISCV::F7_64,
-  RISCV::F8_64,  RISCV::F9_64,  RISCV::F10_64, RISCV::F11_64,
-  RISCV::F12_64, RISCV::F13_64, RISCV::F14_64, RISCV::F15_64,
-  RISCV::F16_64, RISCV::F17_64, RISCV::F18_64, RISCV::F19_64,
-  RISCV::F20_64, RISCV::F21_64, RISCV::F22_64, RISCV::F23_64,
-  RISCV::F24_64, RISCV::F25_64, RISCV::F26_64, RISCV::F27_64,
-  RISCV::F28_64, RISCV::F29_64, RISCV::F30_64, RISCV::F31_64
-};
-
-static DecodeStatus DecodeFPR64RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                             uint64_t Address,
-                                             const void *Decoder) {
-  if (RegNo > sizeof(FPR64DecoderTable))
-    return MCDisassembler::Fail;
-
-  // We must define our own mapping from RegNo to register identifier.
-  // Accessing index RegNo in the register class will work in the case that
-  // registers were added in ascending order, but not in general.
-  unsigned Reg = FPR64DecoderTable[RegNo];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus DecodeFPR64CRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                              uint64_t Address,
-                                              const void *Decoder) {
-  if (RegNo > 8) {
-    return MCDisassembler::Fail;
-  }
-  unsigned Reg = FPR64DecoderTable[RegNo + 8];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus DecodeGPRNoX0RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                               uint64_t Address,
-                                               const void *Decoder) {
-  if (RegNo == 0) {
-    return MCDisassembler::Fail;
-  }
-
-  return DecodeGPRRegisterClass(Inst, RegNo, Address, Decoder);
-}
-
-static DecodeStatus DecodeGPRNoX0X2RegisterClass(MCInst &Inst, uint64_t RegNo,
-                                                 uint64_t Address,
-                                                 const void *Decoder) {
-  if (RegNo == 2) {
-    return MCDisassembler::Fail;
-  }
-
-  return DecodeGPRNoX0RegisterClass(Inst, RegNo, Address, Decoder);
-}
-
-static DecodeStatus DecodeGPRCRegisterClass(MCInst &Inst, uint64_t RegNo,
-                                            uint64_t Address,
-                                            const void *Decoder) {
-  if (RegNo > 8)
-    return MCDisassembler::Fail;
-
-  unsigned Reg = GPRDecoderTable[RegNo + 8];
-  Inst.addOperand(MCOperand::createReg(Reg));
-  return MCDisassembler::Success;
-}
-
-// Add implied SP operand for instructions *SP compressed instructions. The SP
-// operand isn't explicitly encoded in the instruction.
-static void addImplySP(MCInst &Inst, int64_t Address, const void *Decoder) {
-  if (Inst.getOpcode() == RISCV::C_LWSP || Inst.getOpcode() == RISCV::C_SWSP ||
-      Inst.getOpcode() == RISCV::C_LDSP || Inst.getOpcode() == RISCV::C_SDSP ||
-      Inst.getOpcode() == RISCV::C_FLWSP ||
-      Inst.getOpcode() == RISCV::C_FSWSP ||
-      Inst.getOpcode() == RISCV::C_FLDSP ||
-      Inst.getOpcode() == RISCV::C_FSDSP ||
-      Inst.getOpcode() == RISCV::C_ADDI4SPN) {
-    DecodeGPRRegisterClass(Inst, 2, Address, Decoder);
-  }
-  if (Inst.getOpcode() == RISCV::C_ADDI16SP) {
-    DecodeGPRRegisterClass(Inst, 2, Address, Decoder);
-    DecodeGPRRegisterClass(Inst, 2, Address, Decoder);
-  }
-}
-
-template <unsigned N>
-static DecodeStatus decodeUImmOperand(MCInst &Inst, uint64_t Imm,
-                                      int64_t Address, const void *Decoder) {
-  assert(isUInt<N>(Imm) && "Invalid immediate");
-  addImplySP(Inst, Address, Decoder);
-  Inst.addOperand(MCOperand::createImm(Imm));
-  return MCDisassembler::Success;
-}
-
-template <unsigned N>
-static DecodeStatus decodeSImmOperand(MCInst &Inst, uint64_t Imm,
-                                      int64_t Address, const void *Decoder) {
-  assert(isUInt<N>(Imm) && "Invalid immediate");
-  addImplySP(Inst, Address, Decoder);
-  // Sign-extend the number in the bottom N bits of Imm
-  Inst.addOperand(MCOperand::createImm(SignExtend64<N>(Imm)));
-  return MCDisassembler::Success;
-}
-
-template <unsigned N>
-static DecodeStatus decodeSImmOperandAndLsl1(MCInst &Inst, uint64_t Imm,
-                                             int64_t Address,
-                                             const void *Decoder) {
-  assert(isUInt<N>(Imm) && "Invalid immediate");
-  // Sign-extend the number in the bottom N bits of Imm after accounting for
-  // the fact that the N bit immediate is stored in N-1 bits (the LSB is
-  // always zero)
-  Inst.addOperand(MCOperand::createImm(SignExtend64<N>(Imm << 1)));
-  return MCDisassembler::Success;
-}
-
-static DecodeStatus decodeCLUIImmOperand(MCInst &Inst, uint64_t Imm,
-                                         int64_t Address,
-                                         const void *Decoder) {
-  assert(isUInt<6>(Imm) && "Invalid immediate");
-  if (Imm > 31) {
-    Imm = (SignExtend64<6>(Imm) & 0xfffff);
-  }
-  Inst.addOperand(MCOperand::createImm(Imm));
-  return MCDisassembler::Success;
-}
-
-#include "RISCVGenDisassemblerTables.inc"
-
-DecodeStatus RISCVDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
-                                               ArrayRef<uint8_t> Bytes,
-                                               uint64_t Address,
-                                               raw_ostream &OS,
-                                               raw_ostream &CS) const {
-  // TODO: This will need modification when supporting instruction set
-  // extensions with instructions > 32-bits (up to 176 bits wide).
-  uint32_t Insn;
-  DecodeStatus Result;
-
-  // It's a 32 bit instruction if bit 0 and 1 are 1.
-  if ((Bytes[0] & 0x3) == 0x3) {
-    Insn = support::endian::read32le(Bytes.data());
-    DEBUG(dbgs() << "Trying RISCV32 table :\n");
-    Result = decodeInstruction(DecoderTable32, MI, Insn, Address, this, STI);
-    Size = 4;
-  } else {
-    Insn = support::endian::read16le(Bytes.data());
-
-    if (!STI.getFeatureBits()[RISCV::Feature64Bit]) {
-      DEBUG(dbgs() << "Trying RISCV32Only_16 table (16-bit Instruction):\n");
-      // Calling the auto-generated decoder function.
-      Result = decodeInstruction(DecoderTableRISCV32Only_16, MI, Insn, Address,
-                                 this, STI);
-      if (Result != MCDisassembler::Fail) {
-        Size = 2;
-        return Result;
-      }
-    }
-
-    DEBUG(dbgs() << "Trying RISCV_C table (16-bit Instruction):\n");
-    // Calling the auto-generated decoder function.
-    Result = decodeInstruction(DecoderTable16, MI, Insn, Address, this, STI);
-    Size = 2;
-  }
-
-  return Result;
-}
diff --git a/lib/Target/RISCV/InstPrinter/CMakeLists.txt b/lib/Target/RISCV/InstPrinter/CMakeLists.txt
deleted file mode 100644
index 7f91743fb93..00000000000
--- a/lib/Target/RISCV/InstPrinter/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVAsmPrinter
-  RISCVInstPrinter.cpp
-  )
diff --git a/lib/Target/RISCV/InstPrinter/LLVMBuild.txt b/lib/Target/RISCV/InstPrinter/LLVMBuild.txt
deleted file mode 100644
index 5f4545e3d67..00000000000
--- a/lib/Target/RISCV/InstPrinter/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/InstPrinter/LLVMBuild.txt -------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVAsmPrinter
-parent = RISCV
-required_libraries = MC Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp b/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp
deleted file mode 100644
index f1fa2ecbcb2..00000000000
--- a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.cpp
+++ /dev/null
@@ -1,90 +0,0 @@
-//===-- RISCVInstPrinter.cpp - Convert RISCV MCInst to asm syntax ---------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This class prints an RISCV MCInst to a .s file.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVInstPrinter.h"
-#include "MCTargetDesc/RISCVBaseInfo.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/FormattedStream.h"
-using namespace llvm;
-
-#define DEBUG_TYPE "asm-printer"
-
-// Include the auto-generated portion of the assembly writer.
-#define PRINT_ALIAS_INSTR
-#include "RISCVGenAsmWriter.inc"
-
-static cl::opt<bool>
-NoAliases("riscv-no-aliases",
-            cl::desc("Disable the emission of assembler pseudo instructions"),
-            cl::init(false),
-            cl::Hidden);
-
-void RISCVInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
-                                 StringRef Annot, const MCSubtargetInfo &STI) {
-  if (NoAliases || !printAliasInstr(MI, STI, O))
-    printInstruction(MI, STI, O);
-  printAnnotation(O, Annot);
-}
-
-void RISCVInstPrinter::printRegName(raw_ostream &O, unsigned RegNo) const {
-  O << getRegisterName(RegNo);
-}
-
-void RISCVInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
-                                    const MCSubtargetInfo &STI,
-                                    raw_ostream &O, const char *Modifier) {
-  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");
-  const MCOperand &MO = MI->getOperand(OpNo);
-
-  if (MO.isReg()) {
-    printRegName(O, MO.getReg());
-    return;
-  }
-
-  if (MO.isImm()) {
-    O << MO.getImm();
-    return;
-  }
-
-  assert(MO.isExpr() && "Unknown operand kind in printOperand");
-  MO.getExpr()->print(O, &MAI);
-}
-
-void RISCVInstPrinter::printFenceArg(const MCInst *MI, unsigned OpNo,
-                                     const MCSubtargetInfo &STI,
-                                     raw_ostream &O) {
-  unsigned FenceArg = MI->getOperand(OpNo).getImm();
-  if ((FenceArg & RISCVFenceField::I) != 0)
-    O << 'i';
-  if ((FenceArg & RISCVFenceField::O) != 0)
-    O << 'o';
-  if ((FenceArg & RISCVFenceField::R) != 0)
-    O << 'r';
-  if ((FenceArg & RISCVFenceField::W) != 0)
-    O << 'w';
-}
-
-void RISCVInstPrinter::printFRMArg(const MCInst *MI, unsigned OpNo,
-                                   const MCSubtargetInfo &STI,
-                                   raw_ostream &O) {
-  auto FRMArg =
-      static_cast<RISCVFPRndMode::RoundingMode>(MI->getOperand(OpNo).getImm());
-  O << RISCVFPRndMode::roundingModeToString(FRMArg);
-}
diff --git a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h b/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h
deleted file mode 100644
index 241be8daf11..00000000000
--- a/lib/Target/RISCV/InstPrinter/RISCVInstPrinter.h
+++ /dev/null
@@ -1,53 +0,0 @@
-//===-- RISCVInstPrinter.h - Convert RISCV MCInst to asm syntax ---*- C++ -*--//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This class prints a RISCV MCInst to a .s file.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_INSTPRINTER_RISCVINSTPRINTER_H
-#define LLVM_LIB_TARGET_RISCV_INSTPRINTER_RISCVINSTPRINTER_H
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/MC/MCInstPrinter.h"
-
-namespace llvm {
-class MCOperand;
-
-class RISCVInstPrinter : public MCInstPrinter {
-public:
-  RISCVInstPrinter(const MCAsmInfo &MAI, const MCInstrInfo &MII,
-                   const MCRegisterInfo &MRI)
-      : MCInstPrinter(MAI, MII, MRI) {}
-
-  void printInst(const MCInst *MI, raw_ostream &O, StringRef Annot,
-                 const MCSubtargetInfo &STI) override;
-  void printRegName(raw_ostream &O, unsigned RegNo) const override;
-
-  void printOperand(const MCInst *MI, unsigned OpNo, const MCSubtargetInfo &STI,
-                    raw_ostream &O, const char *Modifier = nullptr);
-  void printFenceArg(const MCInst *MI, unsigned OpNo,
-                     const MCSubtargetInfo &STI, raw_ostream &O);
-  void printFRMArg(const MCInst *MI, unsigned OpNo, const MCSubtargetInfo &STI,
-                   raw_ostream &O);
-
-  // Autogenerated by tblgen.
-  void printInstruction(const MCInst *MI, const MCSubtargetInfo &STI,
-                        raw_ostream &O);
-  bool printAliasInstr(const MCInst *MI, const MCSubtargetInfo &STI,
-                       raw_ostream &O);
-  void printCustomAliasOperand(const MCInst *MI, unsigned OpIdx,
-                               unsigned PrintMethodIdx,
-                               const MCSubtargetInfo &STI, raw_ostream &O);
-  static const char *getRegisterName(unsigned RegNo,
-                                     unsigned AltIdx = RISCV::ABIRegAltName);
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/LLVMBuild.txt b/lib/Target/RISCV/LLVMBuild.txt
deleted file mode 100644
index ab21565b0c2..00000000000
--- a/lib/Target/RISCV/LLVMBuild.txt
+++ /dev/null
@@ -1,35 +0,0 @@
-;===- ./lib/Target/RISCV/LLVMBuild.txt -------------------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[common]
-subdirectories = AsmParser Disassembler InstPrinter TargetInfo MCTargetDesc
-
-[component_0]
-type = TargetGroup
-name = RISCV
-parent = Target
-has_asmparser = 1
-has_asmprinter = 1
-has_disassembler = 1
-
-[component_1]
-type = Library
-name = RISCVCodeGen
-parent = RISCV
-required_libraries = AsmPrinter Core CodeGen MC RISCVAsmPrinter RISCVDesc
-  RISCVInfo SelectionDAG Support Target
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/MCTargetDesc/CMakeLists.txt b/lib/Target/RISCV/MCTargetDesc/CMakeLists.txt
deleted file mode 100644
index d9f4188aa75..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-add_llvm_library(LLVMRISCVDesc
-  RISCVAsmBackend.cpp
-  RISCVELFObjectWriter.cpp
-  RISCVMCAsmInfo.cpp
-  RISCVMCCodeEmitter.cpp
-  RISCVMCExpr.cpp
-  RISCVMCTargetDesc.cpp
-  RISCVTargetStreamer.cpp
-  RISCVELFStreamer.cpp
-)
diff --git a/lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt b/lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt
deleted file mode 100644
index 92daae30e3f..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/MCTargetDesc/LLVMBuild.txt ------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVDesc
-parent = RISCV
-required_libraries = MC RISCVAsmPrinter RISCVInfo Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
deleted file mode 100644
index 65425e4b156..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVAsmBackend.cpp
+++ /dev/null
@@ -1,326 +0,0 @@
-//===-- RISCVAsmBackend.cpp - RISCV Assembler Backend ---------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVFixupKinds.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/ADT/APInt.h"
-#include "llvm/MC/MCAsmBackend.h"
-#include "llvm/MC/MCAssembler.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCDirectives.h"
-#include "llvm/MC/MCELFObjectWriter.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCFixupKindInfo.h"
-#include "llvm/MC/MCObjectWriter.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-namespace {
-class RISCVAsmBackend : public MCAsmBackend {
-  const MCSubtargetInfo &STI;
-  uint8_t OSABI;
-  bool Is64Bit;
-
-public:
-  RISCVAsmBackend(const MCSubtargetInfo &STI, uint8_t OSABI, bool Is64Bit)
-      : MCAsmBackend(), STI(STI), OSABI(OSABI), Is64Bit(Is64Bit) {}
-  ~RISCVAsmBackend() override {}
-
-  void applyFixup(const MCAssembler &Asm, const MCFixup &Fixup,
-                  const MCValue &Target, MutableArrayRef<char> Data,
-                  uint64_t Value, bool IsResolved) const override;
-
-  std::unique_ptr<MCObjectWriter>
-  createObjectWriter(raw_pwrite_stream &OS) const override;
-
-  bool fixupNeedsRelaxation(const MCFixup &Fixup, uint64_t Value,
-                            const MCRelaxableFragment *DF,
-                            const MCAsmLayout &Layout) const override;
-
-  unsigned getNumFixupKinds() const override {
-    return RISCV::NumTargetFixupKinds;
-  }
-
-  const MCFixupKindInfo &getFixupKindInfo(MCFixupKind Kind) const override {
-    const static MCFixupKindInfo Infos[RISCV::NumTargetFixupKinds] = {
-      // This table *must* be in the order that the fixup_* kinds are defined in
-      // RISCVFixupKinds.h.
-      //
-      // name                      offset bits  flags
-      { "fixup_riscv_hi20",         12,     20,  0 },
-      { "fixup_riscv_lo12_i",       20,     12,  0 },
-      { "fixup_riscv_lo12_s",        0,     32,  0 },
-      { "fixup_riscv_pcrel_hi20",   12,     20,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_pcrel_lo12_i", 20,     12,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_pcrel_lo12_s",  0,     32,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_jal",          12,     20,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_branch",        0,     32,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_rvc_jump",      2,     11,  MCFixupKindInfo::FKF_IsPCRel },
-      { "fixup_riscv_rvc_branch",    0,     16,  MCFixupKindInfo::FKF_IsPCRel }
-    };
-
-    if (Kind < FirstTargetFixupKind)
-      return MCAsmBackend::getFixupKindInfo(Kind);
-
-    assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&
-           "Invalid kind!");
-    return Infos[Kind - FirstTargetFixupKind];
-  }
-
-  bool mayNeedRelaxation(const MCInst &Inst) const override;
-  unsigned getRelaxedOpcode(unsigned Op) const;
-
-  void relaxInstruction(const MCInst &Inst, const MCSubtargetInfo &STI,
-                        MCInst &Res) const override;
-
-
-  bool writeNopData(uint64_t Count, MCObjectWriter *OW) const override;
-};
-
-
-bool RISCVAsmBackend::fixupNeedsRelaxation(const MCFixup &Fixup,
-                                           uint64_t Value,
-                                           const MCRelaxableFragment *DF,
-                                           const MCAsmLayout &Layout) const {
-  int64_t Offset = int64_t(Value);
-  switch ((unsigned)Fixup.getKind()) {
-  default:
-    return false;
-  case RISCV::fixup_riscv_rvc_branch:
-    // For compressed branch instructions the immediate must be
-    // in the range [-256, 254].
-    return Offset > 254 || Offset < -256;
-  case RISCV::fixup_riscv_rvc_jump:
-    // For compressed jump instructions the immediate must be
-    // in the range [-2048, 2046].
-    return Offset > 2046 || Offset < -2048;
-  }
-}
-
-void RISCVAsmBackend::relaxInstruction(const MCInst &Inst,
-                                       const MCSubtargetInfo &STI,
-                                       MCInst &Res) const {
-  // TODO: replace this with call to auto generated uncompressinstr() function.
-  switch (Inst.getOpcode()) {
-  default:
-    llvm_unreachable("Opcode not expected!");
-  case RISCV::C_BEQZ:
-    // c.beqz $rs1, $imm -> beq $rs1, X0, $imm.
-    Res.setOpcode(RISCV::BEQ);
-    Res.addOperand(Inst.getOperand(0));
-    Res.addOperand(MCOperand::createReg(RISCV::X0));
-    Res.addOperand(Inst.getOperand(1));
-    break;
-  case RISCV::C_BNEZ:
-    // c.bnez $rs1, $imm -> bne $rs1, X0, $imm.
-    Res.setOpcode(RISCV::BNE);
-    Res.addOperand(Inst.getOperand(0));
-    Res.addOperand(MCOperand::createReg(RISCV::X0));
-    Res.addOperand(Inst.getOperand(1));
-    break;
-  case RISCV::C_J:
-    // c.j $imm -> jal X0, $imm.
-    Res.setOpcode(RISCV::JAL);
-    Res.addOperand(MCOperand::createReg(RISCV::X0));
-    Res.addOperand(Inst.getOperand(0));
-    break;
-  case RISCV::C_JAL:
-    // c.jal $imm -> jal X1, $imm.
-    Res.setOpcode(RISCV::JAL);
-    Res.addOperand(MCOperand::createReg(RISCV::X1));
-    Res.addOperand(Inst.getOperand(0));
-    break;
-  }
-}
-
-// Given a compressed control flow instruction this function returns
-// the expanded instruction.
-unsigned RISCVAsmBackend::getRelaxedOpcode(unsigned Op) const {
-  switch (Op) {
-  default:
-    return Op;
-  case RISCV::C_BEQZ:
-    return RISCV::BEQ;
-  case RISCV::C_BNEZ:
-    return RISCV::BNE;
-  case RISCV::C_J:
-  case RISCV::C_JAL: // fall through.
-    return RISCV::JAL;
-  }
-}
-
-bool RISCVAsmBackend::mayNeedRelaxation(const MCInst &Inst) const {
-  return getRelaxedOpcode(Inst.getOpcode()) != Inst.getOpcode();
-}
-
-bool RISCVAsmBackend::writeNopData(uint64_t Count, MCObjectWriter *OW) const {
-  bool HasStdExtC = STI.getFeatureBits()[RISCV::FeatureStdExtC];
-  unsigned MinNopLen = HasStdExtC ? 2 : 4;
-
-  if ((Count % MinNopLen) != 0)
-    return false;
-
-  // The canonical nop on RISC-V is addi x0, x0, 0.
-  uint64_t Nop32Count = Count / 4;
-  for (uint64_t i = Nop32Count; i != 0; --i)
-    OW->write32(0x13);
-
-  // The canonical nop on RVC is c.nop.
-  if (HasStdExtC) {
-    uint64_t Nop16Count = (Count - Nop32Count * 4) / 2;
-    for (uint64_t i = Nop16Count; i != 0; --i)
-      OW->write16(0x01);
-  }
-
-  return true;
-}
-
-static uint64_t adjustFixupValue(const MCFixup &Fixup, uint64_t Value,
-                                 MCContext &Ctx) {
-  unsigned Kind = Fixup.getKind();
-  switch (Kind) {
-  default:
-    llvm_unreachable("Unknown fixup kind!");
-  case FK_Data_1:
-  case FK_Data_2:
-  case FK_Data_4:
-  case FK_Data_8:
-    return Value;
-  case RISCV::fixup_riscv_lo12_i:
-  case RISCV::fixup_riscv_pcrel_lo12_i:
-    return Value & 0xfff;
-  case RISCV::fixup_riscv_lo12_s:
-  case RISCV::fixup_riscv_pcrel_lo12_s:
-    return (((Value >> 5) & 0x7f) << 25) | ((Value & 0x1f) << 7);
-  case RISCV::fixup_riscv_hi20:
-  case RISCV::fixup_riscv_pcrel_hi20:
-    // Add 1 if bit 11 is 1, to compensate for low 12 bits being negative.
-    return ((Value + 0x800) >> 12) & 0xfffff;
-  case RISCV::fixup_riscv_jal: {
-    if (!isInt<21>(Value))
-      Ctx.reportError(Fixup.getLoc(), "fixup value out of range");
-    if (Value & 0x1)
-      Ctx.reportError(Fixup.getLoc(), "fixup value must be 2-byte aligned");
-    // Need to produce imm[19|10:1|11|19:12] from the 21-bit Value.
-    unsigned Sbit = (Value >> 20) & 0x1;
-    unsigned Hi8 = (Value >> 12) & 0xff;
-    unsigned Mid1 = (Value >> 11) & 0x1;
-    unsigned Lo10 = (Value >> 1) & 0x3ff;
-    // Inst{31} = Sbit;
-    // Inst{30-21} = Lo10;
-    // Inst{20} = Mid1;
-    // Inst{19-12} = Hi8;
-    Value = (Sbit << 19) | (Lo10 << 9) | (Mid1 << 8) | Hi8;
-    return Value;
-  }
-  case RISCV::fixup_riscv_branch: {
-    if (!isInt<13>(Value))
-      Ctx.reportError(Fixup.getLoc(), "fixup value out of range");
-    if (Value & 0x1)
-      Ctx.reportError(Fixup.getLoc(), "fixup value must be 2-byte aligned");
-    // Need to extract imm[12], imm[10:5], imm[4:1], imm[11] from the 13-bit
-    // Value.
-    unsigned Sbit = (Value >> 12) & 0x1;
-    unsigned Hi1 = (Value >> 11) & 0x1;
-    unsigned Mid6 = (Value >> 5) & 0x3f;
-    unsigned Lo4 = (Value >> 1) & 0xf;
-    // Inst{31} = Sbit;
-    // Inst{30-25} = Mid6;
-    // Inst{11-8} = Lo4;
-    // Inst{7} = Hi1;
-    Value = (Sbit << 31) | (Mid6 << 25) | (Lo4 << 8) | (Hi1 << 7);
-    return Value;
-  }
-  case RISCV::fixup_riscv_rvc_jump: {
-    // Need to produce offset[11|4|9:8|10|6|7|3:1|5] from the 11-bit Value.
-    unsigned Bit11  = (Value >> 11) & 0x1;
-    unsigned Bit4   = (Value >> 4) & 0x1;
-    unsigned Bit9_8 = (Value >> 8) & 0x3;
-    unsigned Bit10  = (Value >> 10) & 0x1;
-    unsigned Bit6   = (Value >> 6) & 0x1;
-    unsigned Bit7   = (Value >> 7) & 0x1;
-    unsigned Bit3_1 = (Value >> 1) & 0x7;
-    unsigned Bit5   = (Value >> 5) & 0x1;
-    Value = (Bit11 << 10) | (Bit4 << 9) | (Bit9_8 << 7) | (Bit10 << 6) |
-            (Bit6 << 5) | (Bit7 << 4) | (Bit3_1 << 1) | Bit5;
-    return Value;
-  }
-  case RISCV::fixup_riscv_rvc_branch: {
-    // Need to produce offset[8|4:3], [reg 3 bit], offset[7:6|2:1|5]
-    unsigned Bit8   = (Value >> 8) & 0x1;
-    unsigned Bit7_6 = (Value >> 6) & 0x3;
-    unsigned Bit5   = (Value >> 5) & 0x1;
-    unsigned Bit4_3 = (Value >> 3) & 0x3;
-    unsigned Bit2_1 = (Value >> 1) & 0x3;
-    Value = (Bit8 << 12) | (Bit4_3 << 10) | (Bit7_6 << 5) | (Bit2_1 << 3) |
-            (Bit5 << 2);
-    return Value;
-  }
-
-  }
-}
-
-static unsigned getSize(unsigned Kind) {
-  switch (Kind) {
-  default:
-    return 4;
-  case RISCV::fixup_riscv_rvc_jump:
-  case RISCV::fixup_riscv_rvc_branch:
-    return 2;
-  }
-}
-
-void RISCVAsmBackend::applyFixup(const MCAssembler &Asm, const MCFixup &Fixup,
-                                 const MCValue &Target,
-                                 MutableArrayRef<char> Data, uint64_t Value,
-                                 bool IsResolved) const {
-  MCContext &Ctx = Asm.getContext();
-  MCFixupKindInfo Info = getFixupKindInfo(Fixup.getKind());
-  if (!Value)
-    return; // Doesn't change encoding.
-  // Apply any target-specific value adjustments.
-  Value = adjustFixupValue(Fixup, Value, Ctx);
-
-  // Shift the value into position.
-  Value <<= Info.TargetOffset;
-
-  unsigned Offset = Fixup.getOffset();
-  unsigned FullSize = getSize(Fixup.getKind());
-
-#ifndef NDEBUG
-  unsigned NumBytes = (Info.TargetSize + 7) / 8;
-  assert(Offset + NumBytes <= Data.size() && "Invalid fixup offset!");
-#endif
-
-  // For each byte of the fragment that the fixup touches, mask in the
-  // bits from the fixup value.
-  for (unsigned i = 0; i != FullSize; ++i) {
-    Data[Offset + i] |= uint8_t((Value >> (i * 8)) & 0xff);
-  }
-}
-
-std::unique_ptr<MCObjectWriter>
-RISCVAsmBackend::createObjectWriter(raw_pwrite_stream &OS) const {
-  return createRISCVELFObjectWriter(OS, OSABI, Is64Bit);
-}
-
-} // end anonymous namespace
-
-MCAsmBackend *llvm::createRISCVAsmBackend(const Target &T,
-                                          const MCSubtargetInfo &STI,
-                                          const MCRegisterInfo &MRI,
-                                          const MCTargetOptions &Options) {
-  const Triple &TT = STI.getTargetTriple();
-  uint8_t OSABI = MCELFObjectTargetWriter::getOSABI(TT.getOS());
-  return new RISCVAsmBackend(STI, OSABI, TT.isArch64Bit());
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h b/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
deleted file mode 100644
index b278a2ed390..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
+++ /dev/null
@@ -1,110 +0,0 @@
-//===-- RISCVBaseInfo.h - Top level definitions for RISCV MC ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains small standalone enum definitions for the RISCV target
-// useful for the compiler back-end and the MC libraries.
-//
-//===----------------------------------------------------------------------===//
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVBASEINFO_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVBASEINFO_H
-
-#include "RISCVMCTargetDesc.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/StringSwitch.h"
-
-namespace llvm {
-
-// RISCVII - This namespace holds all of the target specific flags that
-// instruction info tracks. All definitions must match RISCVInstrFormats.td.
-namespace RISCVII {
-enum {
-  InstFormatPseudo = 0,
-  InstFormatR = 1,
-  InstFormatR4 = 2,
-  InstFormatI = 3,
-  InstFormatS = 4,
-  InstFormatB = 5,
-  InstFormatU = 6,
-  InstFormatJ = 7,
-  InstFormatCR = 8,
-  InstFormatCI = 9,
-  InstFormatCSS = 10,
-  InstFormatCIW = 11,
-  InstFormatCL = 12,
-  InstFormatCS = 13,
-  InstFormatCB = 14,
-  InstFormatCJ = 15,
-  InstFormatOther = 16,
-
-  InstFormatMask = 31
-};
-
-enum {
-  MO_None,
-  MO_LO,
-  MO_HI,
-  MO_PCREL_HI,
-};
-} // namespace RISCVII
-
-// Describes the predecessor/successor bits used in the FENCE instruction.
-namespace RISCVFenceField {
-enum FenceField {
-  I = 8,
-  O = 4,
-  R = 2,
-  W = 1
-};
-}
-
-// Describes the supported floating point rounding mode encodings.
-namespace RISCVFPRndMode {
-enum RoundingMode {
-  RNE = 0,
-  RTZ = 1,
-  RDN = 2,
-  RUP = 3,
-  RMM = 4,
-  DYN = 7,
-  Invalid
-};
-
-inline static StringRef roundingModeToString(RoundingMode RndMode) {
-  switch (RndMode) {
-  default:
-    llvm_unreachable("Unknown floating point rounding mode");
-  case RISCVFPRndMode::RNE:
-    return "rne";
-  case RISCVFPRndMode::RTZ:
-    return "rtz";
-  case RISCVFPRndMode::RDN:
-    return "rdn";
-  case RISCVFPRndMode::RUP:
-    return "rup";
-  case RISCVFPRndMode::RMM:
-    return "rmm";
-  case RISCVFPRndMode::DYN:
-    return "dyn";
-  }
-}
-
-inline static RoundingMode stringToRoundingMode(StringRef Str) {
-  return StringSwitch<RoundingMode>(Str)
-      .Case("rne", RISCVFPRndMode::RNE)
-      .Case("rtz", RISCVFPRndMode::RTZ)
-      .Case("rdn", RISCVFPRndMode::RDN)
-      .Case("rup", RISCVFPRndMode::RUP)
-      .Case("rmm", RISCVFPRndMode::RMM)
-      .Case("dyn", RISCVFPRndMode::DYN)
-      .Default(RISCVFPRndMode::Invalid);
-}
-} // namespace RISCVFPRndMode
-} // namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
deleted file mode 100644
index 0dc371c46f2..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVELFObjectWriter.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-//===-- RISCVELFObjectWriter.cpp - RISCV ELF Writer -----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVFixupKinds.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/MC/MCELFObjectWriter.h"
-#include "llvm/MC/MCFixup.h"
-#include "llvm/MC/MCObjectWriter.h"
-#include "llvm/Support/ErrorHandling.h"
-
-using namespace llvm;
-
-namespace {
-class RISCVELFObjectWriter : public MCELFObjectTargetWriter {
-public:
-  RISCVELFObjectWriter(uint8_t OSABI, bool Is64Bit);
-
-  ~RISCVELFObjectWriter() override;
-
-protected:
-  unsigned getRelocType(MCContext &Ctx, const MCValue &Target,
-                        const MCFixup &Fixup, bool IsPCRel) const override;
-};
-}
-
-RISCVELFObjectWriter::RISCVELFObjectWriter(uint8_t OSABI, bool Is64Bit)
-    : MCELFObjectTargetWriter(Is64Bit, OSABI, ELF::EM_RISCV,
-                              /*HasRelocationAddend*/ true) {}
-
-RISCVELFObjectWriter::~RISCVELFObjectWriter() {}
-
-unsigned RISCVELFObjectWriter::getRelocType(MCContext &Ctx,
-                                            const MCValue &Target,
-                                            const MCFixup &Fixup,
-                                            bool IsPCRel) const {
-  // Determine the type of the relocation
-  switch ((unsigned)Fixup.getKind()) {
-  default:
-    llvm_unreachable("invalid fixup kind!");
-  case FK_Data_4:
-    return ELF::R_RISCV_32;
-  case FK_Data_8:
-    return ELF::R_RISCV_64;
-  case RISCV::fixup_riscv_hi20:
-    return ELF::R_RISCV_HI20;
-  case RISCV::fixup_riscv_lo12_i:
-    return ELF::R_RISCV_LO12_I;
-  case RISCV::fixup_riscv_lo12_s:
-    return ELF::R_RISCV_LO12_S;
-  case RISCV::fixup_riscv_pcrel_hi20:
-    return ELF::R_RISCV_PCREL_HI20;
-  case RISCV::fixup_riscv_pcrel_lo12_i:
-    return ELF::R_RISCV_PCREL_LO12_I;
-  case RISCV::fixup_riscv_pcrel_lo12_s:
-    return ELF::R_RISCV_PCREL_LO12_S;
-  case RISCV::fixup_riscv_jal:
-    return ELF::R_RISCV_JAL;
-  case RISCV::fixup_riscv_branch:
-    return ELF::R_RISCV_BRANCH;
-  case RISCV::fixup_riscv_rvc_jump:
-    return ELF::R_RISCV_RVC_JUMP;
-  case RISCV::fixup_riscv_rvc_branch:
-    return ELF::R_RISCV_RVC_BRANCH;
-  }
-}
-
-std::unique_ptr<MCObjectWriter>
-llvm::createRISCVELFObjectWriter(raw_pwrite_stream &OS, uint8_t OSABI,
-                                 bool Is64Bit) {
-  return createELFObjectWriter(
-      llvm::make_unique<RISCVELFObjectWriter>(OSABI, Is64Bit), OS,
-      /*IsLittleEndian=*/true);
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
deleted file mode 100644
index 243f8ed7fb5..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-//===-- RISCVELFStreamer.cpp - RISCV ELF Target Streamer Methods ----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file provides RISCV specific target streamer methods.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVELFStreamer.h"
-#include "RISCVMCTargetDesc.h"
-#include "llvm/BinaryFormat/ELF.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-
-using namespace llvm;
-
-// This part is for ELF object output.
-RISCVTargetELFStreamer::RISCVTargetELFStreamer(MCStreamer &S,
-                                               const MCSubtargetInfo &STI)
-    : RISCVTargetStreamer(S) {
-  MCAssembler &MCA = getStreamer().getAssembler();
-
-  const FeatureBitset &Features = STI.getFeatureBits();
-
-  unsigned EFlags = MCA.getELFHeaderEFlags();
-
-  if (Features[RISCV::FeatureStdExtC])
-    EFlags |= ELF::EF_RISCV_RVC;
-
-  MCA.setELFHeaderEFlags(EFlags);
-}
-
-MCELFStreamer &RISCVTargetELFStreamer::getStreamer() {
-  return static_cast<MCELFStreamer &>(Streamer);
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h b/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h
deleted file mode 100644
index d3cfbe3e83c..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.h
+++ /dev/null
@@ -1,24 +0,0 @@
-//===-- RISCVELFStreamer.h - RISCV ELF Target Streamer ---------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVELFSTREAMER_H
-#define LLVM_LIB_TARGET_RISCV_RISCVELFSTREAMER_H
-
-#include "RISCVTargetStreamer.h"
-#include "llvm/MC/MCELFStreamer.h"
-
-namespace llvm {
-
-class RISCVTargetELFStreamer : public RISCVTargetStreamer {
-public:
-  MCELFStreamer &getStreamer();
-  RISCVTargetELFStreamer(MCStreamer &S, const MCSubtargetInfo &STI);
-};
-}
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h b/lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h
deleted file mode 100644
index 604c3dc9921..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVFixupKinds.h
+++ /dev/null
@@ -1,58 +0,0 @@
-//===-- RISCVFixupKinds.h - RISCV Specific Fixup Entries --------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVFIXUPKINDS_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVFIXUPKINDS_H
-
-#include "llvm/MC/MCFixup.h"
-
-#undef RISCV
-
-namespace llvm {
-namespace RISCV {
-enum Fixups {
-  // fixup_riscv_hi20 - 20-bit fixup corresponding to hi(foo) for
-  // instructions like lui
-  fixup_riscv_hi20 = FirstTargetFixupKind,
-  // fixup_riscv_lo12_i - 12-bit fixup corresponding to lo(foo) for
-  // instructions like addi
-  fixup_riscv_lo12_i,
-  // fixup_riscv_lo12_s - 12-bit fixup corresponding to lo(foo) for
-  // the S-type store instructions
-  fixup_riscv_lo12_s,
-  // fixup_riscv_pcrel_hi20 - 20-bit fixup corresponding to pcrel_hi(foo) for
-  // instructions like auipc
-  fixup_riscv_pcrel_hi20,
-  // fixup_riscv_pcrel_lo12_i - 12-bit fixup corresponding to pcrel_lo(foo) for
-  // instructions like addi
-  fixup_riscv_pcrel_lo12_i,
-  // fixup_riscv_pcrel_lo12_s - 12-bit fixup corresponding to pcrel_lo(foo) for
-  // the S-type store instructions
-  fixup_riscv_pcrel_lo12_s,
-  // fixup_riscv_jal - 20-bit fixup for symbol references in the jal
-  // instruction
-  fixup_riscv_jal,
-  // fixup_riscv_branch - 12-bit fixup for symbol references in the branch
-  // instructions
-  fixup_riscv_branch,
-  // fixup_riscv_rvc_jump - 11-bit fixup for symbol references in the
-  // compressed jump instruction
-  fixup_riscv_rvc_jump,
-  // fixup_riscv_rvc_branch - 8-bit fixup for symbol references in the
-  // compressed branch instruction
-  fixup_riscv_rvc_branch,
-
-  // fixup_riscv_invalid - used as a sentinel and a marker, must be last fixup
-  fixup_riscv_invalid,
-  NumTargetFixupKinds = fixup_riscv_invalid - FirstTargetFixupKind
-};
-} // end namespace RISCV
-} // end namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp
deleted file mode 100644
index d622911e92c..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-//===-- RISCVMCAsmInfo.cpp - RISCV Asm properties -------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the declarations of the RISCVMCAsmInfo properties.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVMCAsmInfo.h"
-#include "llvm/ADT/Triple.h"
-using namespace llvm;
-
-void RISCVMCAsmInfo::anchor() {}
-
-RISCVMCAsmInfo::RISCVMCAsmInfo(const Triple &TT) {
-  CodePointerSize = CalleeSaveStackSlotSize = TT.isArch64Bit() ? 8 : 4;
-  CommentString = "#";
-  AlignmentIsInBytes = false;
-  SupportsDebugInformation = true;
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h b/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h
deleted file mode 100644
index 901a1eba8af..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCAsmInfo.h
+++ /dev/null
@@ -1,31 +0,0 @@
-//===-- RISCVMCAsmInfo.h - RISCV Asm Info ----------------------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the declaration of the RISCVMCAsmInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCASMINFO_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCASMINFO_H
-
-#include "llvm/MC/MCAsmInfoELF.h"
-
-namespace llvm {
-class Triple;
-
-class RISCVMCAsmInfo : public MCAsmInfoELF {
-  void anchor() override;
-
-public:
-  explicit RISCVMCAsmInfo(const Triple &TargetTriple);
-};
-
-} // namespace llvm
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
deleted file mode 100644
index a1ecb3e5937..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCCodeEmitter.cpp
+++ /dev/null
@@ -1,209 +0,0 @@
-//===-- RISCVMCCodeEmitter.cpp - Convert RISCV code to machine code -------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file implements the RISCVMCCodeEmitter class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "MCTargetDesc/RISCVBaseInfo.h"
-#include "MCTargetDesc/RISCVFixupKinds.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "llvm/ADT/Statistic.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCCodeEmitter.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCInstrInfo.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/Casting.h"
-#include "llvm/Support/EndianStream.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "mccodeemitter"
-
-STATISTIC(MCNumEmitted, "Number of MC instructions emitted");
-STATISTIC(MCNumFixups, "Number of MC fixups created");
-
-namespace {
-class RISCVMCCodeEmitter : public MCCodeEmitter {
-  RISCVMCCodeEmitter(const RISCVMCCodeEmitter &) = delete;
-  void operator=(const RISCVMCCodeEmitter &) = delete;
-  MCContext &Ctx;
-  MCInstrInfo const &MCII;
-
-public:
-  RISCVMCCodeEmitter(MCContext &ctx, MCInstrInfo const &MCII)
-      : Ctx(ctx), MCII(MCII) {}
-
-  ~RISCVMCCodeEmitter() override {}
-
-  void encodeInstruction(const MCInst &MI, raw_ostream &OS,
-                         SmallVectorImpl<MCFixup> &Fixups,
-                         const MCSubtargetInfo &STI) const override;
-
-  /// TableGen'erated function for getting the binary encoding for an
-  /// instruction.
-  uint64_t getBinaryCodeForInstr(const MCInst &MI,
-                                 SmallVectorImpl<MCFixup> &Fixups,
-                                 const MCSubtargetInfo &STI) const;
-
-  /// Return binary encoding of operand. If the machine operand requires
-  /// relocation, record the relocation and return zero.
-  unsigned getMachineOpValue(const MCInst &MI, const MCOperand &MO,
-                             SmallVectorImpl<MCFixup> &Fixups,
-                             const MCSubtargetInfo &STI) const;
-
-  unsigned getImmOpValueAsr1(const MCInst &MI, unsigned OpNo,
-                             SmallVectorImpl<MCFixup> &Fixups,
-                             const MCSubtargetInfo &STI) const;
-
-  unsigned getImmOpValue(const MCInst &MI, unsigned OpNo,
-                         SmallVectorImpl<MCFixup> &Fixups,
-                         const MCSubtargetInfo &STI) const;
-};
-} // end anonymous namespace
-
-MCCodeEmitter *llvm::createRISCVMCCodeEmitter(const MCInstrInfo &MCII,
-                                              const MCRegisterInfo &MRI,
-                                              MCContext &Ctx) {
-  return new RISCVMCCodeEmitter(Ctx, MCII);
-}
-
-void RISCVMCCodeEmitter::encodeInstruction(const MCInst &MI, raw_ostream &OS,
-                                           SmallVectorImpl<MCFixup> &Fixups,
-                                           const MCSubtargetInfo &STI) const {
-  const MCInstrDesc &Desc = MCII.get(MI.getOpcode());
-  // Get byte count of instruction.
-  unsigned Size = Desc.getSize();
-
-  switch (Size) {
-  default:
-    llvm_unreachable("Unhandled encodeInstruction length!");
-  case 2: {
-    uint16_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
-    support::endian::Writer<support::little>(OS).write<uint16_t>(Bits);
-    break;
-  }
-  case 4: {
-    uint32_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
-    support::endian::Writer<support::little>(OS).write(Bits);
-    break;
-  }
-  }
-
-  ++MCNumEmitted; // Keep track of the # of mi's emitted.
-}
-
-unsigned
-RISCVMCCodeEmitter::getMachineOpValue(const MCInst &MI, const MCOperand &MO,
-                                      SmallVectorImpl<MCFixup> &Fixups,
-                                      const MCSubtargetInfo &STI) const {
-
-  if (MO.isReg())
-    return Ctx.getRegisterInfo()->getEncodingValue(MO.getReg());
-
-  if (MO.isImm())
-    return static_cast<unsigned>(MO.getImm());
-
-  llvm_unreachable("Unhandled expression!");
-  return 0;
-}
-
-unsigned
-RISCVMCCodeEmitter::getImmOpValueAsr1(const MCInst &MI, unsigned OpNo,
-                                      SmallVectorImpl<MCFixup> &Fixups,
-                                      const MCSubtargetInfo &STI) const {
-  const MCOperand &MO = MI.getOperand(OpNo);
-
-  if (MO.isImm()) {
-    unsigned Res = MO.getImm();
-    assert((Res & 1) == 0 && "LSB is non-zero");
-    return Res >> 1;
-  }
-
-  return getImmOpValue(MI, OpNo, Fixups, STI);
-}
-
-unsigned RISCVMCCodeEmitter::getImmOpValue(const MCInst &MI, unsigned OpNo,
-                                           SmallVectorImpl<MCFixup> &Fixups,
-                                           const MCSubtargetInfo &STI) const {
-
-  const MCOperand &MO = MI.getOperand(OpNo);
-
-  MCInstrDesc const &Desc = MCII.get(MI.getOpcode());
-  unsigned MIFrm = Desc.TSFlags & RISCVII::InstFormatMask;
-
-  // If the destination is an immediate, there is nothing to do
-  if (MO.isImm())
-    return MO.getImm();
-
-  assert(MO.isExpr() &&
-         "getImmOpValue expects only expressions or immediates");
-  const MCExpr *Expr = MO.getExpr();
-  MCExpr::ExprKind Kind = Expr->getKind();
-  RISCV::Fixups FixupKind = RISCV::fixup_riscv_invalid;
-  if (Kind == MCExpr::Target) {
-    const RISCVMCExpr *RVExpr = cast<RISCVMCExpr>(Expr);
-
-    switch (RVExpr->getKind()) {
-    case RISCVMCExpr::VK_RISCV_None:
-    case RISCVMCExpr::VK_RISCV_Invalid:
-      llvm_unreachable("Unhandled fixup kind!");
-    case RISCVMCExpr::VK_RISCV_LO:
-      if (MIFrm == RISCVII::InstFormatI)
-        FixupKind = RISCV::fixup_riscv_lo12_i;
-      else if (MIFrm == RISCVII::InstFormatS)
-        FixupKind = RISCV::fixup_riscv_lo12_s;
-      else
-        llvm_unreachable("VK_RISCV_LO used with unexpected instruction format");
-      break;
-    case RISCVMCExpr::VK_RISCV_HI:
-      FixupKind = RISCV::fixup_riscv_hi20;
-      break;
-    case RISCVMCExpr::VK_RISCV_PCREL_LO:
-      if (MIFrm == RISCVII::InstFormatI)
-        FixupKind = RISCV::fixup_riscv_pcrel_lo12_i;
-      else if (MIFrm == RISCVII::InstFormatS)
-        FixupKind = RISCV::fixup_riscv_pcrel_lo12_s;
-      else
-        llvm_unreachable(
-            "VK_RISCV_PCREL_LO used with unexpected instruction format");
-      break;
-    case RISCVMCExpr::VK_RISCV_PCREL_HI:
-      FixupKind = RISCV::fixup_riscv_pcrel_hi20;
-      break;
-    }
-  } else if (Kind == MCExpr::SymbolRef &&
-             cast<MCSymbolRefExpr>(Expr)->getKind() == MCSymbolRefExpr::VK_None) {
-    if (Desc.getOpcode() == RISCV::JAL) {
-      FixupKind = RISCV::fixup_riscv_jal;
-    } else if (MIFrm == RISCVII::InstFormatB) {
-      FixupKind = RISCV::fixup_riscv_branch;
-    } else if (MIFrm == RISCVII::InstFormatCJ) {
-      FixupKind = RISCV::fixup_riscv_rvc_jump;
-    } else if (MIFrm == RISCVII::InstFormatCB) {
-      FixupKind = RISCV::fixup_riscv_rvc_branch;
-    }
-  }
-
-  assert(FixupKind != RISCV::fixup_riscv_invalid && "Unhandled expression!");
-
-  Fixups.push_back(
-      MCFixup::create(0, Expr, MCFixupKind(FixupKind), MI.getLoc()));
-  ++MCNumFixups;
-
-  return 0;
-}
-
-#include "RISCVGenMCCodeEmitter.inc"
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp
deleted file mode 100644
index 68cdb3783b1..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-//===-- RISCVMCExpr.cpp - RISCV specific MC expression classes ------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the implementation of the assembly expression modifiers
-// accepted by the RISCV architecture (e.g. ":lo12:", ":gottprel_g1:", ...).
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVMCExpr.h"
-#include "llvm/MC/MCAssembler.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSymbolELF.h"
-#include "llvm/MC/MCValue.h"
-#include "llvm/Object/ELF.h"
-#include "llvm/Support/ErrorHandling.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscvmcexpr"
-
-const RISCVMCExpr *RISCVMCExpr::create(const MCExpr *Expr, VariantKind Kind,
-                                       MCContext &Ctx) {
-  return new (Ctx) RISCVMCExpr(Expr, Kind);
-}
-
-void RISCVMCExpr::printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const {
-  bool HasVariant = getKind() != VK_RISCV_None;
-  if (HasVariant)
-    OS << '%' << getVariantKindName(getKind()) << '(';
-  Expr->print(OS, MAI);
-  if (HasVariant)
-    OS << ')';
-}
-
-bool RISCVMCExpr::evaluateAsRelocatableImpl(MCValue &Res,
-                                            const MCAsmLayout *Layout,
-                                            const MCFixup *Fixup) const {
-  return getSubExpr()->evaluateAsRelocatable(Res, Layout, Fixup);
-}
-
-void RISCVMCExpr::visitUsedExpr(MCStreamer &Streamer) const {
-  Streamer.visitUsedExpr(*getSubExpr());
-}
-
-RISCVMCExpr::VariantKind RISCVMCExpr::getVariantKindForName(StringRef name) {
-  return StringSwitch<RISCVMCExpr::VariantKind>(name)
-      .Case("lo", VK_RISCV_LO)
-      .Case("hi", VK_RISCV_HI)
-      .Case("pcrel_lo", VK_RISCV_PCREL_LO)
-      .Case("pcrel_hi", VK_RISCV_PCREL_HI)
-      .Default(VK_RISCV_Invalid);
-}
-
-StringRef RISCVMCExpr::getVariantKindName(VariantKind Kind) {
-  switch (Kind) {
-  default:
-    llvm_unreachable("Invalid ELF symbol kind");
-  case VK_RISCV_LO:
-    return "lo";
-  case VK_RISCV_HI:
-    return "hi";
-  case VK_RISCV_PCREL_LO:
-    return "pcrel_lo";
-  case VK_RISCV_PCREL_HI:
-    return "pcrel_hi";
-  }
-}
-
-bool RISCVMCExpr::evaluateAsConstant(int64_t &Res) const {
-  MCValue Value;
-
-  if (Kind == VK_RISCV_PCREL_HI || Kind == VK_RISCV_PCREL_LO)
-    return false;
-
-  if (!getSubExpr()->evaluateAsRelocatable(Value, nullptr, nullptr))
-    return false;
-
-  if (!Value.isAbsolute())
-    return false;
-
-  Res = evaluateAsInt64(Value.getConstant());
-  return true;
-}
-
-int64_t RISCVMCExpr::evaluateAsInt64(int64_t Value) const {
-  switch (Kind) {
-  default:
-    llvm_unreachable("Invalid kind");
-  case VK_RISCV_LO:
-    return SignExtend64<12>(Value);
-  case VK_RISCV_HI:
-    // Add 1 if bit 11 is 1, to compensate for low 12 bits being negative.
-    return ((Value + 0x800) >> 12) & 0xfffff;
-  }
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h b/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h
deleted file mode 100644
index c49593f0b9c..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCExpr.h
+++ /dev/null
@@ -1,76 +0,0 @@
-//===-- RISCVMCExpr.h - RISCV specific MC expression classes ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes RISCV-specific MCExprs, used for modifiers like
-// "%hi" or "%lo" etc.,
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCEXPR_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCEXPR_H
-
-#include "llvm/MC/MCExpr.h"
-
-namespace llvm {
-
-class StringRef;
-class RISCVMCExpr : public MCTargetExpr {
-public:
-  enum VariantKind {
-    VK_RISCV_None,
-    VK_RISCV_LO,
-    VK_RISCV_HI,
-    VK_RISCV_PCREL_LO,
-    VK_RISCV_PCREL_HI,
-    VK_RISCV_Invalid
-  };
-
-private:
-  const MCExpr *Expr;
-  const VariantKind Kind;
-
-  int64_t evaluateAsInt64(int64_t Value) const;
-
-  explicit RISCVMCExpr(const MCExpr *Expr, VariantKind Kind)
-      : Expr(Expr), Kind(Kind) {}
-
-public:
-  static const RISCVMCExpr *create(const MCExpr *Expr, VariantKind Kind,
-                                   MCContext &Ctx);
-
-  VariantKind getKind() const { return Kind; }
-
-  const MCExpr *getSubExpr() const { return Expr; }
-
-  void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const override;
-  bool evaluateAsRelocatableImpl(MCValue &Res, const MCAsmLayout *Layout,
-                                 const MCFixup *Fixup) const override;
-  void visitUsedExpr(MCStreamer &Streamer) const override;
-  MCFragment *findAssociatedFragment() const override {
-    return getSubExpr()->findAssociatedFragment();
-  }
-
-  // There are no TLS RISCVMCExprs at the moment.
-  void fixELFSymbolsInTLSFixups(MCAssembler &Asm) const override {}
-
-  bool evaluateAsConstant(int64_t &Res) const;
-
-  static bool classof(const MCExpr *E) {
-    return E->getKind() == MCExpr::Target;
-  }
-
-  static bool classof(const RISCVMCExpr *) { return true; }
-
-  static VariantKind getVariantKindForName(StringRef name);
-  static StringRef getVariantKindName(VariantKind Kind);
-};
-
-} // end namespace llvm.
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
deleted file mode 100644
index b1fc7c0c678..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-//===-- RISCVMCTargetDesc.cpp - RISCV Target Descriptions -----------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-///
-/// This file provides RISCV-specific target descriptions.
-///
-//===----------------------------------------------------------------------===//
-
-#include "RISCVMCTargetDesc.h"
-#include "InstPrinter/RISCVInstPrinter.h"
-#include "RISCVELFStreamer.h"
-#include "RISCVMCAsmInfo.h"
-#include "RISCVTargetStreamer.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCInstrInfo.h"
-#include "llvm/MC/MCRegisterInfo.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSubtargetInfo.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/TargetRegistry.h"
-
-#define GET_INSTRINFO_MC_DESC
-#include "RISCVGenInstrInfo.inc"
-
-#define GET_REGINFO_MC_DESC
-#include "RISCVGenRegisterInfo.inc"
-
-#define GET_SUBTARGETINFO_MC_DESC
-#include "RISCVGenSubtargetInfo.inc"
-
-using namespace llvm;
-
-static MCInstrInfo *createRISCVMCInstrInfo() {
-  MCInstrInfo *X = new MCInstrInfo();
-  InitRISCVMCInstrInfo(X);
-  return X;
-}
-
-static MCRegisterInfo *createRISCVMCRegisterInfo(const Triple &TT) {
-  MCRegisterInfo *X = new MCRegisterInfo();
-  InitRISCVMCRegisterInfo(X, RISCV::X1);
-  return X;
-}
-
-static MCAsmInfo *createRISCVMCAsmInfo(const MCRegisterInfo &MRI,
-                                       const Triple &TT) {
-  return new RISCVMCAsmInfo(TT);
-}
-
-static MCSubtargetInfo *createRISCVMCSubtargetInfo(const Triple &TT,
-                                                   StringRef CPU, StringRef FS) {
-  std::string CPUName = CPU;
-  if (CPUName.empty())
-    CPUName = TT.isArch64Bit() ? "generic-rv64" : "generic-rv32";
-  return createRISCVMCSubtargetInfoImpl(TT, CPUName, FS);
-}
-
-static MCInstPrinter *createRISCVMCInstPrinter(const Triple &T,
-                                               unsigned SyntaxVariant,
-                                               const MCAsmInfo &MAI,
-                                               const MCInstrInfo &MII,
-                                               const MCRegisterInfo &MRI) {
-  return new RISCVInstPrinter(MAI, MII, MRI);
-}
-
-static MCTargetStreamer *
-createRISCVObjectTargetStreamer(MCStreamer &S, const MCSubtargetInfo &STI) {
-  const Triple &TT = STI.getTargetTriple();
-  if (TT.isOSBinFormatELF())
-    return new RISCVTargetELFStreamer(S, STI);
-  return new RISCVTargetStreamer(S);
-}
-
-extern "C" void LLVMInitializeRISCVTargetMC() {
-  for (Target *T : {&getTheRISCV32Target(), &getTheRISCV64Target()}) {
-    TargetRegistry::RegisterMCAsmInfo(*T, createRISCVMCAsmInfo);
-    TargetRegistry::RegisterMCInstrInfo(*T, createRISCVMCInstrInfo);
-    TargetRegistry::RegisterMCRegInfo(*T, createRISCVMCRegisterInfo);
-    TargetRegistry::RegisterMCAsmBackend(*T, createRISCVAsmBackend);
-    TargetRegistry::RegisterMCCodeEmitter(*T, createRISCVMCCodeEmitter);
-    TargetRegistry::RegisterMCInstPrinter(*T, createRISCVMCInstPrinter);
-    TargetRegistry::RegisterMCSubtargetInfo(*T, createRISCVMCSubtargetInfo);
-    TargetRegistry::RegisterObjectTargetStreamer(
-        *T, createRISCVObjectTargetStreamer);
-  }
-}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h b/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h
deleted file mode 100644
index ef58a6b8cbc..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVMCTargetDesc.h
+++ /dev/null
@@ -1,62 +0,0 @@
-//===-- RISCVMCTargetDesc.h - RISCV Target Descriptions ---------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file provides RISCV specific target descriptions.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCTARGETDESC_H
-#define LLVM_LIB_TARGET_RISCV_MCTARGETDESC_RISCVMCTARGETDESC_H
-
-#include "llvm/Config/config.h"
-#include "llvm/MC/MCTargetOptions.h"
-#include "llvm/Support/DataTypes.h"
-#include <memory>
-
-namespace llvm {
-class MCAsmBackend;
-class MCCodeEmitter;
-class MCContext;
-class MCInstrInfo;
-class MCObjectWriter;
-class MCRegisterInfo;
-class MCSubtargetInfo;
-class StringRef;
-class Target;
-class Triple;
-class raw_ostream;
-class raw_pwrite_stream;
-
-Target &getTheRISCV32Target();
-Target &getTheRISCV64Target();
-
-MCCodeEmitter *createRISCVMCCodeEmitter(const MCInstrInfo &MCII,
-                                        const MCRegisterInfo &MRI,
-                                        MCContext &Ctx);
-
-MCAsmBackend *createRISCVAsmBackend(const Target &T, const MCSubtargetInfo &STI,
-                                    const MCRegisterInfo &MRI,
-                                    const MCTargetOptions &Options);
-
-std::unique_ptr<MCObjectWriter>
-createRISCVELFObjectWriter(raw_pwrite_stream &OS, uint8_t OSABI, bool Is64Bit);
-}
-
-// Defines symbolic names for RISC-V registers.
-#define GET_REGINFO_ENUM
-#include "RISCVGenRegisterInfo.inc"
-
-// Defines symbolic names for RISC-V instructions.
-#define GET_INSTRINFO_ENUM
-#include "RISCVGenInstrInfo.inc"
-
-#define GET_SUBTARGETINFO_ENUM
-#include "RISCVGenSubtargetInfo.inc"
-
-#endif
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp b/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
deleted file mode 100644
index e72b0243b2e..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-//===-- RISCVTargetStreamer.cpp - RISCV Target Streamer Methods -----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file provides RISCV specific target streamer methods.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVTargetStreamer.h"
-
-using namespace llvm;
-
-RISCVTargetStreamer::RISCVTargetStreamer(MCStreamer &S) : MCTargetStreamer(S) {}
diff --git a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h b/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h
deleted file mode 100644
index 3f395405b59..00000000000
--- a/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.h
+++ /dev/null
@@ -1,22 +0,0 @@
-//===-- RISCVTargetStreamer.h - RISCV Target Streamer ----------*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVTARGETSTREAMER_H
-#define LLVM_LIB_TARGET_RISCV_RISCVTARGETSTREAMER_H
-
-#include "llvm/MC/MCStreamer.h"
-
-namespace llvm {
-
-class RISCVTargetStreamer : public MCTargetStreamer {
-public:
-  RISCVTargetStreamer(MCStreamer &S);
-};
-}
-#endif
diff --git a/lib/Target/RISCV/RISCV.h b/lib/Target/RISCV/RISCV.h
deleted file mode 100644
index 884cb2e5014..00000000000
--- a/lib/Target/RISCV/RISCV.h
+++ /dev/null
@@ -1,37 +0,0 @@
-//===-- RISCV.h - Top-level interface for RISCV -----------------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the entry points for global functions defined in the LLVM
-// RISC-V back-end.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCV_H
-#define LLVM_LIB_TARGET_RISCV_RISCV_H
-
-#include "MCTargetDesc/RISCVBaseInfo.h"
-
-namespace llvm {
-class RISCVTargetMachine;
-class AsmPrinter;
-class FunctionPass;
-class MCInst;
-class MCOperand;
-class MachineInstr;
-class MachineOperand;
-
-void LowerRISCVMachineInstrToMCInst(const MachineInstr *MI, MCInst &OutMI,
-                                    const AsmPrinter &AP);
-bool LowerRISCVMachineOperandToMCOperand(const MachineOperand &MO,
-                                         MCOperand &MCOp, const AsmPrinter &AP);
-
-FunctionPass *createRISCVISelDag(RISCVTargetMachine &TM);
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCV.td b/lib/Target/RISCV/RISCV.td
deleted file mode 100644
index 3e80d745b82..00000000000
--- a/lib/Target/RISCV/RISCV.td
+++ /dev/null
@@ -1,96 +0,0 @@
-//===-- RISCV.td - Describe the RISCV Target Machine -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-include "llvm/Target/Target.td"
-
-//===----------------------------------------------------------------------===//
-// RISC-V subtarget features and instruction predicates.
-//===----------------------------------------------------------------------===//
-
-def FeatureStdExtM
-    : SubtargetFeature<"m", "HasStdExtM", "true",
-                       "'M' (Integer Multiplication and Division)">;
-def HasStdExtM : Predicate<"Subtarget->hasStdExtM()">,
-                           AssemblerPredicate<"FeatureStdExtM">;
-
-def FeatureStdExtA
-    : SubtargetFeature<"a", "HasStdExtA", "true",
-                       "'A' (Atomic Instructions)">;
-def HasStdExtA : Predicate<"Subtarget->hasStdExtA()">,
-                           AssemblerPredicate<"FeatureStdExtA">;
-
-def FeatureStdExtF
-    : SubtargetFeature<"f", "HasStdExtF", "true",
-                       "'F' (Single-Precision Floating-Point)">;
-def HasStdExtF : Predicate<"Subtarget->hasStdExtF()">,
-                           AssemblerPredicate<"FeatureStdExtF">;
-
-def FeatureStdExtD
-    : SubtargetFeature<"d", "HasStdExtD", "true",
-                       "'D' (Double-Precision Floating-Point)",
-                       [FeatureStdExtF]>;
-def HasStdExtD : Predicate<"Subtarget->hasStdExtD()">,
-                           AssemblerPredicate<"FeatureStdExtD">;
-
-def FeatureStdExtC
-    : SubtargetFeature<"c", "HasStdExtC", "true",
-                       "'C' (Compressed Instructions)">;
-def HasStdExtC : Predicate<"Subtarget->hasStdExtC()">,
-                           AssemblerPredicate<"FeatureStdExtC">;
-
-
-def Feature64Bit
-    : SubtargetFeature<"64bit", "HasRV64", "true", "Implements RV64">;
-def IsRV64 : Predicate<"Subtarget->is64Bit()">,
-                       AssemblerPredicate<"Feature64Bit">;
-def IsRV32 : Predicate<"!Subtarget->is64Bit()">,
-                       AssemblerPredicate<"!Feature64Bit">;
-
-def RV64           : HwMode<"+64bit">;
-def RV32           : HwMode<"-64bit">;
-
-//===----------------------------------------------------------------------===//
-// Registers, calling conventions, instruction descriptions.
-//===----------------------------------------------------------------------===//
-
-include "RISCVRegisterInfo.td"
-include "RISCVCallingConv.td"
-include "RISCVInstrInfo.td"
-
-//===----------------------------------------------------------------------===//
-// RISC-V processors supported.
-//===----------------------------------------------------------------------===//
-
-def : ProcessorModel<"generic-rv32", NoSchedModel, []>;
-
-def : ProcessorModel<"generic-rv64", NoSchedModel, [Feature64Bit]>;
-
-//===----------------------------------------------------------------------===//
-// Define the RISC-V target.
-//===----------------------------------------------------------------------===//
-
-def RISCVInstrInfo : InstrInfo {
-  let guessInstructionProperties = 0;
-}
-
-def RISCVAsmParser : AsmParser {
-  let ShouldEmitMatchRegisterAltName = 1;
-  let AllowDuplicateRegisterNames = 1;
-}
-
-def RISCVAsmWriter : AsmWriter {
-  int PassSubtarget = 1;
-}
-
-def RISCV : Target {
-  let InstructionSet = RISCVInstrInfo;
-  let AssemblyParsers = [RISCVAsmParser];
-  let AssemblyWriters = [RISCVAsmWriter];
-  let AllowRegisterRenaming = 1;
-}
diff --git a/lib/Target/RISCV/RISCVAsmPrinter.cpp b/lib/Target/RISCV/RISCVAsmPrinter.cpp
deleted file mode 100644
index bbaa8ec454f..00000000000
--- a/lib/Target/RISCV/RISCVAsmPrinter.cpp
+++ /dev/null
@@ -1,127 +0,0 @@
-//===-- RISCVAsmPrinter.cpp - RISCV LLVM assembly writer ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains a printer that converts from our internal representation
-// of machine-dependent LLVM code to the RISCV assembly language.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "InstPrinter/RISCVInstPrinter.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/CodeGen/AsmPrinter.h"
-#include "llvm/CodeGen/MachineConstantPool.h"
-#include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineInstr.h"
-#include "llvm/CodeGen/MachineModuleInfo.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/MC/MCStreamer.h"
-#include "llvm/MC/MCSymbol.h"
-#include "llvm/Support/TargetRegistry.h"
-#include "llvm/Support/raw_ostream.h"
-using namespace llvm;
-
-#define DEBUG_TYPE "asm-printer"
-
-namespace {
-class RISCVAsmPrinter : public AsmPrinter {
-public:
-  explicit RISCVAsmPrinter(TargetMachine &TM,
-                           std::unique_ptr<MCStreamer> Streamer)
-      : AsmPrinter(TM, std::move(Streamer)) {}
-
-  StringRef getPassName() const override { return "RISCV Assembly Printer"; }
-
-  void EmitInstruction(const MachineInstr *MI) override;
-
-  bool PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
-                       unsigned AsmVariant, const char *ExtraCode,
-                       raw_ostream &OS) override;
-  bool PrintAsmMemoryOperand(const MachineInstr *MI, unsigned OpNo,
-                             unsigned AsmVariant, const char *ExtraCode,
-                             raw_ostream &OS) override;
-
-  bool emitPseudoExpansionLowering(MCStreamer &OutStreamer,
-                                   const MachineInstr *MI);
-
-  // Wrapper needed for tblgenned pseudo lowering.
-  bool lowerOperand(const MachineOperand &MO, MCOperand &MCOp) const {
-    return LowerRISCVMachineOperandToMCOperand(MO, MCOp, *this);
-  }
-};
-}
-
-// Simple pseudo-instructions have their lowering (with expansion to real
-// instructions) auto-generated.
-#include "RISCVGenMCPseudoLowering.inc"
-
-void RISCVAsmPrinter::EmitInstruction(const MachineInstr *MI) {
-  // Do any auto-generated pseudo lowerings.
-  if (emitPseudoExpansionLowering(*OutStreamer, MI))
-    return;
-
-  MCInst TmpInst;
-  LowerRISCVMachineInstrToMCInst(MI, TmpInst, *this);
-  EmitToStreamer(*OutStreamer, TmpInst);
-}
-
-bool RISCVAsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
-                                      unsigned AsmVariant,
-                                      const char *ExtraCode, raw_ostream &OS) {
-  if (AsmVariant != 0)
-    report_fatal_error("There are no defined alternate asm variants");
-
-  // First try the generic code, which knows about modifiers like 'c' and 'n'.
-  if (!AsmPrinter::PrintAsmOperand(MI, OpNo, AsmVariant, ExtraCode, OS))
-    return false;
-
-  if (!ExtraCode) {
-    const MachineOperand &MO = MI->getOperand(OpNo);
-    switch (MO.getType()) {
-    case MachineOperand::MO_Immediate:
-      OS << MO.getImm();
-      return false;
-    case MachineOperand::MO_Register:
-      OS << RISCVInstPrinter::getRegisterName(MO.getReg());
-      return false;
-    default:
-      break;
-    }
-  }
-
-  return true;
-}
-
-bool RISCVAsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI,
-                                            unsigned OpNo, unsigned AsmVariant,
-                                            const char *ExtraCode,
-                                            raw_ostream &OS) {
-  if (AsmVariant != 0)
-    report_fatal_error("There are no defined alternate asm variants");
-
-  if (!ExtraCode) {
-    const MachineOperand &MO = MI->getOperand(OpNo);
-    // For now, we only support register memory operands in registers and
-    // assume there is no addend
-    if (!MO.isReg())
-      return true;
-
-    OS << "0(" << RISCVInstPrinter::getRegisterName(MO.getReg()) << ")";
-    return false;
-  }
-
-  return AsmPrinter::PrintAsmMemoryOperand(MI, OpNo, AsmVariant, ExtraCode, OS);
-}
-
-// Force static initialization.
-extern "C" void LLVMInitializeRISCVAsmPrinter() {
-  RegisterAsmPrinter<RISCVAsmPrinter> X(getTheRISCV32Target());
-  RegisterAsmPrinter<RISCVAsmPrinter> Y(getTheRISCV64Target());
-}
diff --git a/lib/Target/RISCV/RISCVCallingConv.td b/lib/Target/RISCV/RISCVCallingConv.td
deleted file mode 100644
index d2b17c64c9c..00000000000
--- a/lib/Target/RISCV/RISCVCallingConv.td
+++ /dev/null
@@ -1,20 +0,0 @@
-//===-- RISCVCallingConv.td - Calling Conventions RISCV ----*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This describes the calling conventions for the RISCV architecture.
-//
-//===----------------------------------------------------------------------===//
-
-// The RISC-V calling convention is handled with custom code in
-// RISCVISelLowering.cpp (CC_RISCV).
-
-def CSR : CalleeSavedRegs<(add X1, X3, X4, X8, X9, (sequence "X%u", 18, 27))>;
-
-// Needed for implementation of RISCVRegisterInfo::getNoPreservedMask()
-def CSR_NoRegs : CalleeSavedRegs<(add)>;
diff --git a/lib/Target/RISCV/RISCVFrameLowering.cpp b/lib/Target/RISCV/RISCVFrameLowering.cpp
deleted file mode 100644
index 33703f5ec20..00000000000
--- a/lib/Target/RISCV/RISCVFrameLowering.cpp
+++ /dev/null
@@ -1,248 +0,0 @@
-//===-- RISCVFrameLowering.cpp - RISCV Frame Information ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of TargetFrameLowering class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVFrameLowering.h"
-#include "RISCVMachineFunctionInfo.h"
-#include "RISCVSubtarget.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/MachineRegisterInfo.h"
-#include "llvm/CodeGen/RegisterScavenging.h"
-
-using namespace llvm;
-
-bool RISCVFrameLowering::hasFP(const MachineFunction &MF) const {
-  const TargetRegisterInfo *RegInfo = MF.getSubtarget().getRegisterInfo();
-
-  const MachineFrameInfo &MFI = MF.getFrameInfo();
-  return MF.getTarget().Options.DisableFramePointerElim(MF) ||
-         RegInfo->needsStackRealignment(MF) || MFI.hasVarSizedObjects() ||
-         MFI.isFrameAddressTaken();
-}
-
-// Determines the size of the frame and maximum call frame size.
-void RISCVFrameLowering::determineFrameLayout(MachineFunction &MF) const {
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  const RISCVRegisterInfo *RI = STI.getRegisterInfo();
-
-  // Get the number of bytes to allocate from the FrameInfo.
-  uint64_t FrameSize = MFI.getStackSize();
-
-  // Get the alignment.
-  uint64_t StackAlign = RI->needsStackRealignment(MF) ? MFI.getMaxAlignment()
-                                                      : getStackAlignment();
-
-  // Get the maximum call frame size of all the calls.
-  uint64_t MaxCallFrameSize = MFI.getMaxCallFrameSize();
-
-  // If we have dynamic alloca then MaxCallFrameSize needs to be aligned so
-  // that allocations will be aligned.
-  if (MFI.hasVarSizedObjects())
-    MaxCallFrameSize = alignTo(MaxCallFrameSize, StackAlign);
-
-  // Update maximum call frame size.
-  MFI.setMaxCallFrameSize(MaxCallFrameSize);
-
-  // Include call frame size in total.
-  if (!(hasReservedCallFrame(MF) && MFI.adjustsStack()))
-    FrameSize += MaxCallFrameSize;
-
-  // Make sure the frame is aligned.
-  FrameSize = alignTo(FrameSize, StackAlign);
-
-  // Update frame info.
-  MFI.setStackSize(FrameSize);
-}
-
-void RISCVFrameLowering::adjustReg(MachineBasicBlock &MBB,
-                                   MachineBasicBlock::iterator MBBI,
-                                   const DebugLoc &DL, unsigned DestReg,
-                                   unsigned SrcReg, int64_t Val,
-                                   MachineInstr::MIFlag Flag) const {
-  MachineRegisterInfo &MRI = MBB.getParent()->getRegInfo();
-  const RISCVInstrInfo *TII = STI.getInstrInfo();
-
-  if (DestReg == SrcReg && Val == 0)
-    return;
-
-  if (isInt<12>(Val)) {
-    BuildMI(MBB, MBBI, DL, TII->get(RISCV::ADDI), DestReg)
-        .addReg(SrcReg)
-        .addImm(Val)
-        .setMIFlag(Flag);
-  } else if (isInt<32>(Val)) {
-    unsigned Opc = RISCV::ADD;
-    bool isSub = Val < 0;
-    if (isSub) {
-      Val = -Val;
-      Opc = RISCV::SUB;
-    }
-
-    unsigned ScratchReg = MRI.createVirtualRegister(&RISCV::GPRRegClass);
-    TII->movImm32(MBB, MBBI, DL, ScratchReg, Val, Flag);
-    BuildMI(MBB, MBBI, DL, TII->get(Opc), DestReg)
-        .addReg(SrcReg)
-        .addReg(ScratchReg, RegState::Kill)
-        .setMIFlag(Flag);
-  } else {
-    report_fatal_error("adjustReg cannot yet handle adjustments >32 bits");
-  }
-}
-
-// Returns the register used to hold the frame pointer.
-static unsigned getFPReg(const RISCVSubtarget &STI) { return RISCV::X8; }
-
-// Returns the register used to hold the stack pointer.
-static unsigned getSPReg(const RISCVSubtarget &STI) { return RISCV::X2; }
-
-void RISCVFrameLowering::emitPrologue(MachineFunction &MF,
-                                      MachineBasicBlock &MBB) const {
-  assert(&MF.front() == &MBB && "Shrink-wrapping not yet supported");
-
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  auto *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-  MachineBasicBlock::iterator MBBI = MBB.begin();
-
-  unsigned FPReg = getFPReg(STI);
-  unsigned SPReg = getSPReg(STI);
-
-  // Debug location must be unknown since the first debug location is used
-  // to determine the end of the prologue.
-  DebugLoc DL;
-
-  // Determine the correct frame layout
-  determineFrameLayout(MF);
-
-  // FIXME (note copied from Lanai): This appears to be overallocating.  Needs
-  // investigation. Get the number of bytes to allocate from the FrameInfo.
-  uint64_t StackSize = MFI.getStackSize();
-
-  // Early exit if there is no need to allocate on the stack
-  if (StackSize == 0 && !MFI.adjustsStack())
-    return;
-
-  // Allocate space on the stack if necessary.
-  adjustReg(MBB, MBBI, DL, SPReg, SPReg, -StackSize, MachineInstr::FrameSetup);
-
-  // The frame pointer is callee-saved, and code has been generated for us to
-  // save it to the stack. We need to skip over the storing of callee-saved
-  // registers as the frame pointer must be modified after it has been saved
-  // to the stack, not before.
-  // FIXME: assumes exactly one instruction is used to save each callee-saved
-  // register.
-  const std::vector<CalleeSavedInfo> &CSI = MFI.getCalleeSavedInfo();
-  std::advance(MBBI, CSI.size());
-
-  // Generate new FP.
-  if (hasFP(MF))
-    adjustReg(MBB, MBBI, DL, FPReg, SPReg,
-              StackSize - RVFI->getVarArgsSaveSize(), MachineInstr::FrameSetup);
-}
-
-void RISCVFrameLowering::emitEpilogue(MachineFunction &MF,
-                                      MachineBasicBlock &MBB) const {
-  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
-  const RISCVRegisterInfo *RI = STI.getRegisterInfo();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  auto *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-  DebugLoc DL = MBBI->getDebugLoc();
-  unsigned FPReg = getFPReg(STI);
-  unsigned SPReg = getSPReg(STI);
-
-  // Skip to before the restores of callee-saved registers
-  // FIXME: assumes exactly one instruction is used to restore each
-  // callee-saved register.
-  MachineBasicBlock::iterator LastFrameDestroy = MBBI;
-  std::advance(LastFrameDestroy, -MFI.getCalleeSavedInfo().size());
-
-  uint64_t StackSize = MFI.getStackSize();
-
-  // Restore the stack pointer using the value of the frame pointer. Only
-  // necessary if the stack pointer was modified, meaning the stack size is
-  // unknown.
-  if (RI->needsStackRealignment(MF) || MFI.hasVarSizedObjects()) {
-    assert(hasFP(MF) && "frame pointer should not have been eliminated");
-    adjustReg(MBB, LastFrameDestroy, DL, SPReg, FPReg,
-              -StackSize + RVFI->getVarArgsSaveSize(),
-              MachineInstr::FrameDestroy);
-  }
-
-  // Deallocate stack
-  adjustReg(MBB, MBBI, DL, SPReg, SPReg, StackSize, MachineInstr::FrameDestroy);
-}
-
-int RISCVFrameLowering::getFrameIndexReference(const MachineFunction &MF,
-                                               int FI,
-                                               unsigned &FrameReg) const {
-  const MachineFrameInfo &MFI = MF.getFrameInfo();
-  const TargetRegisterInfo *RI = MF.getSubtarget().getRegisterInfo();
-  const auto *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-
-  // Callee-saved registers should be referenced relative to the stack
-  // pointer (positive offset), otherwise use the frame pointer (negative
-  // offset).
-  const std::vector<CalleeSavedInfo> &CSI = MFI.getCalleeSavedInfo();
-  int MinCSFI = 0;
-  int MaxCSFI = -1;
-
-  int Offset = MFI.getObjectOffset(FI) - getOffsetOfLocalArea() +
-               MFI.getOffsetAdjustment();
-
-  if (CSI.size()) {
-    MinCSFI = CSI[0].getFrameIdx();
-    MaxCSFI = CSI[CSI.size() - 1].getFrameIdx();
-  }
-
-  if (FI >= MinCSFI && FI <= MaxCSFI) {
-    FrameReg = RISCV::X2;
-    Offset += MF.getFrameInfo().getStackSize();
-  } else {
-    FrameReg = RI->getFrameRegister(MF);
-    if (hasFP(MF))
-      Offset += RVFI->getVarArgsSaveSize();
-    else
-      Offset += MF.getFrameInfo().getStackSize();
-  }
-  return Offset;
-}
-
-void RISCVFrameLowering::determineCalleeSaves(MachineFunction &MF,
-                                              BitVector &SavedRegs,
-                                              RegScavenger *RS) const {
-  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);
-  // Unconditionally spill RA and FP only if the function uses a frame
-  // pointer.
-  if (hasFP(MF)) {
-    SavedRegs.set(RISCV::X1);
-    SavedRegs.set(RISCV::X8);
-  }
-}
-
-void RISCVFrameLowering::processFunctionBeforeFrameFinalized(
-    MachineFunction &MF, RegScavenger *RS) const {
-  const TargetRegisterInfo *RegInfo = MF.getSubtarget().getRegisterInfo();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  const TargetRegisterClass *RC = &RISCV::GPRRegClass;
-  // estimateStackSize has been observed to under-estimate the final stack
-  // size, so give ourselves wiggle-room by checking for stack size
-  // representable an 11-bit signed field rather than 12-bits.
-  // FIXME: It may be possible to craft a function with a small stack that
-  // still needs an emergency spill slot for branch relaxation. This case
-  // would currently be missed.
-  if (!isInt<11>(MFI.estimateStackSize(MF))) {
-    int RegScavFI = MFI.CreateStackObject(
-        RegInfo->getSpillSize(*RC), RegInfo->getSpillAlignment(*RC), false);
-    RS->addScavengingFrameIndex(RegScavFI);
-  }
-}
diff --git a/lib/Target/RISCV/RISCVFrameLowering.h b/lib/Target/RISCV/RISCVFrameLowering.h
deleted file mode 100644
index ccf7e247b55..00000000000
--- a/lib/Target/RISCV/RISCVFrameLowering.h
+++ /dev/null
@@ -1,60 +0,0 @@
-//===-- RISCVFrameLowering.h - Define frame lowering for RISCV -*- C++ -*--===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This class implements RISCV-specific bits of TargetFrameLowering class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVFRAMELOWERING_H
-#define LLVM_LIB_TARGET_RISCV_RISCVFRAMELOWERING_H
-
-#include "llvm/CodeGen/TargetFrameLowering.h"
-
-namespace llvm {
-class RISCVSubtarget;
-
-class RISCVFrameLowering : public TargetFrameLowering {
-public:
-  explicit RISCVFrameLowering(const RISCVSubtarget &STI)
-      : TargetFrameLowering(StackGrowsDown,
-                            /*StackAlignment=*/16,
-                            /*LocalAreaOffset=*/0),
-        STI(STI) {}
-
-  void emitPrologue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
-  void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
-
-  int getFrameIndexReference(const MachineFunction &MF, int FI,
-                             unsigned &FrameReg) const override;
-
-  void determineCalleeSaves(MachineFunction &MF, BitVector &SavedRegs,
-                            RegScavenger *RS) const override;
-
-  void processFunctionBeforeFrameFinalized(MachineFunction &MF,
-                                           RegScavenger *RS) const override;
-
-  bool hasFP(const MachineFunction &MF) const override;
-
-  MachineBasicBlock::iterator
-  eliminateCallFramePseudoInstr(MachineFunction &MF, MachineBasicBlock &MBB,
-                                MachineBasicBlock::iterator MI) const override {
-    return MBB.erase(MI);
-  }
-
-protected:
-  const RISCVSubtarget &STI;
-
-private:
-  void determineFrameLayout(MachineFunction &MF) const;
-  void adjustReg(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                 const DebugLoc &DL, unsigned DestReg, unsigned SrcReg,
-                 int64_t Val, MachineInstr::MIFlag Flag) const;
-};
-}
-#endif
diff --git a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
deleted file mode 100644
index d07301df718..00000000000
--- a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ /dev/null
@@ -1,124 +0,0 @@
-//===-- RISCVISelDAGToDAG.cpp - A dag to dag inst selector for RISCV ------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines an instruction selector for the RISCV target.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/SelectionDAGISel.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/MathExtras.h"
-#include "llvm/Support/raw_ostream.h"
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-isel"
-
-// RISCV-specific code to select RISCV machine instructions for
-// SelectionDAG operations.
-namespace {
-class RISCVDAGToDAGISel final : public SelectionDAGISel {
-  const RISCVSubtarget *Subtarget;
-
-public:
-  explicit RISCVDAGToDAGISel(RISCVTargetMachine &TargetMachine)
-      : SelectionDAGISel(TargetMachine) {}
-
-  StringRef getPassName() const override {
-    return "RISCV DAG->DAG Pattern Instruction Selection";
-  }
-
-  bool runOnMachineFunction(MachineFunction &MF) override {
-    Subtarget = &MF.getSubtarget<RISCVSubtarget>();
-    return SelectionDAGISel::runOnMachineFunction(MF);
-  }
-
-  void Select(SDNode *Node) override;
-
-  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
-                                    std::vector<SDValue> &OutOps) override;
-
-  bool SelectAddrFI(SDValue Addr, SDValue &Base);
-
-// Include the pieces autogenerated from the target description.
-#include "RISCVGenDAGISel.inc"
-};
-}
-
-void RISCVDAGToDAGISel::Select(SDNode *Node) {
-  unsigned Opcode = Node->getOpcode();
-  MVT XLenVT = Subtarget->getXLenVT();
-
-  // If we have a custom node, we have already selected
-  if (Node->isMachineOpcode()) {
-    DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
-    Node->setNodeId(-1);
-    return;
-  }
-
-  // Instruction Selection not handled by the auto-generated tablegen selection
-  // should be handled here.
-  EVT VT = Node->getValueType(0);
-  if (Opcode == ISD::Constant && VT == XLenVT) {
-    auto *ConstNode = cast<ConstantSDNode>(Node);
-    // Materialize zero constants as copies from X0. This allows the coalescer
-    // to propagate these into other instructions.
-    if (ConstNode->isNullValue()) {
-      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
-                                           RISCV::X0, XLenVT);
-      ReplaceNode(Node, New.getNode());
-      return;
-    }
-  }
-  if (Opcode == ISD::FrameIndex) {
-    SDLoc DL(Node);
-    SDValue Imm = CurDAG->getTargetConstant(0, DL, XLenVT);
-    int FI = dyn_cast<FrameIndexSDNode>(Node)->getIndex();
-    EVT VT = Node->getValueType(0);
-    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
-    ReplaceNode(Node, CurDAG->getMachineNode(RISCV::ADDI, DL, VT, TFI, Imm));
-    return;
-  }
-
-  // Select the default instruction.
-  SelectCode(Node);
-}
-
-bool RISCVDAGToDAGISel::SelectInlineAsmMemoryOperand(
-    const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
-  switch (ConstraintID) {
-  case InlineAsm::Constraint_i:
-  case InlineAsm::Constraint_m:
-    // We just support simple memory operands that have a single address
-    // operand and need no special handling.
-    OutOps.push_back(Op);
-    return false;
-  default:
-    break;
-  }
-
-  return true;
-}
-
-bool RISCVDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
-  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
-    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), Subtarget->getXLenVT());
-    return true;
-  }
-  return false;
-}
-
-// This pass converts a legalized DAG into a RISCV-specific DAG, ready
-// for instruction scheduling.
-FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM) {
-  return new RISCVDAGToDAGISel(TM);
-}
diff --git a/lib/Target/RISCV/RISCVISelLowering.cpp b/lib/Target/RISCV/RISCVISelLowering.cpp
deleted file mode 100644
index 239a144745c..00000000000
--- a/lib/Target/RISCV/RISCVISelLowering.cpp
+++ /dev/null
@@ -1,1080 +0,0 @@
-//===-- RISCVISelLowering.cpp - RISCV DAG Lowering Implementation  --------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the interfaces that RISCV uses to lower LLVM code into a
-// selection DAG.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVISelLowering.h"
-#include "RISCV.h"
-#include "RISCVMachineFunctionInfo.h"
-#include "RISCVRegisterInfo.h"
-#include "RISCVSubtarget.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/CodeGen/CallingConvLower.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/MachineRegisterInfo.h"
-#include "llvm/CodeGen/SelectionDAGISel.h"
-#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
-#include "llvm/CodeGen/ValueTypes.h"
-#include "llvm/IR/DiagnosticInfo.h"
-#include "llvm/IR/DiagnosticPrinter.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-lower"
-
-RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
-                                         const RISCVSubtarget &STI)
-    : TargetLowering(TM), Subtarget(STI) {
-
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  // Set up the register classes.
-  addRegisterClass(XLenVT, &RISCV::GPRRegClass);
-
-  // Compute derived properties from the register classes.
-  computeRegisterProperties(STI.getRegisterInfo());
-
-  setStackPointerRegisterToSaveRestore(RISCV::X2);
-
-  for (auto N : {ISD::EXTLOAD, ISD::SEXTLOAD, ISD::ZEXTLOAD})
-    setLoadExtAction(N, XLenVT, MVT::i1, Promote);
-
-  // TODO: add all necessary setOperationAction calls.
-  setOperationAction(ISD::DYNAMIC_STACKALLOC, XLenVT, Expand);
-
-  setOperationAction(ISD::BR_JT, MVT::Other, Expand);
-  setOperationAction(ISD::BR_CC, XLenVT, Expand);
-  setOperationAction(ISD::SELECT, XLenVT, Custom);
-  setOperationAction(ISD::SELECT_CC, XLenVT, Expand);
-
-  setOperationAction(ISD::STACKSAVE, MVT::Other, Expand);
-  setOperationAction(ISD::STACKRESTORE, MVT::Other, Expand);
-
-  setOperationAction(ISD::VASTART, MVT::Other, Custom);
-  setOperationAction(ISD::VAARG, MVT::Other, Expand);
-  setOperationAction(ISD::VACOPY, MVT::Other, Expand);
-  setOperationAction(ISD::VAEND, MVT::Other, Expand);
-
-  for (auto VT : {MVT::i1, MVT::i8, MVT::i16})
-    setOperationAction(ISD::SIGN_EXTEND_INREG, VT, Expand);
-
-  setOperationAction(ISD::ADDC, XLenVT, Expand);
-  setOperationAction(ISD::ADDE, XLenVT, Expand);
-  setOperationAction(ISD::SUBC, XLenVT, Expand);
-  setOperationAction(ISD::SUBE, XLenVT, Expand);
-
-  if (!Subtarget.hasStdExtM()) {
-    setOperationAction(ISD::MUL, XLenVT, Expand);
-    setOperationAction(ISD::MULHS, XLenVT, Expand);
-    setOperationAction(ISD::MULHU, XLenVT, Expand);
-    setOperationAction(ISD::SDIV, XLenVT, Expand);
-    setOperationAction(ISD::UDIV, XLenVT, Expand);
-    setOperationAction(ISD::SREM, XLenVT, Expand);
-    setOperationAction(ISD::UREM, XLenVT, Expand);
-  }
-
-  setOperationAction(ISD::SDIVREM, XLenVT, Expand);
-  setOperationAction(ISD::UDIVREM, XLenVT, Expand);
-  setOperationAction(ISD::SMUL_LOHI, XLenVT, Expand);
-  setOperationAction(ISD::UMUL_LOHI, XLenVT, Expand);
-
-  setOperationAction(ISD::SHL_PARTS, XLenVT, Expand);
-  setOperationAction(ISD::SRL_PARTS, XLenVT, Expand);
-  setOperationAction(ISD::SRA_PARTS, XLenVT, Expand);
-
-  setOperationAction(ISD::ROTL, XLenVT, Expand);
-  setOperationAction(ISD::ROTR, XLenVT, Expand);
-  setOperationAction(ISD::BSWAP, XLenVT, Expand);
-  setOperationAction(ISD::CTTZ, XLenVT, Expand);
-  setOperationAction(ISD::CTLZ, XLenVT, Expand);
-  setOperationAction(ISD::CTPOP, XLenVT, Expand);
-
-  setOperationAction(ISD::GlobalAddress, XLenVT, Custom);
-  setOperationAction(ISD::BlockAddress, XLenVT, Custom);
-
-  setBooleanContents(ZeroOrOneBooleanContent);
-
-  // Function alignments (log2).
-  setMinFunctionAlignment(3);
-  setPrefFunctionAlignment(3);
-
-  // Effectively disable jump table generation.
-  setMinimumJumpTableEntries(INT_MAX);
-}
-
-EVT RISCVTargetLowering::getSetCCResultType(const DataLayout &DL, LLVMContext &,
-                                            EVT VT) const {
-  if (!VT.isVector())
-    return getPointerTy(DL);
-  return VT.changeVectorElementTypeToInteger();
-}
-
-// Changes the condition code and swaps operands if necessary, so the SetCC
-// operation matches one of the comparisons supported directly in the RISC-V
-// ISA.
-static void normaliseSetCC(SDValue &LHS, SDValue &RHS, ISD::CondCode &CC) {
-  switch (CC) {
-  default:
-    break;
-  case ISD::SETGT:
-  case ISD::SETLE:
-  case ISD::SETUGT:
-  case ISD::SETULE:
-    CC = ISD::getSetCCSwappedOperands(CC);
-    std::swap(LHS, RHS);
-    break;
-  }
-}
-
-// Return the RISC-V branch opcode that matches the given DAG integer
-// condition code. The CondCode must be one of those supported by the RISC-V
-// ISA (see normaliseSetCC).
-static unsigned getBranchOpcodeForIntCondCode(ISD::CondCode CC) {
-  switch (CC) {
-  default:
-    llvm_unreachable("Unsupported CondCode");
-  case ISD::SETEQ:
-    return RISCV::BEQ;
-  case ISD::SETNE:
-    return RISCV::BNE;
-  case ISD::SETLT:
-    return RISCV::BLT;
-  case ISD::SETGE:
-    return RISCV::BGE;
-  case ISD::SETULT:
-    return RISCV::BLTU;
-  case ISD::SETUGE:
-    return RISCV::BGEU;
-  }
-}
-
-SDValue RISCVTargetLowering::LowerOperation(SDValue Op,
-                                            SelectionDAG &DAG) const {
-  switch (Op.getOpcode()) {
-  default:
-    report_fatal_error("unimplemented operand");
-  case ISD::GlobalAddress:
-    return lowerGlobalAddress(Op, DAG);
-  case ISD::BlockAddress:
-    return lowerBlockAddress(Op, DAG);
-  case ISD::SELECT:
-    return lowerSELECT(Op, DAG);
-  case ISD::VASTART:
-    return lowerVASTART(Op, DAG);
-  case ISD::FRAMEADDR:
-    return LowerFRAMEADDR(Op, DAG);
-  case ISD::RETURNADDR:
-    return LowerRETURNADDR(Op, DAG);
-  }
-}
-
-SDValue RISCVTargetLowering::lowerGlobalAddress(SDValue Op,
-                                                SelectionDAG &DAG) const {
-  SDLoc DL(Op);
-  EVT Ty = Op.getValueType();
-  GlobalAddressSDNode *N = cast<GlobalAddressSDNode>(Op);
-  const GlobalValue *GV = N->getGlobal();
-  int64_t Offset = N->getOffset();
-
-  if (isPositionIndependent() || Subtarget.is64Bit())
-    report_fatal_error("Unable to lowerGlobalAddress");
-
-  SDValue GAHi =
-    DAG.getTargetGlobalAddress(GV, DL, Ty, Offset, RISCVII::MO_HI);
-  SDValue GALo =
-    DAG.getTargetGlobalAddress(GV, DL, Ty, Offset, RISCVII::MO_LO);
-  SDValue MNHi = SDValue(DAG.getMachineNode(RISCV::LUI, DL, Ty, GAHi), 0);
-  SDValue MNLo =
-    SDValue(DAG.getMachineNode(RISCV::ADDI, DL, Ty, MNHi, GALo), 0);
-  return MNLo;
-}
-
-SDValue RISCVTargetLowering::lowerBlockAddress(SDValue Op,
-                                               SelectionDAG &DAG) const {
-  SDLoc DL(Op);
-  EVT Ty = Op.getValueType();
-  BlockAddressSDNode *N = cast<BlockAddressSDNode>(Op);
-  const BlockAddress *BA = N->getBlockAddress();
-  int64_t Offset = N->getOffset();
-
-  if (isPositionIndependent() || Subtarget.is64Bit())
-    report_fatal_error("Unable to lowerBlockAddress");
-
-  SDValue BAHi = DAG.getTargetBlockAddress(BA, Ty, Offset, RISCVII::MO_HI);
-  SDValue BALo = DAG.getTargetBlockAddress(BA, Ty, Offset, RISCVII::MO_LO);
-  SDValue MNHi = SDValue(DAG.getMachineNode(RISCV::LUI, DL, Ty, BAHi), 0);
-  SDValue MNLo =
-    SDValue(DAG.getMachineNode(RISCV::ADDI, DL, Ty, MNHi, BALo), 0);
-  return MNLo;
-}
-
-SDValue RISCVTargetLowering::lowerExternalSymbol(SDValue Op,
-                                                 SelectionDAG &DAG) const {
-  SDLoc DL(Op);
-  EVT Ty = Op.getValueType();
-  ExternalSymbolSDNode *N = cast<ExternalSymbolSDNode>(Op);
-  const char *Sym = N->getSymbol();
-
-  // TODO: should also handle gp-relative loads.
-
-  if (isPositionIndependent() || Subtarget.is64Bit())
-    report_fatal_error("Unable to lowerExternalSymbol");
-
-  SDValue GAHi = DAG.getTargetExternalSymbol(Sym, Ty, RISCVII::MO_HI);
-  SDValue GALo = DAG.getTargetExternalSymbol(Sym, Ty, RISCVII::MO_LO);
-  SDValue MNHi = SDValue(DAG.getMachineNode(RISCV::LUI, DL, Ty, GAHi), 0);
-  SDValue MNLo =
-    SDValue(DAG.getMachineNode(RISCV::ADDI, DL, Ty, MNHi, GALo), 0);
-  return MNLo;
-}
-
-SDValue RISCVTargetLowering::lowerSELECT(SDValue Op, SelectionDAG &DAG) const {
-  SDValue CondV = Op.getOperand(0);
-  SDValue TrueV = Op.getOperand(1);
-  SDValue FalseV = Op.getOperand(2);
-  SDLoc DL(Op);
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  // If the result type is XLenVT and CondV is the output of a SETCC node
-  // which also operated on XLenVT inputs, then merge the SETCC node into the
-  // lowered RISCVISD::SELECT_CC to take advantage of the integer
-  // compare+branch instructions. i.e.:
-  // (select (setcc lhs, rhs, cc), truev, falsev)
-  // -> (riscvisd::select_cc lhs, rhs, cc, truev, falsev)
-  if (Op.getSimpleValueType() == XLenVT && CondV.getOpcode() == ISD::SETCC &&
-      CondV.getOperand(0).getSimpleValueType() == XLenVT) {
-    SDValue LHS = CondV.getOperand(0);
-    SDValue RHS = CondV.getOperand(1);
-    auto CC = cast<CondCodeSDNode>(CondV.getOperand(2));
-    ISD::CondCode CCVal = CC->get();
-
-    normaliseSetCC(LHS, RHS, CCVal);
-
-    SDValue TargetCC = DAG.getConstant(CCVal, DL, XLenVT);
-    SDVTList VTs = DAG.getVTList(Op.getValueType(), MVT::Glue);
-    SDValue Ops[] = {LHS, RHS, TargetCC, TrueV, FalseV};
-    return DAG.getNode(RISCVISD::SELECT_CC, DL, VTs, Ops);
-  }
-
-  // Otherwise:
-  // (select condv, truev, falsev)
-  // -> (riscvisd::select_cc condv, zero, setne, truev, falsev)
-  SDValue Zero = DAG.getConstant(0, DL, XLenVT);
-  SDValue SetNE = DAG.getConstant(ISD::SETNE, DL, XLenVT);
-
-  SDVTList VTs = DAG.getVTList(Op.getValueType(), MVT::Glue);
-  SDValue Ops[] = {CondV, Zero, SetNE, TrueV, FalseV};
-
-  return DAG.getNode(RISCVISD::SELECT_CC, DL, VTs, Ops);
-}
-
-SDValue RISCVTargetLowering::lowerVASTART(SDValue Op, SelectionDAG &DAG) const {
-  MachineFunction &MF = DAG.getMachineFunction();
-  RISCVMachineFunctionInfo *FuncInfo = MF.getInfo<RISCVMachineFunctionInfo>();
-
-  SDLoc DL(Op);
-  SDValue FI = DAG.getFrameIndex(FuncInfo->getVarArgsFrameIndex(),
-                                 getPointerTy(MF.getDataLayout()));
-
-  // vastart just stores the address of the VarArgsFrameIndex slot into the
-  // memory location argument.
-  const Value *SV = cast<SrcValueSDNode>(Op.getOperand(2))->getValue();
-  return DAG.getStore(Op.getOperand(0), DL, FI, Op.getOperand(1),
-                      MachinePointerInfo(SV));
-}
-
-SDValue RISCVTargetLowering::LowerFRAMEADDR(SDValue Op,
-                                            SelectionDAG &DAG) const {
-  const RISCVRegisterInfo &RI = *Subtarget.getRegisterInfo();
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  MFI.setFrameAddressIsTaken(true);
-  unsigned FrameReg = RI.getFrameRegister(MF);
-  int XLenInBytes = Subtarget.getXLen() / 8;
-
-  EVT VT = Op.getValueType();
-  SDLoc DL(Op);
-  SDValue FrameAddr = DAG.getCopyFromReg(DAG.getEntryNode(), DL, FrameReg, VT);
-  unsigned Depth = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
-  while (Depth--) {
-    int Offset = -(XLenInBytes * 2);
-    SDValue Ptr = DAG.getNode(ISD::ADD, DL, VT, FrameAddr,
-                              DAG.getIntPtrConstant(Offset, DL));
-    FrameAddr =
-        DAG.getLoad(VT, DL, DAG.getEntryNode(), Ptr, MachinePointerInfo());
-  }
-  return FrameAddr;
-}
-
-SDValue RISCVTargetLowering::LowerRETURNADDR(SDValue Op,
-                                             SelectionDAG &DAG) const {
-  const RISCVRegisterInfo &RI = *Subtarget.getRegisterInfo();
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  MFI.setReturnAddressIsTaken(true);
-  MVT XLenVT = Subtarget.getXLenVT();
-  int XLenInBytes = Subtarget.getXLen() / 8;
-
-  if (verifyReturnAddressArgumentIsConstant(Op, DAG))
-    return SDValue();
-
-  EVT VT = Op.getValueType();
-  SDLoc DL(Op);
-  unsigned Depth = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
-  if (Depth) {
-    int Off = -XLenInBytes;
-    SDValue FrameAddr = LowerFRAMEADDR(Op, DAG);
-    SDValue Offset = DAG.getConstant(Off, DL, VT);
-    return DAG.getLoad(VT, DL, DAG.getEntryNode(),
-                       DAG.getNode(ISD::ADD, DL, VT, FrameAddr, Offset),
-                       MachinePointerInfo());
-  }
-
-  // Return the value of the return address register, marking it an implicit
-  // live-in.
-  unsigned Reg = MF.addLiveIn(RI.getRARegister(), getRegClassFor(XLenVT));
-  return DAG.getCopyFromReg(DAG.getEntryNode(), DL, Reg, XLenVT);
-}
-
-MachineBasicBlock *
-RISCVTargetLowering::EmitInstrWithCustomInserter(MachineInstr &MI,
-                                                 MachineBasicBlock *BB) const {
-  const TargetInstrInfo &TII = *BB->getParent()->getSubtarget().getInstrInfo();
-  DebugLoc DL = MI.getDebugLoc();
-
-  assert(MI.getOpcode() == RISCV::Select_GPR_Using_CC_GPR &&
-         "Unexpected instr type to insert");
-
-  // To "insert" a SELECT instruction, we actually have to insert the triangle
-  // control-flow pattern.  The incoming instruction knows the destination vreg
-  // to set, the condition code register to branch on, the true/false values to
-  // select between, and the condcode to use to select the appropriate branch.
-  //
-  // We produce the following control flow:
-  //     HeadMBB
-  //     |  \
-  //     |  IfFalseMBB
-  //     | /
-  //    TailMBB
-  const BasicBlock *LLVM_BB = BB->getBasicBlock();
-  MachineFunction::iterator I = ++BB->getIterator();
-
-  MachineBasicBlock *HeadMBB = BB;
-  MachineFunction *F = BB->getParent();
-  MachineBasicBlock *TailMBB = F->CreateMachineBasicBlock(LLVM_BB);
-  MachineBasicBlock *IfFalseMBB = F->CreateMachineBasicBlock(LLVM_BB);
-
-  F->insert(I, IfFalseMBB);
-  F->insert(I, TailMBB);
-  // Move all remaining instructions to TailMBB.
-  TailMBB->splice(TailMBB->begin(), HeadMBB,
-                  std::next(MachineBasicBlock::iterator(MI)), HeadMBB->end());
-  // Update machine-CFG edges by transferring all successors of the current
-  // block to the new block which will contain the Phi node for the select.
-  TailMBB->transferSuccessorsAndUpdatePHIs(HeadMBB);
-  // Set the successors for HeadMBB.
-  HeadMBB->addSuccessor(IfFalseMBB);
-  HeadMBB->addSuccessor(TailMBB);
-
-  // Insert appropriate branch.
-  unsigned LHS = MI.getOperand(1).getReg();
-  unsigned RHS = MI.getOperand(2).getReg();
-  auto CC = static_cast<ISD::CondCode>(MI.getOperand(3).getImm());
-  unsigned Opcode = getBranchOpcodeForIntCondCode(CC);
-
-  BuildMI(HeadMBB, DL, TII.get(Opcode))
-    .addReg(LHS)
-    .addReg(RHS)
-    .addMBB(TailMBB);
-
-  // IfFalseMBB just falls through to TailMBB.
-  IfFalseMBB->addSuccessor(TailMBB);
-
-  // %Result = phi [ %TrueValue, HeadMBB ], [ %FalseValue, IfFalseMBB ]
-  BuildMI(*TailMBB, TailMBB->begin(), DL, TII.get(RISCV::PHI),
-          MI.getOperand(0).getReg())
-      .addReg(MI.getOperand(4).getReg())
-      .addMBB(HeadMBB)
-      .addReg(MI.getOperand(5).getReg())
-      .addMBB(IfFalseMBB);
-
-  MI.eraseFromParent(); // The pseudo instruction is gone now.
-  return TailMBB;
-}
-
-// Calling Convention Implementation.
-// The expectations for frontend ABI lowering vary from target to target.
-// Ideally, an LLVM frontend would be able to avoid worrying about many ABI
-// details, but this is a longer term goal. For now, we simply try to keep the
-// role of the frontend as simple and well-defined as possible. The rules can
-// be summarised as:
-// * Never split up large scalar arguments. We handle them here.
-// * If a hardfloat calling convention is being used, and the struct may be
-// passed in a pair of registers (fp+fp, int+fp), and both registers are
-// available, then pass as two separate arguments. If either the GPRs or FPRs
-// are exhausted, then pass according to the rule below.
-// * If a struct could never be passed in registers or directly in a stack
-// slot (as it is larger than 2*XLEN and the floating point rules don't
-// apply), then pass it using a pointer with the byval attribute.
-// * If a struct is less than 2*XLEN, then coerce to either a two-element
-// word-sized array or a 2*XLEN scalar (depending on alignment).
-// * The frontend can determine whether a struct is returned by reference or
-// not based on its size and fields. If it will be returned by reference, the
-// frontend must modify the prototype so a pointer with the sret annotation is
-// passed as the first argument. This is not necessary for large scalar
-// returns.
-// * Struct return values and varargs should be coerced to structs containing
-// register-size fields in the same situations they would be for fixed
-// arguments.
-
-static const MCPhysReg ArgGPRs[] = {
-  RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13,
-  RISCV::X14, RISCV::X15, RISCV::X16, RISCV::X17
-};
-
-// Pass a 2*XLEN argument that has been split into two XLEN values through
-// registers or the stack as necessary.
-static bool CC_RISCVAssign2XLen(unsigned XLen, CCState &State, CCValAssign VA1,
-                                ISD::ArgFlagsTy ArgFlags1, unsigned ValNo2,
-                                MVT ValVT2, MVT LocVT2,
-                                ISD::ArgFlagsTy ArgFlags2) {
-  unsigned XLenInBytes = XLen / 8;
-  if (unsigned Reg = State.AllocateReg(ArgGPRs)) {
-    // At least one half can be passed via register.
-    State.addLoc(CCValAssign::getReg(VA1.getValNo(), VA1.getValVT(), Reg,
-                                     VA1.getLocVT(), CCValAssign::Full));
-  } else {
-    // Both halves must be passed on the stack, with proper alignment.
-    unsigned StackAlign = std::max(XLenInBytes, ArgFlags1.getOrigAlign());
-    State.addLoc(
-        CCValAssign::getMem(VA1.getValNo(), VA1.getValVT(),
-                            State.AllocateStack(XLenInBytes, StackAlign),
-                            VA1.getLocVT(), CCValAssign::Full));
-    State.addLoc(CCValAssign::getMem(
-        ValNo2, ValVT2, State.AllocateStack(XLenInBytes, XLenInBytes), LocVT2,
-        CCValAssign::Full));
-    return false;
-  }
-
-  if (unsigned Reg = State.AllocateReg(ArgGPRs)) {
-    // The second half can also be passed via register.
-    State.addLoc(
-        CCValAssign::getReg(ValNo2, ValVT2, Reg, LocVT2, CCValAssign::Full));
-  } else {
-    // The second half is passed via the stack, without additional alignment.
-    State.addLoc(CCValAssign::getMem(
-        ValNo2, ValVT2, State.AllocateStack(XLenInBytes, XLenInBytes), LocVT2,
-        CCValAssign::Full));
-  }
-
-  return false;
-}
-
-// Implements the RISC-V calling convention. Returns true upon failure.
-static bool CC_RISCV(const DataLayout &DL, unsigned ValNo, MVT ValVT, MVT LocVT,
-                     CCValAssign::LocInfo LocInfo, ISD::ArgFlagsTy ArgFlags,
-                     CCState &State, bool IsFixed, bool IsRet, Type *OrigTy) {
-  unsigned XLen = DL.getLargestLegalIntTypeSizeInBits();
-  assert(XLen == 32 || XLen == 64);
-  MVT XLenVT = XLen == 32 ? MVT::i32 : MVT::i64;
-  assert(ValVT == XLenVT && "Unexpected ValVT");
-  assert(LocVT == XLenVT && "Unexpected LocVT");
-
-  // Any return value split in to more than two values can't be returned
-  // directly.
-  if (IsRet && ValNo > 1)
-    return true;
-
-  // If this is a variadic argument, the RISC-V calling convention requires
-  // that it is assigned an 'even' or 'aligned' register if it has 8-byte
-  // alignment (RV32) or 16-byte alignment (RV64). An aligned register should
-  // be used regardless of whether the original argument was split during
-  // legalisation or not. The argument will not be passed by registers if the
-  // original type is larger than 2*XLEN, so the register alignment rule does
-  // not apply.
-  unsigned TwoXLenInBytes = (2 * XLen) / 8;
-  if (!IsFixed && ArgFlags.getOrigAlign() == TwoXLenInBytes &&
-      DL.getTypeAllocSize(OrigTy) == TwoXLenInBytes) {
-    unsigned RegIdx = State.getFirstUnallocated(ArgGPRs);
-    // Skip 'odd' register if necessary.
-    if (RegIdx != array_lengthof(ArgGPRs) && RegIdx % 2 == 1)
-      State.AllocateReg(ArgGPRs);
-  }
-
-  SmallVectorImpl<CCValAssign> &PendingLocs = State.getPendingLocs();
-  SmallVectorImpl<ISD::ArgFlagsTy> &PendingArgFlags =
-      State.getPendingArgFlags();
-
-  assert(PendingLocs.size() == PendingArgFlags.size() &&
-         "PendingLocs and PendingArgFlags out of sync");
-
-  // Split arguments might be passed indirectly, so keep track of the pending
-  // values.
-  if (ArgFlags.isSplit() || !PendingLocs.empty()) {
-    LocVT = XLenVT;
-    LocInfo = CCValAssign::Indirect;
-    PendingLocs.push_back(
-        CCValAssign::getPending(ValNo, ValVT, LocVT, LocInfo));
-    PendingArgFlags.push_back(ArgFlags);
-    if (!ArgFlags.isSplitEnd()) {
-      return false;
-    }
-  }
-
-  // If the split argument only had two elements, it should be passed directly
-  // in registers or on the stack.
-  if (ArgFlags.isSplitEnd() && PendingLocs.size() <= 2) {
-    assert(PendingLocs.size() == 2 && "Unexpected PendingLocs.size()");
-    // Apply the normal calling convention rules to the first half of the
-    // split argument.
-    CCValAssign VA = PendingLocs[0];
-    ISD::ArgFlagsTy AF = PendingArgFlags[0];
-    PendingLocs.clear();
-    PendingArgFlags.clear();
-    return CC_RISCVAssign2XLen(XLen, State, VA, AF, ValNo, ValVT, LocVT,
-                               ArgFlags);
-  }
-
-  // Allocate to a register if possible, or else a stack slot.
-  unsigned Reg = State.AllocateReg(ArgGPRs);
-  unsigned StackOffset = Reg ? 0 : State.AllocateStack(XLen / 8, XLen / 8);
-
-  // If we reach this point and PendingLocs is non-empty, we must be at the
-  // end of a split argument that must be passed indirectly.
-  if (!PendingLocs.empty()) {
-    assert(ArgFlags.isSplitEnd() && "Expected ArgFlags.isSplitEnd()");
-    assert(PendingLocs.size() > 2 && "Unexpected PendingLocs.size()");
-
-    for (auto &It : PendingLocs) {
-      if (Reg)
-        It.convertToReg(Reg);
-      else
-        It.convertToMem(StackOffset);
-      State.addLoc(It);
-    }
-    PendingLocs.clear();
-    PendingArgFlags.clear();
-    return false;
-  }
-
-  assert(LocVT == XLenVT && "Expected an XLenVT at this stage");
-
-  if (Reg) {
-    State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
-  } else {
-    State.addLoc(
-        CCValAssign::getMem(ValNo, ValVT, StackOffset, LocVT, LocInfo));
-  }
-  return false;
-}
-
-void RISCVTargetLowering::analyzeInputArgs(
-    MachineFunction &MF, CCState &CCInfo,
-    const SmallVectorImpl<ISD::InputArg> &Ins, bool IsRet) const {
-  unsigned NumArgs = Ins.size();
-  FunctionType *FType = MF.getFunction().getFunctionType();
-
-  for (unsigned i = 0; i != NumArgs; ++i) {
-    MVT ArgVT = Ins[i].VT;
-    ISD::ArgFlagsTy ArgFlags = Ins[i].Flags;
-
-    Type *ArgTy = nullptr;
-    if (IsRet)
-      ArgTy = FType->getReturnType();
-    else if (Ins[i].isOrigArg())
-      ArgTy = FType->getParamType(Ins[i].getOrigArgIndex());
-
-    if (CC_RISCV(MF.getDataLayout(), i, ArgVT, ArgVT, CCValAssign::Full,
-                 ArgFlags, CCInfo, /*IsRet=*/true, IsRet, ArgTy)) {
-      DEBUG(dbgs() << "InputArg #" << i << " has unhandled type "
-                   << EVT(ArgVT).getEVTString() << '\n');
-      llvm_unreachable(nullptr);
-    }
-  }
-}
-
-void RISCVTargetLowering::analyzeOutputArgs(
-    MachineFunction &MF, CCState &CCInfo,
-    const SmallVectorImpl<ISD::OutputArg> &Outs, bool IsRet,
-    CallLoweringInfo *CLI) const {
-  unsigned NumArgs = Outs.size();
-
-  for (unsigned i = 0; i != NumArgs; i++) {
-    MVT ArgVT = Outs[i].VT;
-    ISD::ArgFlagsTy ArgFlags = Outs[i].Flags;
-    Type *OrigTy = CLI ? CLI->getArgs()[Outs[i].OrigArgIndex].Ty : nullptr;
-
-    if (CC_RISCV(MF.getDataLayout(), i, ArgVT, ArgVT, CCValAssign::Full,
-                 ArgFlags, CCInfo, Outs[i].IsFixed, IsRet, OrigTy)) {
-      DEBUG(dbgs() << "OutputArg #" << i << " has unhandled type "
-                   << EVT(ArgVT).getEVTString() << "\n");
-      llvm_unreachable(nullptr);
-    }
-  }
-}
-
-// The caller is responsible for loading the full value if the argument is
-// passed with CCValAssign::Indirect.
-static SDValue unpackFromRegLoc(SelectionDAG &DAG, SDValue Chain,
-                                const CCValAssign &VA, const SDLoc &DL) {
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineRegisterInfo &RegInfo = MF.getRegInfo();
-  EVT LocVT = VA.getLocVT();
-  SDValue Val;
-
-  unsigned VReg = RegInfo.createVirtualRegister(&RISCV::GPRRegClass);
-  RegInfo.addLiveIn(VA.getLocReg(), VReg);
-  Val = DAG.getCopyFromReg(Chain, DL, VReg, LocVT);
-
-  switch (VA.getLocInfo()) {
-  default:
-    llvm_unreachable("Unexpected CCValAssign::LocInfo");
-  case CCValAssign::Full:
-  case CCValAssign::Indirect:
-    return Val;
-  }
-}
-
-// The caller is responsible for loading the full value if the argument is
-// passed with CCValAssign::Indirect.
-static SDValue unpackFromMemLoc(SelectionDAG &DAG, SDValue Chain,
-                                const CCValAssign &VA, const SDLoc &DL) {
-  MachineFunction &MF = DAG.getMachineFunction();
-  MachineFrameInfo &MFI = MF.getFrameInfo();
-  EVT LocVT = VA.getLocVT();
-  EVT ValVT = VA.getValVT();
-  EVT PtrVT = MVT::getIntegerVT(DAG.getDataLayout().getPointerSizeInBits(0));
-  int FI = MFI.CreateFixedObject(ValVT.getSizeInBits() / 8,
-                                 VA.getLocMemOffset(), /*Immutable=*/true);
-  SDValue FIN = DAG.getFrameIndex(FI, PtrVT);
-  SDValue Val;
-
-  ISD::LoadExtType ExtType;
-  switch (VA.getLocInfo()) {
-  default:
-    llvm_unreachable("Unexpected CCValAssign::LocInfo");
-  case CCValAssign::Full:
-  case CCValAssign::Indirect:
-    ExtType = ISD::NON_EXTLOAD;
-    break;
-  }
-  Val = DAG.getExtLoad(
-      ExtType, DL, LocVT, Chain, FIN,
-      MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI), ValVT);
-  return Val;
-}
-
-// Transform physical registers into virtual registers.
-SDValue RISCVTargetLowering::LowerFormalArguments(
-    SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
-    const SmallVectorImpl<ISD::InputArg> &Ins, const SDLoc &DL,
-    SelectionDAG &DAG, SmallVectorImpl<SDValue> &InVals) const {
-
-  switch (CallConv) {
-  default:
-    report_fatal_error("Unsupported calling convention");
-  case CallingConv::C:
-  case CallingConv::Fast:
-    break;
-  }
-
-  MachineFunction &MF = DAG.getMachineFunction();
-  EVT PtrVT = getPointerTy(DAG.getDataLayout());
-  MVT XLenVT = Subtarget.getXLenVT();
-  unsigned XLenInBytes = Subtarget.getXLen() / 8;
-  // Used with vargs to acumulate store chains.
-  std::vector<SDValue> OutChains;
-
-  // Assign locations to all of the incoming arguments.
-  SmallVector<CCValAssign, 16> ArgLocs;
-  CCState CCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
-  analyzeInputArgs(MF, CCInfo, Ins, /*IsRet=*/false);
-
-  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
-    CCValAssign &VA = ArgLocs[i];
-    assert(VA.getLocVT() == XLenVT && "Unhandled argument type");
-    SDValue ArgValue;
-    if (VA.isRegLoc())
-      ArgValue = unpackFromRegLoc(DAG, Chain, VA, DL);
-    else
-      ArgValue = unpackFromMemLoc(DAG, Chain, VA, DL);
-
-    if (VA.getLocInfo() == CCValAssign::Indirect) {
-      // If the original argument was split and passed by reference (e.g. i128
-      // on RV32), we need to load all parts of it here (using the same
-      // address).
-      InVals.push_back(DAG.getLoad(VA.getValVT(), DL, Chain, ArgValue,
-                                   MachinePointerInfo()));
-      unsigned ArgIndex = Ins[i].OrigArgIndex;
-      assert(Ins[i].PartOffset == 0);
-      while (i + 1 != e && Ins[i + 1].OrigArgIndex == ArgIndex) {
-        CCValAssign &PartVA = ArgLocs[i + 1];
-        unsigned PartOffset = Ins[i + 1].PartOffset;
-        SDValue Address = DAG.getNode(ISD::ADD, DL, PtrVT, ArgValue,
-                                      DAG.getIntPtrConstant(PartOffset, DL));
-        InVals.push_back(DAG.getLoad(PartVA.getValVT(), DL, Chain, Address,
-                                     MachinePointerInfo()));
-        ++i;
-      }
-      continue;
-    }
-    InVals.push_back(ArgValue);
-  }
-
-  if (IsVarArg) {
-    ArrayRef<MCPhysReg> ArgRegs = makeArrayRef(ArgGPRs);
-    unsigned Idx = CCInfo.getFirstUnallocated(ArgRegs);
-    const TargetRegisterClass *RC = &RISCV::GPRRegClass;
-    MachineFrameInfo &MFI = MF.getFrameInfo();
-    MachineRegisterInfo &RegInfo = MF.getRegInfo();
-    RISCVMachineFunctionInfo *RVFI = MF.getInfo<RISCVMachineFunctionInfo>();
-
-    // Offset of the first variable argument from stack pointer, and size of
-    // the vararg save area. For now, the varargs save area is either zero or
-    // large enough to hold a0-a7.
-    int VaArgOffset, VarArgsSaveSize;
-
-    // If all registers are allocated, then all varargs must be passed on the
-    // stack and we don't need to save any argregs.
-    if (ArgRegs.size() == Idx) {
-      VaArgOffset = CCInfo.getNextStackOffset();
-      VarArgsSaveSize = 0;
-    } else {
-      VarArgsSaveSize = XLenInBytes * (ArgRegs.size() - Idx);
-      VaArgOffset = -VarArgsSaveSize;
-    }
-
-    // Record the frame index of the first variable argument
-    // which is a value necessary to VASTART.
-    int FI = MFI.CreateFixedObject(XLenInBytes, VaArgOffset, true);
-    RVFI->setVarArgsFrameIndex(FI);
-
-    // If saving an odd number of registers then create an extra stack slot to
-    // ensure that the frame pointer is 2*XLEN-aligned, which in turn ensures
-    // offsets to even-numbered registered remain 2*XLEN-aligned.
-    if (Idx % 2) {
-      FI = MFI.CreateFixedObject(XLenInBytes, VaArgOffset - (int)XLenInBytes,
-                                 true);
-      VarArgsSaveSize += XLenInBytes;
-    }
-
-    // Copy the integer registers that may have been used for passing varargs
-    // to the vararg save area.
-    for (unsigned I = Idx; I < ArgRegs.size();
-         ++I, VaArgOffset += XLenInBytes) {
-      const unsigned Reg = RegInfo.createVirtualRegister(RC);
-      RegInfo.addLiveIn(ArgRegs[I], Reg);
-      SDValue ArgValue = DAG.getCopyFromReg(Chain, DL, Reg, XLenVT);
-      FI = MFI.CreateFixedObject(XLenInBytes, VaArgOffset, true);
-      SDValue PtrOff = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
-      SDValue Store = DAG.getStore(Chain, DL, ArgValue, PtrOff,
-                                   MachinePointerInfo::getFixedStack(MF, FI));
-      cast<StoreSDNode>(Store.getNode())
-          ->getMemOperand()
-          ->setValue((Value *)nullptr);
-      OutChains.push_back(Store);
-    }
-    RVFI->setVarArgsSaveSize(VarArgsSaveSize);
-  }
-
-  // All stores are grouped in one node to allow the matching between
-  // the size of Ins and InVals. This only happens for vararg functions.
-  if (!OutChains.empty()) {
-    OutChains.push_back(Chain);
-    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, OutChains);
-  }
-
-  return Chain;
-}
-
-// Lower a call to a callseq_start + CALL + callseq_end chain, and add input
-// and output parameter nodes.
-SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
-                                       SmallVectorImpl<SDValue> &InVals) const {
-  SelectionDAG &DAG = CLI.DAG;
-  SDLoc &DL = CLI.DL;
-  SmallVectorImpl<ISD::OutputArg> &Outs = CLI.Outs;
-  SmallVectorImpl<SDValue> &OutVals = CLI.OutVals;
-  SmallVectorImpl<ISD::InputArg> &Ins = CLI.Ins;
-  SDValue Chain = CLI.Chain;
-  SDValue Callee = CLI.Callee;
-  CLI.IsTailCall = false;
-  CallingConv::ID CallConv = CLI.CallConv;
-  bool IsVarArg = CLI.IsVarArg;
-  EVT PtrVT = getPointerTy(DAG.getDataLayout());
-  MVT XLenVT = Subtarget.getXLenVT();
-
-  MachineFunction &MF = DAG.getMachineFunction();
-
-  // Analyze the operands of the call, assigning locations to each operand.
-  SmallVector<CCValAssign, 16> ArgLocs;
-  CCState ArgCCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
-  analyzeOutputArgs(MF, ArgCCInfo, Outs, /*IsRet=*/false, &CLI);
-
-  // Get a count of how many bytes are to be pushed on the stack.
-  unsigned NumBytes = ArgCCInfo.getNextStackOffset();
-
-  // Create local copies for byval args
-  SmallVector<SDValue, 8> ByValArgs;
-  for (unsigned i = 0, e = Outs.size(); i != e; ++i) {
-    ISD::ArgFlagsTy Flags = Outs[i].Flags;
-    if (!Flags.isByVal())
-      continue;
-
-    SDValue Arg = OutVals[i];
-    unsigned Size = Flags.getByValSize();
-    unsigned Align = Flags.getByValAlign();
-
-    int FI = MF.getFrameInfo().CreateStackObject(Size, Align, /*isSS=*/false);
-    SDValue FIPtr = DAG.getFrameIndex(FI, getPointerTy(DAG.getDataLayout()));
-    SDValue SizeNode = DAG.getConstant(Size, DL, XLenVT);
-
-    Chain = DAG.getMemcpy(Chain, DL, FIPtr, Arg, SizeNode, Align,
-                          /*IsVolatile=*/false,
-                          /*AlwaysInline=*/false,
-                          /*isTailCall=*/false, MachinePointerInfo(),
-                          MachinePointerInfo());
-    ByValArgs.push_back(FIPtr);
-  }
-
-  Chain = DAG.getCALLSEQ_START(Chain, NumBytes, 0, CLI.DL);
-
-  // Copy argument values to their designated locations.
-  SmallVector<std::pair<unsigned, SDValue>, 8> RegsToPass;
-  SmallVector<SDValue, 8> MemOpChains;
-  SDValue StackPtr;
-  for (unsigned i = 0, j = 0, e = ArgLocs.size(); i != e; ++i) {
-    CCValAssign &VA = ArgLocs[i];
-    SDValue ArgValue = OutVals[i];
-    ISD::ArgFlagsTy Flags = Outs[i].Flags;
-
-    // Promote the value if needed.
-    // For now, only handle fully promoted and indirect arguments.
-    switch (VA.getLocInfo()) {
-    case CCValAssign::Full:
-      break;
-    case CCValAssign::Indirect: {
-      // Store the argument in a stack slot and pass its address.
-      SDValue SpillSlot = DAG.CreateStackTemporary(Outs[i].ArgVT);
-      int FI = cast<FrameIndexSDNode>(SpillSlot)->getIndex();
-      MemOpChains.push_back(
-          DAG.getStore(Chain, DL, ArgValue, SpillSlot,
-                       MachinePointerInfo::getFixedStack(MF, FI)));
-      // If the original argument was split (e.g. i128), we need
-      // to store all parts of it here (and pass just one address).
-      unsigned ArgIndex = Outs[i].OrigArgIndex;
-      assert(Outs[i].PartOffset == 0);
-      while (i + 1 != e && Outs[i + 1].OrigArgIndex == ArgIndex) {
-        SDValue PartValue = OutVals[i + 1];
-        unsigned PartOffset = Outs[i + 1].PartOffset;
-        SDValue Address = DAG.getNode(ISD::ADD, DL, PtrVT, SpillSlot,
-                                      DAG.getIntPtrConstant(PartOffset, DL));
-        MemOpChains.push_back(
-            DAG.getStore(Chain, DL, PartValue, Address,
-                         MachinePointerInfo::getFixedStack(MF, FI)));
-        ++i;
-      }
-      ArgValue = SpillSlot;
-      break;
-    }
-    default:
-      llvm_unreachable("Unknown loc info!");
-    }
-
-    // Use local copy if it is a byval arg.
-    if (Flags.isByVal())
-      ArgValue = ByValArgs[j++];
-
-    if (VA.isRegLoc()) {
-      // Queue up the argument copies and emit them at the end.
-      RegsToPass.push_back(std::make_pair(VA.getLocReg(), ArgValue));
-    } else {
-      assert(VA.isMemLoc() && "Argument not register or memory");
-
-      // Work out the address of the stack slot.
-      if (!StackPtr.getNode())
-        StackPtr = DAG.getCopyFromReg(Chain, DL, RISCV::X2, PtrVT);
-      SDValue Address =
-          DAG.getNode(ISD::ADD, DL, PtrVT, StackPtr,
-                      DAG.getIntPtrConstant(VA.getLocMemOffset(), DL));
-
-      // Emit the store.
-      MemOpChains.push_back(
-          DAG.getStore(Chain, DL, ArgValue, Address, MachinePointerInfo()));
-    }
-  }
-
-  // Join the stores, which are independent of one another.
-  if (!MemOpChains.empty())
-    Chain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, MemOpChains);
-
-  SDValue Glue;
-
-  // Build a sequence of copy-to-reg nodes, chained and glued together.
-  for (auto &Reg : RegsToPass) {
-    Chain = DAG.getCopyToReg(Chain, DL, Reg.first, Reg.second, Glue);
-    Glue = Chain.getValue(1);
-  }
-
-  if (isa<GlobalAddressSDNode>(Callee)) {
-    Callee = lowerGlobalAddress(Callee, DAG);
-  } else if (isa<ExternalSymbolSDNode>(Callee)) {
-    Callee = lowerExternalSymbol(Callee, DAG);
-  }
-
-  // The first call operand is the chain and the second is the target address.
-  SmallVector<SDValue, 8> Ops;
-  Ops.push_back(Chain);
-  Ops.push_back(Callee);
-
-  // Add argument registers to the end of the list so that they are
-  // known live into the call.
-  for (auto &Reg : RegsToPass)
-    Ops.push_back(DAG.getRegister(Reg.first, Reg.second.getValueType()));
-
-  // Add a register mask operand representing the call-preserved registers.
-  const TargetRegisterInfo *TRI = Subtarget.getRegisterInfo();
-  const uint32_t *Mask = TRI->getCallPreservedMask(MF, CallConv);
-  assert(Mask && "Missing call preserved mask for calling convention");
-  Ops.push_back(DAG.getRegisterMask(Mask));
-
-  // Glue the call to the argument copies, if any.
-  if (Glue.getNode())
-    Ops.push_back(Glue);
-
-  // Emit the call.
-  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);
-  Chain = DAG.getNode(RISCVISD::CALL, DL, NodeTys, Ops);
-  Glue = Chain.getValue(1);
-
-  // Mark the end of the call, which is glued to the call itself.
-  Chain = DAG.getCALLSEQ_END(Chain,
-                             DAG.getConstant(NumBytes, DL, PtrVT, true),
-                             DAG.getConstant(0, DL, PtrVT, true),
-                             Glue, DL);
-  Glue = Chain.getValue(1);
-
-  // Assign locations to each value returned by this call.
-  SmallVector<CCValAssign, 16> RVLocs;
-  CCState RetCCInfo(CallConv, IsVarArg, MF, RVLocs, *DAG.getContext());
-  analyzeInputArgs(MF, RetCCInfo, Ins, /*IsRet=*/true);
-
-  // Copy all of the result registers out of their specified physreg.
-  for (auto &VA : RVLocs) {
-    // Copy the value out, gluing the copy to the end of the call sequence.
-    SDValue RetValue = DAG.getCopyFromReg(Chain, DL, VA.getLocReg(),
-                                          VA.getLocVT(), Glue);
-    Chain = RetValue.getValue(1);
-    Glue = RetValue.getValue(2);
-
-    assert(VA.getLocInfo() == CCValAssign::Full && "Unknown loc info!");
-    InVals.push_back(RetValue);
-  }
-
-  return Chain;
-}
-
-bool RISCVTargetLowering::CanLowerReturn(
-    CallingConv::ID CallConv, MachineFunction &MF, bool IsVarArg,
-    const SmallVectorImpl<ISD::OutputArg> &Outs, LLVMContext &Context) const {
-  SmallVector<CCValAssign, 16> RVLocs;
-  CCState CCInfo(CallConv, IsVarArg, MF, RVLocs, Context);
-  for (unsigned i = 0, e = Outs.size(); i != e; ++i) {
-    MVT VT = Outs[i].VT;
-    ISD::ArgFlagsTy ArgFlags = Outs[i].Flags;
-    if (CC_RISCV(MF.getDataLayout(), i, VT, VT, CCValAssign::Full, ArgFlags,
-                 CCInfo, /*IsFixed=*/true, /*IsRet=*/true, nullptr))
-      return false;
-  }
-  return true;
-}
-
-SDValue
-RISCVTargetLowering::LowerReturn(SDValue Chain, CallingConv::ID CallConv,
-                                 bool IsVarArg,
-                                 const SmallVectorImpl<ISD::OutputArg> &Outs,
-                                 const SmallVectorImpl<SDValue> &OutVals,
-                                 const SDLoc &DL, SelectionDAG &DAG) const {
-  // Stores the assignment of the return value to a location.
-  SmallVector<CCValAssign, 16> RVLocs;
-
-  // Info about the registers and stack slot.
-  CCState CCInfo(CallConv, IsVarArg, DAG.getMachineFunction(), RVLocs,
-                 *DAG.getContext());
-
-  analyzeOutputArgs(DAG.getMachineFunction(), CCInfo, Outs, /*IsRet=*/true,
-                    nullptr);
-
-  SDValue Flag;
-  SmallVector<SDValue, 4> RetOps(1, Chain);
-
-  // Copy the result values into the output registers.
-  for (unsigned i = 0, e = RVLocs.size(); i < e; ++i) {
-    SDValue Val = OutVals[i];
-    CCValAssign &VA = RVLocs[i];
-    assert(VA.isRegLoc() && "Can only return in registers!");
-    assert(VA.getLocInfo() == CCValAssign::Full &&
-           "Unexpected CCValAssign::LocInfo");
-
-    Chain = DAG.getCopyToReg(Chain, DL, VA.getLocReg(), Val, Flag);
-
-    // Guarantee that all emitted copies are stuck together.
-    Flag = Chain.getValue(1);
-    RetOps.push_back(DAG.getRegister(VA.getLocReg(), VA.getLocVT()));
-  }
-
-  RetOps[0] = Chain; // Update chain.
-
-  // Add the flag if we have it.
-  if (Flag.getNode()) {
-    RetOps.push_back(Flag);
-  }
-
-  return DAG.getNode(RISCVISD::RET_FLAG, DL, MVT::Other, RetOps);
-}
-
-const char *RISCVTargetLowering::getTargetNodeName(unsigned Opcode) const {
-  switch ((RISCVISD::NodeType)Opcode) {
-  case RISCVISD::FIRST_NUMBER:
-    break;
-  case RISCVISD::RET_FLAG:
-    return "RISCVISD::RET_FLAG";
-  case RISCVISD::CALL:
-    return "RISCVISD::CALL";
-  case RISCVISD::SELECT_CC:
-    return "RISCVISD::SELECT_CC";
-  }
-  return nullptr;
-}
-
-std::pair<unsigned, const TargetRegisterClass *>
-RISCVTargetLowering::getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,
-                                                  StringRef Constraint,
-                                                  MVT VT) const {
-  // First, see if this is a constraint that directly corresponds to a
-  // RISCV register class.
-  if (Constraint.size() == 1) {
-    switch (Constraint[0]) {
-    case 'r':
-      return std::make_pair(0U, &RISCV::GPRRegClass);
-    default:
-      break;
-    }
-  }
-
-  return TargetLowering::getRegForInlineAsmConstraint(TRI, Constraint, VT);
-}
diff --git a/lib/Target/RISCV/RISCVISelLowering.h b/lib/Target/RISCV/RISCVISelLowering.h
deleted file mode 100644
index 6fbe2dd90f3..00000000000
--- a/lib/Target/RISCV/RISCVISelLowering.h
+++ /dev/null
@@ -1,94 +0,0 @@
-//===-- RISCVISelLowering.h - RISCV DAG Lowering Interface ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file defines the interfaces that RISCV uses to lower LLVM code into a
-// selection DAG.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVISELLOWERING_H
-#define LLVM_LIB_TARGET_RISCV_RISCVISELLOWERING_H
-
-#include "RISCV.h"
-#include "llvm/CodeGen/SelectionDAG.h"
-#include "llvm/CodeGen/TargetLowering.h"
-
-namespace llvm {
-class RISCVSubtarget;
-namespace RISCVISD {
-enum NodeType : unsigned {
-  FIRST_NUMBER = ISD::BUILTIN_OP_END,
-  RET_FLAG,
-  CALL,
-  SELECT_CC
-};
-}
-
-class RISCVTargetLowering : public TargetLowering {
-  const RISCVSubtarget &Subtarget;
-
-public:
-  explicit RISCVTargetLowering(const TargetMachine &TM,
-                               const RISCVSubtarget &STI);
-
-  // Provide custom lowering hooks for some operations.
-  SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const override;
-
-  // This method returns the name of a target specific DAG node.
-  const char *getTargetNodeName(unsigned Opcode) const override;
-
-  std::pair<unsigned, const TargetRegisterClass *>
-  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,
-                               StringRef Constraint, MVT VT) const override;
-
-  MachineBasicBlock *
-  EmitInstrWithCustomInserter(MachineInstr &MI,
-                              MachineBasicBlock *BB) const override;
-
-  EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,
-                         EVT VT) const override;
-
-private:
-  void analyzeInputArgs(MachineFunction &MF, CCState &CCInfo,
-                        const SmallVectorImpl<ISD::InputArg> &Ins,
-                        bool IsRet) const;
-  void analyzeOutputArgs(MachineFunction &MF, CCState &CCInfo,
-                         const SmallVectorImpl<ISD::OutputArg> &Outs,
-                         bool IsRet, CallLoweringInfo *CLI) const;
-  // Lower incoming arguments, copy physregs into vregs
-  SDValue LowerFormalArguments(SDValue Chain, CallingConv::ID CallConv,
-                               bool IsVarArg,
-                               const SmallVectorImpl<ISD::InputArg> &Ins,
-                               const SDLoc &DL, SelectionDAG &DAG,
-                               SmallVectorImpl<SDValue> &InVals) const override;
-  bool CanLowerReturn(CallingConv::ID CallConv, MachineFunction &MF,
-                      bool IsVarArg,
-                      const SmallVectorImpl<ISD::OutputArg> &Outs,
-                      LLVMContext &Context) const override;
-  SDValue LowerReturn(SDValue Chain, CallingConv::ID CallConv, bool IsVarArg,
-                      const SmallVectorImpl<ISD::OutputArg> &Outs,
-                      const SmallVectorImpl<SDValue> &OutVals, const SDLoc &DL,
-                      SelectionDAG &DAG) const override;
-  SDValue LowerCall(TargetLowering::CallLoweringInfo &CLI,
-                    SmallVectorImpl<SDValue> &InVals) const override;
-  bool shouldConvertConstantLoadToIntImm(const APInt &Imm,
-                                         Type *Ty) const override {
-    return true;
-  }
-  SDValue lowerGlobalAddress(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerBlockAddress(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerExternalSymbol(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerSELECT(SDValue Op, SelectionDAG &DAG) const;
-  SDValue lowerVASTART(SDValue Op, SelectionDAG &DAG) const;
-  SDValue LowerFRAMEADDR(SDValue Op, SelectionDAG &DAG) const;
-  SDValue LowerRETURNADDR(SDValue Op, SelectionDAG &DAG) const;
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCVInstrFormats.td b/lib/Target/RISCV/RISCVInstrFormats.td
deleted file mode 100644
index 7479ffbc953..00000000000
--- a/lib/Target/RISCV/RISCVInstrFormats.td
+++ /dev/null
@@ -1,285 +0,0 @@
-//===-- RISCVInstrFormats.td - RISCV Instruction Formats ---*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-//
-//  These instruction format definitions are structured to match the
-//  description in the RISC-V User-Level ISA specification as closely as
-//  possible. For instance, the specification describes instructions with the
-//  MSB (31st bit) on the left and the LSB (0th bit) on the right. This is
-//  reflected in the order of parameters to each instruction class.
-//
-//  One area of divergence is in the description of immediates. The
-//  specification describes immediate encoding in terms of bit-slicing
-//  operations on the logical value represented. The immediate argument to
-//  these instruction formats instead represents the bit sequence that will be
-//  inserted into the instruction. e.g. although JAL's immediate is logically
-//  a 21-bit value (where the LSB is always zero), we describe it as an imm20
-//  to match how it is encoded.
-//
-//===----------------------------------------------------------------------===//
-
-// Format specifies the encoding used by the instruction. This is used by
-// RISCVMCCodeEmitter to determine which form of fixup to use. These
-// definitions must be kept in-sync with RISCVBaseInfo.h.
-class InstFormat<bits<5> val> {
-  bits<5> Value = val;
-}
-def InstFormatPseudo : InstFormat<0>;
-def InstFormatR      : InstFormat<1>;
-def InstFormatR4     : InstFormat<2>;
-def InstFormatI      : InstFormat<3>;
-def InstFormatS      : InstFormat<4>;
-def InstFormatB      : InstFormat<5>;
-def InstFormatU      : InstFormat<6>;
-def InstFormatJ      : InstFormat<7>;
-def InstFormatCR     : InstFormat<8>;
-def InstFormatCI     : InstFormat<9>;
-def InstFormatCSS    : InstFormat<10>;
-def InstFormatCIW    : InstFormat<11>;
-def InstFormatCL     : InstFormat<12>;
-def InstFormatCS     : InstFormat<13>;
-def InstFormatCB     : InstFormat<14>;
-def InstFormatCJ     : InstFormat<15>;
-def InstFormatOther  : InstFormat<16>;
-
-// The following opcode names and match those given in Table 19.1 in the
-// RISC-V User-level ISA specification ("RISC-V base opcode map").
-class RISCVOpcode<bits<7> val> {
-  bits<7> Value = val;
-}
-def OPC_LOAD      : RISCVOpcode<0b0000011>;
-def OPC_LOAD_FP   : RISCVOpcode<0b0000111>;
-def OPC_MISC_MEM  : RISCVOpcode<0b0001111>;
-def OPC_OP_IMM    : RISCVOpcode<0b0010011>;
-def OPC_AUIPC     : RISCVOpcode<0b0010111>;
-def OPC_OP_IMM_32 : RISCVOpcode<0b0011011>;
-def OPC_STORE     : RISCVOpcode<0b0100011>;
-def OPC_STORE_FP  : RISCVOpcode<0b0100111>;
-def OPC_AMO       : RISCVOpcode<0b0101111>;
-def OPC_OP        : RISCVOpcode<0b0110011>;
-def OPC_LUI       : RISCVOpcode<0b0110111>;
-def OPC_OP_32     : RISCVOpcode<0b0111011>;
-def OPC_MADD      : RISCVOpcode<0b1000011>;
-def OPC_MSUB      : RISCVOpcode<0b1000111>;
-def OPC_NMSUB     : RISCVOpcode<0b1001011>;
-def OPC_NMADD     : RISCVOpcode<0b1001111>;
-def OPC_OP_FP     : RISCVOpcode<0b1010011>;
-def OPC_BRANCH    : RISCVOpcode<0b1100011>;
-def OPC_JALR      : RISCVOpcode<0b1100111>;
-def OPC_JAL       : RISCVOpcode<0b1101111>;
-def OPC_SYSTEM    : RISCVOpcode<0b1110011>;
-
-class RVInst<dag outs, dag ins, string opcodestr, string argstr,
-             list<dag> pattern, InstFormat format>
-    : Instruction {
-  field bits<32> Inst;
-  // SoftFail is a field the disassembler can use to provide a way for
-  // instructions to not match without killing the whole decode process. It is
-  // mainly used for ARM, but Tablegen expects this field to exist or it fails
-  // to build the decode table.
-  field bits<32> SoftFail = 0;
-  let Size = 4;
-
-  bits<7> Opcode = 0;
-
-  let Inst{6-0} = Opcode;
-
-  let Namespace = "RISCV";
-
-  dag OutOperandList = outs;
-  dag InOperandList = ins;
-  let AsmString = opcodestr # "\t" # argstr;
-  let Pattern = pattern;
-
-  let TSFlags{4-0} = format.Value;
-}
-
-// Pseudo instructions
-class Pseudo<dag outs, dag ins, list<dag> pattern>
-    : RVInst<outs, ins, "", "", pattern, InstFormatPseudo> {
-  let isPseudo = 1;
-  let isCodeGenOnly = 1;
-}
-
-// Instruction formats are listed in the order they appear in the RISC-V
-// instruction set manual (R, I, S, B, U, J) with sub-formats (e.g. RVInstR4,
-// RVInstRAtomic) sorted alphabetically.
-
-class RVInstR<bits<7> funct7, bits<3> funct3, RISCVOpcode opcode, dag outs,
-              dag ins, string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR> {
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31-25} = funct7;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstR4<bits<2> funct2, RISCVOpcode opcode, dag outs, dag ins,
-               string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR4> {
-  bits<5> rs3;
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<3> funct3;
-  bits<5> rd;
-
-  let Inst{31-27} = rs3;
-  let Inst{26-25} = funct2;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstRAtomic<bits<5> funct5, bit aq, bit rl, bits<3> funct3,
-                    RISCVOpcode opcode, dag outs, dag ins, string opcodestr,
-                    string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR> {
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31-27} = funct5;
-  let Inst{26} = aq;
-  let Inst{25} = rl;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstRFrm<bits<7> funct7, RISCVOpcode opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatR> {
-  bits<5> rs2;
-  bits<5> rs1;
-  bits<3> funct3;
-  bits<5> rd;
-
-  let Inst{31-25} = funct7;
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstI<bits<3> funct3, RISCVOpcode opcode, dag outs, dag ins,
-              string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatI> {
-  bits<12> imm12;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31-20} = imm12;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstIShift<bit arithshift, bits<3> funct3, RISCVOpcode opcode,
-                   dag outs, dag ins, string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatI> {
-  bits<6> shamt;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31} = 0;
-  let Inst{30} = arithshift;
-  let Inst{29-26} = 0;
-  let Inst{25-20} = shamt;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstIShiftW<bit arithshift, bits<3> funct3, RISCVOpcode opcode,
-                    dag outs, dag ins, string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatI> {
-  bits<5> shamt;
-  bits<5> rs1;
-  bits<5> rd;
-
-  let Inst{31} = 0;
-  let Inst{30} = arithshift;
-  let Inst{29-25} = 0;
-  let Inst{24-20} = shamt;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstS<bits<3> funct3, RISCVOpcode opcode, dag outs, dag ins,
-              string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatS> {
-  bits<12> imm12;
-  bits<5> rs2;
-  bits<5> rs1;
-
-  let Inst{31-25} = imm12{11-5};
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-7} = imm12{4-0};
-  let Opcode = opcode.Value;
-}
-
-class RVInstB<bits<3> funct3, RISCVOpcode opcode, dag outs, dag ins,
-              string opcodestr, string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatB> {
-  bits<12> imm12;
-  bits<5> rs2;
-  bits<5> rs1;
-
-  let Inst{31} = imm12{11};
-  let Inst{30-25} = imm12{9-4};
-  let Inst{24-20} = rs2;
-  let Inst{19-15} = rs1;
-  let Inst{14-12} = funct3;
-  let Inst{11-8} = imm12{3-0};
-  let Inst{7} = imm12{10};
-  let Opcode = opcode.Value;
-}
-
-class RVInstU<RISCVOpcode opcode, dag outs, dag ins, string opcodestr,
-              string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatU> {
-  bits<20> imm20;
-  bits<5> rd;
-
-  let Inst{31-12} = imm20;
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
-
-class RVInstJ<RISCVOpcode opcode, dag outs, dag ins, string opcodestr,
-              string argstr>
-    : RVInst<outs, ins, opcodestr, argstr, [], InstFormatJ> {
-  bits<20> imm20;
-  bits<5> rd;
-
-  let Inst{31} = imm20{19};
-  let Inst{30-21} = imm20{9-0};
-  let Inst{20} = imm20{10};
-  let Inst{19-12} = imm20{18-11};
-  let Inst{11-7} = rd;
-  let Opcode = opcode.Value;
-}
diff --git a/lib/Target/RISCV/RISCVInstrFormatsC.td b/lib/Target/RISCV/RISCVInstrFormatsC.td
deleted file mode 100644
index 6abcbd7cc8a..00000000000
--- a/lib/Target/RISCV/RISCVInstrFormatsC.td
+++ /dev/null
@@ -1,147 +0,0 @@
-//===-- RISCVInstrFormatsC.td - RISCV C Instruction Formats --*- tablegen -*-=//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-//  This file describes the RISC-V C extension instruction formats.
-//
-//===----------------------------------------------------------------------===//
-
-class RVInst16<dag outs, dag ins, string opcodestr, string argstr,
-               list<dag> pattern, InstFormat format>
-    : Instruction {
-  field bits<16> Inst;
-  // SoftFail is a field the disassembler can use to provide a way for
-  // instructions to not match without killing the whole decode process. It is
-  // mainly used for ARM, but Tablegen expects this field to exist or it fails
-  // to build the decode table.
-  field bits<16> SoftFail = 0;
-  let Size = 2;
-
-  bits<2> Opcode = 0;
-
-  let Namespace = "RISCV";
-
-  dag OutOperandList = outs;
-  dag InOperandList = ins;
-  let AsmString = opcodestr # "\t" # argstr;
-  let Pattern = pattern;
-
-  let TSFlags{4-0} = format.Value;
-}
-
-class RVInst16CR<bits<4> funct4, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCR> {
-  bits<5> rs1;
-  bits<5> rs2;
-
-  let Inst{15-12} = funct4;
-  let Inst{11-7} = rs1;
-  let Inst{6-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{6-2} must be set for each instruction.
-class RVInst16CI<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCI> {
-  bits<10> imm;
-  bits<5> rd;
-  bits<5> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{12} = imm{5};
-  let Inst{11-7} = rd;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{12-7} must be set for each instruction.
-class RVInst16CSS<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                  string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCSS> {
-  bits<10> imm;
-  bits<5> rs2;
-  bits<5> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{6-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CIW<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                  string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCIW> {
-  bits<10> imm;
-  bits<3> rd;
-
-  let Inst{15-13} = funct3;
-  let Inst{4-2} = rd;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{12-10} and Inst{6-5} must be set for each instruction.
-class RVInst16CL<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCL> {
-  bits<3> rd;
-  bits<3> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{9-7} = rs1;
-  let Inst{4-2} = rd;
-  let Inst{1-0} = opcode;
-}
-
-// The immediate value encoding differs for each instruction, so each subclass
-// is responsible for setting the appropriate bits in the Inst field.
-// The bits Inst{12-10} and Inst{6-5} must be set for each instruction.
-class RVInst16CS<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCS> {
-  bits<3> rs2;
-  bits<3> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{9-7} = rs1;
-  let Inst{4-2} = rs2;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CB<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCB> {
-  bits<9> imm;
-  bits<3> rs1;
-
-  let Inst{15-13} = funct3;
-  let Inst{9-7} = rs1;
-  let Inst{1-0} = opcode;
-}
-
-class RVInst16CJ<bits<3> funct3, bits<2> opcode, dag outs, dag ins,
-                 string opcodestr, string argstr>
-    : RVInst16<outs, ins, opcodestr, argstr, [], InstFormatCJ> {
-  bits<11> offset;
-
-  let Inst{15-13} = funct3;
-  let Inst{12} = offset{10};
-  let Inst{11} = offset{3};
-  let Inst{10-9} = offset{8-7};
-  let Inst{8} = offset{9};
-  let Inst{7} = offset{5};
-  let Inst{6} = offset{6};
-  let Inst{5-3} = offset{2-0};
-  let Inst{2} = offset{4};
-  let Inst{1-0} = opcode;
-}
diff --git a/lib/Target/RISCV/RISCVInstrInfo.cpp b/lib/Target/RISCV/RISCVInstrInfo.cpp
deleted file mode 100644
index 6a10329d4b8..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfo.cpp
+++ /dev/null
@@ -1,368 +0,0 @@
-//===-- RISCVInstrInfo.cpp - RISCV Instruction Information ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetInstrInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVInstrInfo.h"
-#include "RISCV.h"
-#include "RISCVSubtarget.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/SmallVector.h"
-#include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/MachineRegisterInfo.h"
-#include "llvm/CodeGen/RegisterScavenging.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/TargetRegistry.h"
-
-#define GET_INSTRINFO_CTOR_DTOR
-#include "RISCVGenInstrInfo.inc"
-
-using namespace llvm;
-
-RISCVInstrInfo::RISCVInstrInfo()
-    : RISCVGenInstrInfo(RISCV::ADJCALLSTACKDOWN, RISCV::ADJCALLSTACKUP) {}
-
-void RISCVInstrInfo::copyPhysReg(MachineBasicBlock &MBB,
-                                 MachineBasicBlock::iterator MBBI,
-                                 const DebugLoc &DL, unsigned DstReg,
-                                 unsigned SrcReg, bool KillSrc) const {
-  assert(RISCV::GPRRegClass.contains(DstReg, SrcReg) &&
-         "Impossible reg-to-reg copy");
-
-  BuildMI(MBB, MBBI, DL, get(RISCV::ADDI), DstReg)
-      .addReg(SrcReg, getKillRegState(KillSrc))
-      .addImm(0);
-}
-
-void RISCVInstrInfo::storeRegToStackSlot(MachineBasicBlock &MBB,
-                                         MachineBasicBlock::iterator I,
-                                         unsigned SrcReg, bool IsKill, int FI,
-                                         const TargetRegisterClass *RC,
-                                         const TargetRegisterInfo *TRI) const {
-  DebugLoc DL;
-  if (I != MBB.end())
-    DL = I->getDebugLoc();
-
-  if (RISCV::GPRRegClass.hasSubClassEq(RC))
-    BuildMI(MBB, I, DL, get(RISCV::SW))
-        .addReg(SrcReg, getKillRegState(IsKill))
-        .addFrameIndex(FI)
-        .addImm(0);
-  else
-    llvm_unreachable("Can't store this register to stack slot");
-}
-
-void RISCVInstrInfo::loadRegFromStackSlot(MachineBasicBlock &MBB,
-                                          MachineBasicBlock::iterator I,
-                                          unsigned DstReg, int FI,
-                                          const TargetRegisterClass *RC,
-                                          const TargetRegisterInfo *TRI) const {
-  DebugLoc DL;
-  if (I != MBB.end())
-    DL = I->getDebugLoc();
-
-  if (RISCV::GPRRegClass.hasSubClassEq(RC))
-    BuildMI(MBB, I, DL, get(RISCV::LW), DstReg).addFrameIndex(FI).addImm(0);
-  else
-    llvm_unreachable("Can't load this register from stack slot");
-}
-
-void RISCVInstrInfo::movImm32(MachineBasicBlock &MBB,
-                              MachineBasicBlock::iterator MBBI,
-                              const DebugLoc &DL, unsigned DstReg, uint64_t Val,
-                              MachineInstr::MIFlag Flag) const {
-  assert(isInt<32>(Val) && "Can only materialize 32-bit constants");
-
-  // TODO: If the value can be materialized using only one instruction, only
-  // insert a single instruction.
-
-  uint64_t Hi20 = ((Val + 0x800) >> 12) & 0xfffff;
-  uint64_t Lo12 = SignExtend64<12>(Val);
-  BuildMI(MBB, MBBI, DL, get(RISCV::LUI), DstReg)
-      .addImm(Hi20)
-      .setMIFlag(Flag);
-  BuildMI(MBB, MBBI, DL, get(RISCV::ADDI), DstReg)
-      .addReg(DstReg, RegState::Kill)
-      .addImm(Lo12)
-      .setMIFlag(Flag);
-}
-
-// The contents of values added to Cond are not examined outside of
-// RISCVInstrInfo, giving us flexibility in what to push to it. For RISCV, we
-// push BranchOpcode, Reg1, Reg2.
-static void parseCondBranch(MachineInstr &LastInst, MachineBasicBlock *&Target,
-                            SmallVectorImpl<MachineOperand> &Cond) {
-  // Block ends with fall-through condbranch.
-  assert(LastInst.getDesc().isConditionalBranch() &&
-         "Unknown conditional branch");
-  Target = LastInst.getOperand(2).getMBB();
-  Cond.push_back(MachineOperand::CreateImm(LastInst.getOpcode()));
-  Cond.push_back(LastInst.getOperand(0));
-  Cond.push_back(LastInst.getOperand(1));
-}
-
-static unsigned getOppositeBranchOpcode(int Opc) {
-  switch (Opc) {
-  default:
-    llvm_unreachable("Unrecognized conditional branch");
-  case RISCV::BEQ:
-    return RISCV::BNE;
-  case RISCV::BNE:
-    return RISCV::BEQ;
-  case RISCV::BLT:
-    return RISCV::BGE;
-  case RISCV::BGE:
-    return RISCV::BLT;
-  case RISCV::BLTU:
-    return RISCV::BGEU;
-  case RISCV::BGEU:
-    return RISCV::BLTU;
-  }
-}
-
-bool RISCVInstrInfo::analyzeBranch(MachineBasicBlock &MBB,
-                                   MachineBasicBlock *&TBB,
-                                   MachineBasicBlock *&FBB,
-                                   SmallVectorImpl<MachineOperand> &Cond,
-                                   bool AllowModify) const {
-  TBB = FBB = nullptr;
-  Cond.clear();
-
-  // If the block has no terminators, it just falls into the block after it.
-  MachineBasicBlock::iterator I = MBB.getLastNonDebugInstr();
-  if (I == MBB.end() || !isUnpredicatedTerminator(*I))
-    return false;
-
-  // Count the number of terminators and find the first unconditional or
-  // indirect branch.
-  MachineBasicBlock::iterator FirstUncondOrIndirectBr = MBB.end();
-  int NumTerminators = 0;
-  for (auto J = I.getReverse(); J != MBB.rend() && isUnpredicatedTerminator(*J);
-       J++) {
-    NumTerminators++;
-    if (J->getDesc().isUnconditionalBranch() ||
-        J->getDesc().isIndirectBranch()) {
-      FirstUncondOrIndirectBr = J.getReverse();
-    }
-  }
-
-  // If AllowModify is true, we can erase any terminators after
-  // FirstUncondOrIndirectBR.
-  if (AllowModify && FirstUncondOrIndirectBr != MBB.end()) {
-    while (std::next(FirstUncondOrIndirectBr) != MBB.end()) {
-      std::next(FirstUncondOrIndirectBr)->eraseFromParent();
-      NumTerminators--;
-    }
-    I = FirstUncondOrIndirectBr;
-  }
-
-  // We can't handle blocks that end in an indirect branch.
-  if (I->getDesc().isIndirectBranch())
-    return true;
-
-  // We can't handle blocks with more than 2 terminators.
-  if (NumTerminators > 2)
-    return true;
-
-  // Handle a single unconditional branch.
-  if (NumTerminators == 1 && I->getDesc().isUnconditionalBranch()) {
-    TBB = I->getOperand(0).getMBB();
-    return false;
-  }
-
-  // Handle a single conditional branch.
-  if (NumTerminators == 1 && I->getDesc().isConditionalBranch()) {
-    parseCondBranch(*I, TBB, Cond);
-    return false;
-  }
-
-  // Handle a conditional branch followed by an unconditional branch.
-  if (NumTerminators == 2 && std::prev(I)->getDesc().isConditionalBranch() &&
-      I->getDesc().isUnconditionalBranch()) {
-    parseCondBranch(*std::prev(I), TBB, Cond);
-    FBB = I->getOperand(0).getMBB();
-    return false;
-  }
-
-  // Otherwise, we can't handle this.
-  return true;
-}
-
-unsigned RISCVInstrInfo::removeBranch(MachineBasicBlock &MBB,
-                                      int *BytesRemoved) const {
-  if (BytesRemoved)
-    *BytesRemoved = 0;
-  MachineBasicBlock::iterator I = MBB.getLastNonDebugInstr();
-  if (I == MBB.end())
-    return 0;
-
-  if (!I->getDesc().isUnconditionalBranch() &&
-      !I->getDesc().isConditionalBranch())
-    return 0;
-
-  // Remove the branch.
-  I->eraseFromParent();
-  if (BytesRemoved)
-    *BytesRemoved += getInstSizeInBytes(*I);
-
-  I = MBB.end();
-
-  if (I == MBB.begin())
-    return 1;
-  --I;
-  if (!I->getDesc().isConditionalBranch())
-    return 1;
-
-  // Remove the branch.
-  I->eraseFromParent();
-  if (BytesRemoved)
-    *BytesRemoved += getInstSizeInBytes(*I);
-  return 2;
-}
-
-// Inserts a branch into the end of the specific MachineBasicBlock, returning
-// the number of instructions inserted.
-unsigned RISCVInstrInfo::insertBranch(
-    MachineBasicBlock &MBB, MachineBasicBlock *TBB, MachineBasicBlock *FBB,
-    ArrayRef<MachineOperand> Cond, const DebugLoc &DL, int *BytesAdded) const {
-  if (BytesAdded)
-    *BytesAdded = 0;
-
-  // Shouldn't be a fall through.
-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");
-  assert((Cond.size() == 3 || Cond.size() == 0) &&
-         "RISCV branch conditions have two components!");
-
-  // Unconditional branch.
-  if (Cond.empty()) {
-    MachineInstr &MI = *BuildMI(&MBB, DL, get(RISCV::PseudoBR)).addMBB(TBB);
-    if (BytesAdded)
-      *BytesAdded += getInstSizeInBytes(MI);
-    return 1;
-  }
-
-  // Either a one or two-way conditional branch.
-  unsigned Opc = Cond[0].getImm();
-  MachineInstr &CondMI =
-      *BuildMI(&MBB, DL, get(Opc)).add(Cond[1]).add(Cond[2]).addMBB(TBB);
-  if (BytesAdded)
-    *BytesAdded += getInstSizeInBytes(CondMI);
-
-  // One-way conditional branch.
-  if (!FBB)
-    return 1;
-
-  // Two-way conditional branch.
-  MachineInstr &MI = *BuildMI(&MBB, DL, get(RISCV::PseudoBR)).addMBB(FBB);
-  if (BytesAdded)
-    *BytesAdded += getInstSizeInBytes(MI);
-  return 2;
-}
-
-unsigned RISCVInstrInfo::insertIndirectBranch(MachineBasicBlock &MBB,
-                                              MachineBasicBlock &DestBB,
-                                              const DebugLoc &DL,
-                                              int64_t BrOffset,
-                                              RegScavenger *RS) const {
-  assert(RS && "RegScavenger required for long branching");
-  assert(MBB.empty() &&
-         "new block should be inserted for expanding unconditional branch");
-  assert(MBB.pred_size() == 1);
-
-  MachineFunction *MF = MBB.getParent();
-  MachineRegisterInfo &MRI = MF->getRegInfo();
-  const auto &TM = static_cast<const RISCVTargetMachine &>(MF->getTarget());
-  const auto &STI = MF->getSubtarget<RISCVSubtarget>();
-
-  if (TM.isPositionIndependent() || STI.is64Bit())
-    report_fatal_error("Unable to insert indirect branch");
-
-  if (!isInt<32>(BrOffset))
-    report_fatal_error(
-        "Branch offsets outside of the signed 32-bit range not supported");
-
-  // FIXME: A virtual register must be used initially, as the register
-  // scavenger won't work with empty blocks (SIInstrInfo::insertIndirectBranch
-  // uses the same workaround).
-  unsigned ScratchReg = MRI.createVirtualRegister(&RISCV::GPRRegClass);
-  auto II = MBB.end();
-
-  MachineInstr &LuiMI = *BuildMI(MBB, II, DL, get(RISCV::LUI), ScratchReg)
-                             .addMBB(&DestBB, RISCVII::MO_HI);
-  BuildMI(MBB, II, DL, get(RISCV::PseudoBRIND))
-      .addReg(ScratchReg, RegState::Kill)
-      .addMBB(&DestBB, RISCVII::MO_LO);
-
-  RS->enterBasicBlockEnd(MBB);
-  unsigned Scav = RS->scavengeRegisterBackwards(
-      RISCV::GPRRegClass, MachineBasicBlock::iterator(LuiMI), false, 0);
-  MRI.replaceRegWith(ScratchReg, Scav);
-  MRI.clearVirtRegs();
-  RS->setRegUsed(Scav);
-  return 8;
-}
-
-bool RISCVInstrInfo::reverseBranchCondition(
-    SmallVectorImpl<MachineOperand> &Cond) const {
-  assert((Cond.size() == 3) && "Invalid branch condition!");
-  Cond[0].setImm(getOppositeBranchOpcode(Cond[0].getImm()));
-  return false;
-}
-
-MachineBasicBlock *
-RISCVInstrInfo::getBranchDestBlock(const MachineInstr &MI) const {
-  assert(MI.getDesc().isBranch() && "Unexpected opcode!");
-  // The branch target is always the last operand.
-  int NumOp = MI.getNumExplicitOperands();
-  return MI.getOperand(NumOp - 1).getMBB();
-}
-
-bool RISCVInstrInfo::isBranchOffsetInRange(unsigned BranchOp,
-                                           int64_t BrOffset) const {
-  // Ideally we could determine the supported branch offset from the
-  // RISCVII::FormMask, but this can't be used for Pseudo instructions like
-  // PseudoBR.
-  switch (BranchOp) {
-  default:
-    llvm_unreachable("Unexpected opcode!");
-  case RISCV::BEQ:
-  case RISCV::BNE:
-  case RISCV::BLT:
-  case RISCV::BGE:
-  case RISCV::BLTU:
-  case RISCV::BGEU:
-    return isIntN(13, BrOffset);
-  case RISCV::JAL:
-  case RISCV::PseudoBR:
-    return isIntN(21, BrOffset);
-  }
-}
-
-unsigned RISCVInstrInfo::getInstSizeInBytes(const MachineInstr &MI) const {
-  unsigned Opcode = MI.getOpcode();
-
-  switch (Opcode) {
-  default: { return get(Opcode).getSize(); }
-  case TargetOpcode::EH_LABEL:
-  case TargetOpcode::IMPLICIT_DEF:
-  case TargetOpcode::KILL:
-  case TargetOpcode::DBG_VALUE:
-    return 0;
-  case TargetOpcode::INLINEASM: {
-    const MachineFunction &MF = *MI.getParent()->getParent();
-    const auto &TM = static_cast<const RISCVTargetMachine &>(MF.getTarget());
-    return getInlineAsmLength(MI.getOperand(0).getSymbolName(),
-                              *TM.getMCAsmInfo());
-  }
-  }
-}
diff --git a/lib/Target/RISCV/RISCVInstrInfo.h b/lib/Target/RISCV/RISCVInstrInfo.h
deleted file mode 100644
index 5761d9bedd7..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfo.h
+++ /dev/null
@@ -1,79 +0,0 @@
-//===-- RISCVInstrInfo.h - RISCV Instruction Information --------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetInstrInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVINSTRINFO_H
-#define LLVM_LIB_TARGET_RISCV_RISCVINSTRINFO_H
-
-#include "RISCVRegisterInfo.h"
-#include "llvm/CodeGen/TargetInstrInfo.h"
-
-#define GET_INSTRINFO_HEADER
-#include "RISCVGenInstrInfo.inc"
-
-namespace llvm {
-
-class RISCVInstrInfo : public RISCVGenInstrInfo {
-
-public:
-  RISCVInstrInfo();
-
-  void copyPhysReg(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                   const DebugLoc &DL, unsigned DstReg, unsigned SrcReg,
-                   bool KillSrc) const override;
-
-  void storeRegToStackSlot(MachineBasicBlock &MBB,
-                           MachineBasicBlock::iterator MBBI, unsigned SrcReg,
-                           bool IsKill, int FrameIndex,
-                           const TargetRegisterClass *RC,
-                           const TargetRegisterInfo *TRI) const override;
-
-  void loadRegFromStackSlot(MachineBasicBlock &MBB,
-                            MachineBasicBlock::iterator MBBI, unsigned DstReg,
-                            int FrameIndex, const TargetRegisterClass *RC,
-                            const TargetRegisterInfo *TRI) const override;
-
-  // Materializes the given int32 Val into DstReg.
-  void movImm32(MachineBasicBlock &MBB, MachineBasicBlock::iterator MBBI,
-                const DebugLoc &DL, unsigned DstReg, uint64_t Val,
-                MachineInstr::MIFlag Flag = MachineInstr::NoFlags) const;
-
-  unsigned getInstSizeInBytes(const MachineInstr &MI) const override;
-
-  bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,
-                     MachineBasicBlock *&FBB,
-                     SmallVectorImpl<MachineOperand> &Cond,
-                     bool AllowModify) const override;
-
-  unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,
-                        MachineBasicBlock *FBB, ArrayRef<MachineOperand> Cond,
-                        const DebugLoc &dl,
-                        int *BytesAdded = nullptr) const override;
-
-  unsigned insertIndirectBranch(MachineBasicBlock &MBB,
-                                MachineBasicBlock &NewDestBB,
-                                const DebugLoc &DL, int64_t BrOffset,
-                                RegScavenger *RS = nullptr) const override;
-
-  unsigned removeBranch(MachineBasicBlock &MBB,
-                        int *BytesRemoved = nullptr) const override;
-
-  bool
-  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const override;
-
-  MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const override;
-
-  bool isBranchOffsetInRange(unsigned BranchOpc,
-                             int64_t BrOffset) const override;
-};
-}
-#endif
diff --git a/lib/Target/RISCV/RISCVInstrInfo.td b/lib/Target/RISCV/RISCVInstrInfo.td
deleted file mode 100644
index 1aae2f39dbd..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfo.td
+++ /dev/null
@@ -1,652 +0,0 @@
-//===-- RISCVInstrInfo.td - Target Description for RISCV ---*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions in TableGen format.
-//
-//===----------------------------------------------------------------------===//
-
-include "RISCVInstrFormats.td"
-
-//===----------------------------------------------------------------------===//
-// RISC-V specific DAG Nodes.
-//===----------------------------------------------------------------------===//
-
-def SDT_RISCVCall         : SDTypeProfile<0, -1, [SDTCisVT<0, XLenVT>]>;
-def SDT_RISCVCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>,
-                                            SDTCisVT<1, i32>]>;
-def SDT_RISCVCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>,
-                                          SDTCisVT<1, i32>]>;
-def SDT_RISCVSelectCC     : SDTypeProfile<1, 5, [SDTCisSameAs<1, 2>,
-                                                 SDTCisSameAs<0, 4>,
-                                                 SDTCisSameAs<4, 5>]>;
-
-
-def Call         : SDNode<"RISCVISD::CALL", SDT_RISCVCall,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
-                           SDNPVariadic]>;
-def CallSeqStart : SDNode<"ISD::CALLSEQ_START", SDT_RISCVCallSeqStart,
-                          [SDNPHasChain, SDNPOutGlue]>;
-def CallSeqEnd   : SDNode<"ISD::CALLSEQ_END", SDT_RISCVCallSeqEnd,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
-def RetFlag      : SDNode<"RISCVISD::RET_FLAG", SDTNone,
-                          [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
-def SelectCC     : SDNode<"RISCVISD::SELECT_CC", SDT_RISCVSelectCC,
-                          [SDNPInGlue]>;
-
-//===----------------------------------------------------------------------===//
-// Operand and SDNode transformation definitions.
-//===----------------------------------------------------------------------===//
-
-class ImmAsmOperand<string prefix, int width, string suffix> : AsmOperandClass {
-  let Name = prefix # "Imm" # width # suffix;
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = !strconcat("Invalid", Name);
-}
-
-class SImmAsmOperand<int width, string suffix = "">
-    : ImmAsmOperand<"S", width, suffix> {
-}
-
-class UImmAsmOperand<int width, string suffix = "">
-    : ImmAsmOperand<"U", width, suffix> {
-}
-
-def FenceArg : AsmOperandClass {
-  let Name = "FenceArg";
-  let RenderMethod = "addFenceArgOperands";
-  let DiagnosticType = "InvalidFenceArg";
-}
-
-def fencearg : Operand<XLenVT> {
-  let ParserMatchClass = FenceArg;
-  let PrintMethod = "printFenceArg";
-  let DecoderMethod = "decodeUImmOperand<4>";
-}
-
-def UImmLog2XLenAsmOperand : AsmOperandClass {
-  let Name = "UImmLog2XLen";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = "InvalidUImmLog2XLen";
-}
-
-def uimmlog2xlen : Operand<XLenVT>, ImmLeaf<XLenVT, [{
-  if (Subtarget->is64Bit())
-    return isUInt<6>(Imm);
-  return isUInt<5>(Imm);
-}]> {
-  let ParserMatchClass = UImmLog2XLenAsmOperand;
-  // TODO: should ensure invalid shamt is rejected when decoding.
-  let DecoderMethod = "decodeUImmOperand<6>";
-}
-
-def uimm5 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<5>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<5>;
-  let DecoderMethod = "decodeUImmOperand<5>";
-}
-
-def simm12 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<12>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<12>;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<12>";
-}
-
-def uimm12 : Operand<XLenVT> {
-  let ParserMatchClass = UImmAsmOperand<12>;
-  let DecoderMethod = "decodeUImmOperand<12>";
-}
-
-// A 13-bit signed immediate where the least significant bit is zero.
-def simm13_lsb0 : Operand<OtherVT> {
-  let ParserMatchClass = SImmAsmOperand<13, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<13>";
-}
-
-def uimm20 : Operand<XLenVT> {
-  let ParserMatchClass = UImmAsmOperand<20>;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<20>";
-}
-
-// A 21-bit signed immediate where the least significant bit is zero.
-def simm21_lsb0 : Operand<OtherVT> {
-  let ParserMatchClass = SImmAsmOperand<21, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<21>";
-}
-
-// A parameterized register class alternative to i32imm/i64imm from Target.td.
-def ixlenimm : Operand<XLenVT>;
-
-// Standalone (codegen-only) immleaf patterns.
-def simm32 : ImmLeaf<XLenVT, [{return isInt<32>(Imm);}]>;
-
-// Addressing modes.
-// Necessary because a frameindex can't be matched directly in a pattern.
-def AddrFI : ComplexPattern<iPTR, 1, "SelectAddrFI", [frameindex], []>;
-
-// Extract least significant 12 bits from an immediate value and sign extend
-// them.
-def LO12Sext : SDNodeXForm<imm, [{
-  return CurDAG->getTargetConstant(SignExtend64<12>(N->getZExtValue()),
-                                   SDLoc(N), N->getValueType(0));
-}]>;
-
-// Extract the most significant 20 bits from an immediate value. Add 1 if bit
-// 11 is 1, to compensate for the low 12 bits in the matching immediate addi
-// or ld/st being negative.
-def HI20 : SDNodeXForm<imm, [{
-  return CurDAG->getTargetConstant(((N->getZExtValue()+0x800) >> 12) & 0xfffff,
-                                   SDLoc(N), N->getValueType(0));
-}]>;
-
-//===----------------------------------------------------------------------===//
-// Instruction Class Templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class BranchCC_rri<bits<3> funct3, string opcodestr>
-    : RVInstB<funct3, OPC_BRANCH, (outs),
-              (ins GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12),
-              opcodestr, "$rs1, $rs2, $imm12"> {
-  let isBranch = 1;
-  let isTerminator = 1;
-}
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class Load_ri<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_LOAD, (outs GPR:$rd), (ins GPR:$rs1, simm12:$imm12),
-              opcodestr, "$rd, ${imm12}(${rs1})">;
-
-// Operands for stores are in the order srcreg, base, offset rather than
-// reflecting the order these fields are specified in the instruction
-// encoding.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-class Store_rri<bits<3> funct3, string opcodestr>
-    : RVInstS<funct3, OPC_STORE, (outs),
-              (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),
-              opcodestr, "$rs2, ${imm12}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ALU_ri<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_OP_IMM, (outs GPR:$rd), (ins GPR:$rs1, simm12:$imm12),
-              opcodestr, "$rd, $rs1, $imm12">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class Shift_ri<bit arithshift, bits<3> funct3, string opcodestr>
-    : RVInstIShift<arithshift, funct3, OPC_OP_IMM, (outs GPR:$rd),
-                   (ins GPR:$rs1, uimmlog2xlen:$shamt), opcodestr,
-                   "$rd, $rs1, $shamt">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ALU_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
-              opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-class CSR_ir<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd), (ins uimm12:$imm12, GPR:$rs1),
-              opcodestr, "$rd, $imm12, $rs1">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-class CSR_ii<bits<3> funct3, string opcodestr>
-    : RVInstI<funct3, OPC_SYSTEM, (outs GPR:$rd),
-              (ins uimm12:$imm12, uimm5:$rs1),
-              opcodestr, "$rd, $imm12, $rs1">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ShiftW_ri<bit arithshift, bits<3> funct3, string opcodestr>
-    : RVInstIShiftW<arithshift, funct3, OPC_OP_IMM_32, (outs GPR:$rd),
-                    (ins GPR:$rs1, uimm5:$shamt), opcodestr,
-                    "$rd, $rs1, $shamt">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class ALUW_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_32, (outs GPR:$rd),
-              (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-class Priv<string opcodestr, bits<7> funct7>
-    : RVInstR<funct7, 0b000, OPC_SYSTEM, (outs), (ins GPR:$rs1, GPR:$rs2),
-              opcodestr, "">;
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in {
-def LUI : RVInstU<OPC_LUI, (outs GPR:$rd), (ins uimm20:$imm20),
-                  "lui", "$rd, $imm20">;
-
-def AUIPC : RVInstU<OPC_AUIPC, (outs GPR:$rd), (ins uimm20:$imm20),
-                    "auipc", "$rd, $imm20">;
-
-let isCall = 1 in
-def JAL : RVInstJ<OPC_JAL, (outs GPR:$rd), (ins simm21_lsb0:$imm20),
-                  "jal", "$rd, $imm20">;
-
-let isCall = 1 in
-def JALR : RVInstI<0b000, OPC_JALR, (outs GPR:$rd),
-                   (ins GPR:$rs1, simm12:$imm12),
-                   "jalr", "$rd, $rs1, $imm12">;
-} // hasSideEffects = 0, mayLoad = 0, mayStore = 0
-
-def BEQ  : BranchCC_rri<0b000, "beq">;
-def BNE  : BranchCC_rri<0b001, "bne">;
-def BLT  : BranchCC_rri<0b100, "blt">;
-def BGE  : BranchCC_rri<0b101, "bge">;
-def BLTU : BranchCC_rri<0b110, "bltu">;
-def BGEU : BranchCC_rri<0b111, "bgeu">;
-
-def LB  : Load_ri<0b000, "lb">;
-def LH  : Load_ri<0b001, "lh">;
-def LW  : Load_ri<0b010, "lw">;
-def LBU : Load_ri<0b100, "lbu">;
-def LHU : Load_ri<0b101, "lhu">;
-
-def SB : Store_rri<0b000, "sb">;
-def SH : Store_rri<0b001, "sh">;
-def SW : Store_rri<0b010, "sw">;
-
-def ADDI  : ALU_ri<0b000, "addi">;
-def SLTI  : ALU_ri<0b010, "slti">;
-def SLTIU : ALU_ri<0b011, "sltiu">;
-def XORI  : ALU_ri<0b100, "xori">;
-def ORI   : ALU_ri<0b110, "ori">;
-def ANDI  : ALU_ri<0b111, "andi">;
-
-def SLLI : Shift_ri<0, 0b001, "slli">;
-def SRLI : Shift_ri<0, 0b101, "srli">;
-def SRAI : Shift_ri<1, 0b101, "srai">;
-
-def ADD  : ALU_rr<0b0000000, 0b000, "add">;
-def SUB  : ALU_rr<0b0100000, 0b000, "sub">;
-def SLL  : ALU_rr<0b0000000, 0b001, "sll">;
-def SLT  : ALU_rr<0b0000000, 0b010, "slt">;
-def SLTU : ALU_rr<0b0000000, 0b011, "sltu">;
-def XOR  : ALU_rr<0b0000000, 0b100, "xor">;
-def SRL  : ALU_rr<0b0000000, 0b101, "srl">;
-def SRA  : ALU_rr<0b0100000, 0b101, "sra">;
-def OR   : ALU_rr<0b0000000, 0b110, "or">;
-def AND  : ALU_rr<0b0000000, 0b111, "and">;
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
-def FENCE : RVInstI<0b000, OPC_MISC_MEM, (outs),
-                    (ins fencearg:$pred, fencearg:$succ),
-                    "fence", "$pred, $succ"> {
-  bits<4> pred;
-  bits<4> succ;
-
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = {0b0000,pred,succ};
-}
-
-def FENCE_I : RVInstI<0b001, OPC_MISC_MEM, (outs), (ins), "fence.i", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 0;
-}
-
-def ECALL : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ecall", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 0;
-}
-
-def EBREAK : RVInstI<0b000, OPC_SYSTEM, (outs), (ins), "ebreak", ""> {
-  let rs1 = 0;
-  let rd = 0;
-  let imm12 = 1;
-}
-} // hasSideEffects = 1, mayLoad = 0, mayStore = 0
-
-def CSRRW : CSR_ir<0b001, "csrrw">;
-def CSRRS : CSR_ir<0b010, "csrrs">;
-def CSRRC : CSR_ir<0b011, "csrrc">;
-
-def CSRRWI : CSR_ii<0b101, "csrrwi">;
-def CSRRSI : CSR_ii<0b110, "csrrsi">;
-def CSRRCI : CSR_ii<0b111, "csrrci">;
-
-/// RV64I instructions
-
-let Predicates = [IsRV64] in {
-def LWU   : Load_ri<0b110, "lwu">;
-def LD    : Load_ri<0b011, "ld">;
-def SD    : Store_rri<0b011, "sd">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def ADDIW : RVInstI<0b000, OPC_OP_IMM_32, (outs GPR:$rd),
-                    (ins GPR:$rs1, simm12:$imm12),
-                    "addiw", "$rd, $rs1, $imm12">;
-
-def SLLIW : ShiftW_ri<0, 0b001, "slliw">;
-def SRLIW : ShiftW_ri<0, 0b101, "srliw">;
-def SRAIW : ShiftW_ri<1, 0b101, "sraiw">;
-
-def ADDW  : ALUW_rr<0b0000000, 0b000, "addw">;
-def SUBW  : ALUW_rr<0b0100000, 0b000, "subw">;
-def SLLW  : ALUW_rr<0b0000000, 0b001, "sllw">;
-def SRLW  : ALUW_rr<0b0000000, 0b101, "srlw">;
-def SRAW  : ALUW_rr<0b0100000, 0b101, "sraw">;
-} // Predicates = [IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Privileged instructions
-//===----------------------------------------------------------------------===//
-
-let isBarrier = 1, isReturn = 1, isTerminator = 1 in {
-def URET : Priv<"uret", 0b0000000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00010;
-}
-
-def SRET : Priv<"sret", 0b0001000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00010;
-}
-
-def MRET : Priv<"mret", 0b0011000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00010;
-}
-} // isBarrier = 1, isReturn = 1, isTerminator = 1
-
-def WFI : Priv<"wfi", 0b0001000> {
-  let rd = 0;
-  let rs1 = 0;
-  let rs2 = 0b00101;
-}
-
-let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in
-def SFENCE_VMA : RVInstR<0b0001001, 0b000, OPC_SYSTEM, (outs),
-                         (ins GPR:$rs1, GPR:$rs2),
-                         "sfence.vma", "$rs1, $rs2"> {
-  let rd = 0;
-}
-
-//===----------------------------------------------------------------------===//
-// Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-//===----------------------------------------------------------------------===//
-
-// TODO la
-// TODO lb lh lw
-// TODO RV64I: ld
-// TODO sb sh sw
-// TODO RV64I: sd
-
-def : InstAlias<"nop",           (ADDI      X0,      X0,       0)>;
-// TODO li
-def : InstAlias<"mv $rd, $rs",   (ADDI GPR:$rd, GPR:$rs,       0)>;
-def : InstAlias<"not $rd, $rs",  (XORI GPR:$rd, GPR:$rs,      -1)>;
-def : InstAlias<"neg $rd, $rs",  (SUB  GPR:$rd,      X0, GPR:$rs)>;
-
-let Predicates = [IsRV64] in {
-def : InstAlias<"negw $rd, $rs",   (SUBW  GPR:$rd,      X0, GPR:$rs)>;
-def : InstAlias<"sext.w $rd, $rs", (ADDIW GPR:$rd, GPR:$rs,       0)>;
-} // Predicates = [IsRV64]
-
-def : InstAlias<"seqz $rd, $rs", (SLTIU GPR:$rd, GPR:$rs,       1)>;
-def : InstAlias<"snez $rd, $rs", (SLTU  GPR:$rd,      X0, GPR:$rs)>;
-def : InstAlias<"sltz $rd, $rs", (SLT   GPR:$rd, GPR:$rs,      X0)>;
-def : InstAlias<"sgtz $rd, $rs", (SLT   GPR:$rd,      X0, GPR:$rs)>;
-
-def : InstAlias<"beqz $rs, $offset",
-                (BEQ GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"bnez $rs, $offset",
-                (BNE GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"blez $rs, $offset",
-                (BGE      X0, GPR:$rs, simm13_lsb0:$offset)>;
-def : InstAlias<"bgez $rs, $offset",
-                (BGE GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"bltz $rs, $offset",
-                (BLT GPR:$rs,      X0, simm13_lsb0:$offset)>;
-def : InstAlias<"bgtz $rs, $offset",
-                (BLT      X0, GPR:$rs, simm13_lsb0:$offset)>;
-
-// Always output the canonical mnemonic for the pseudo branch instructions.
-// The GNU tools emit the canonical mnemonic for the branch pseudo instructions
-// as well (e.g. "bgt" will be recognised by the assembler but never printed by
-// objdump). Match this behaviour by setting a zero weight.
-def : InstAlias<"bgt $rs, $rt, $offset",
-                (BLT  GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-def : InstAlias<"ble $rs, $rt, $offset",
-                (BGE  GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-def : InstAlias<"bgtu $rs, $rt, $offset",
-                (BLTU GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-def : InstAlias<"bleu $rs, $rt, $offset",
-                (BGEU GPR:$rt, GPR:$rs, simm13_lsb0:$offset), 0>;
-
-// "ret" has more weight since "ret" and "jr" alias the same "jalr" instruction.
-def : InstAlias<"j $offset",   (JAL  X0, simm21_lsb0:$offset)>;
-def : InstAlias<"jal $offset", (JAL  X1, simm21_lsb0:$offset)>;
-def : InstAlias<"jr $rs",      (JALR X0, GPR:$rs, 0)>;
-def : InstAlias<"jalr $rs",    (JALR X1, GPR:$rs, 0)>;
-def : InstAlias<"ret",         (JALR X0,      X1, 0), 2>;
-// TODO call
-// TODO tail
-
-def : InstAlias<"fence", (FENCE 0xF, 0xF)>; // 0xF == iorw
-
-// CSR Addresses: 0xC00 == cycle,  0xC01 == time,  0xC02 == instret
-//                0xC80 == cycleh, 0xC81 == timeh, 0xC82 == instreth
-def : InstAlias<"rdinstret $rd", (CSRRS GPR:$rd, 0xC02, X0)>;
-def : InstAlias<"rdcycle $rd",   (CSRRS GPR:$rd, 0xC00, X0)>;
-def : InstAlias<"rdtime $rd",    (CSRRS GPR:$rd, 0xC01, X0)>;
-
-let Predicates = [IsRV32] in {
-def : InstAlias<"rdinstreth $rd", (CSRRS GPR:$rd, 0xC82, X0)>;
-def : InstAlias<"rdcycleh $rd",   (CSRRS GPR:$rd, 0xC80, X0)>;
-def : InstAlias<"rdtimeh $rd",    (CSRRS GPR:$rd, 0xC81, X0)>;
-} // Predicates = [IsRV32]
-
-def : InstAlias<"csrr $rd, $csr", (CSRRS GPR:$rd, uimm12:$csr,      X0)>;
-def : InstAlias<"csrw $csr, $rs", (CSRRW      X0, uimm12:$csr, GPR:$rs)>;
-def : InstAlias<"csrs $csr, $rs", (CSRRS      X0, uimm12:$csr, GPR:$rs)>;
-def : InstAlias<"csrc $csr, $rs", (CSRRC      X0, uimm12:$csr, GPR:$rs)>;
-
-def : InstAlias<"csrwi $csr, $imm", (CSRRWI X0, uimm12:$csr, uimm5:$imm)>;
-def : InstAlias<"csrsi $csr, $imm", (CSRRSI X0, uimm12:$csr, uimm5:$imm)>;
-def : InstAlias<"csrci $csr, $imm", (CSRRCI X0, uimm12:$csr, uimm5:$imm)>;
-
-def : InstAlias<"sfence.vma",     (SFENCE_VMA      X0, X0)>;
-def : InstAlias<"sfence.vma $rs", (SFENCE_VMA GPR:$rs, X0)>;
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//
-// Naming convention: For 'generic' pattern classes, we use the naming
-// convention PatTy1Ty2. For pattern classes which offer a more complex
-// expension, prefix the class name, e.g. BccPat.
-//===----------------------------------------------------------------------===//
-
-/// Generic pattern classes
-
-class PatGprGpr<SDPatternOperator OpNode, RVInstR Inst>
-    : Pat<(OpNode GPR:$rs1, GPR:$rs2), (Inst GPR:$rs1, GPR:$rs2)>;
-class PatGprSimm12<SDPatternOperator OpNode, RVInstI Inst>
-    : Pat<(OpNode GPR:$rs1, simm12:$imm12), (Inst GPR:$rs1, simm12:$imm12)>;
-class PatGprUimmLog2XLen<SDPatternOperator OpNode, RVInstIShift Inst>
-    : Pat<(OpNode GPR:$rs1, uimmlog2xlen:$shamt),
-          (Inst GPR:$rs1, uimmlog2xlen:$shamt)>;
-
-/// Predicates
-
-def IsOrAdd: PatFrag<(ops node:$A, node:$B), (or node:$A, node:$B), [{
-  return isOrEquivalentToAdd(N);
-}]>;
-
-/// Immediates
-
-def : Pat<(simm12:$imm), (ADDI X0, simm12:$imm)>;
-// TODO: Add a pattern for immediates with all zeroes in the lower 12 bits.
-def : Pat<(simm32:$imm), (ADDI (LUI (HI20 imm:$imm)), (LO12Sext imm:$imm))>;
-
-/// Simple arithmetic operations
-
-def : PatGprGpr<add, ADD>;
-def : PatGprSimm12<add, ADDI>;
-def : PatGprGpr<sub, SUB>;
-def : PatGprGpr<or, OR>;
-def : PatGprSimm12<or, ORI>;
-def : PatGprGpr<and, AND>;
-def : PatGprSimm12<and, ANDI>;
-def : PatGprGpr<xor, XOR>;
-def : PatGprSimm12<xor, XORI>;
-def : PatGprGpr<shl, SLL>;
-def : PatGprUimmLog2XLen<shl, SLLI>;
-def : PatGprGpr<srl, SRL>;
-def : PatGprUimmLog2XLen<srl, SRLI>;
-def : PatGprGpr<sra, SRA>;
-def : PatGprUimmLog2XLen<sra, SRAI>;
-
-/// FrameIndex calculations
-
-def : Pat<(add (i32 AddrFI:$Rs), simm12:$imm12),
-          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;
-def : Pat<(IsOrAdd (i32 AddrFI:$Rs), simm12:$imm12),
-          (ADDI (i32 AddrFI:$Rs), simm12:$imm12)>;
-
-/// Setcc
-
-def : PatGprGpr<setlt, SLT>;
-def : PatGprSimm12<setlt, SLTI>;
-def : PatGprGpr<setult, SLTU>;
-def : PatGprSimm12<setult, SLTIU>;
-
-// Define pattern expansions for setcc operations that aren't directly
-// handled by a RISC-V instruction.
-def : Pat<(seteq GPR:$rs1, GPR:$rs2), (SLTIU (XOR GPR:$rs1, GPR:$rs2), 1)>;
-def : Pat<(setne GPR:$rs1, GPR:$rs2), (SLTU X0, (XOR GPR:$rs1, GPR:$rs2))>;
-def : Pat<(setugt GPR:$rs1, GPR:$rs2), (SLTU GPR:$rs2, GPR:$rs1)>;
-def : Pat<(setuge GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs1, GPR:$rs2), 1)>;
-def : Pat<(setule GPR:$rs1, GPR:$rs2), (XORI (SLTU GPR:$rs2, GPR:$rs1), 1)>;
-def : Pat<(setgt GPR:$rs1, GPR:$rs2), (SLT GPR:$rs2, GPR:$rs1)>;
-def : Pat<(setge GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs1, GPR:$rs2), 1)>;
-def : Pat<(setle GPR:$rs1, GPR:$rs2), (XORI (SLT GPR:$rs2, GPR:$rs1), 1)>;
-
-let usesCustomInserter = 1 in
-def Select_GPR_Using_CC_GPR
-    : Pseudo<(outs GPR:$dst),
-             (ins GPR:$lhs, GPR:$rhs, ixlenimm:$imm, GPR:$src, GPR:$src2),
-             [(set XLenVT:$dst, (SelectCC GPR:$lhs, GPR:$rhs,
-              (XLenVT imm:$imm), GPR:$src, GPR:$src2))]>;
-
-/// Branches and jumps
-
-// Match `(brcond (CondOp ..), ..)` and lower to the appropriate RISC-V branch
-// instruction.
-class BccPat<PatFrag CondOp, RVInstB Inst>
-    : Pat<(brcond (i32 (CondOp GPR:$rs1, GPR:$rs2)), bb:$imm12),
-          (Inst GPR:$rs1, GPR:$rs2, simm13_lsb0:$imm12)>;
-
-def : BccPat<seteq, BEQ>;
-def : BccPat<setne, BNE>;
-def : BccPat<setlt, BLT>;
-def : BccPat<setge, BGE>;
-def : BccPat<setult, BLTU>;
-def : BccPat<setuge, BGEU>;
-
-class BccSwapPat<PatFrag CondOp, RVInst InstBcc>
-    : Pat<(brcond (i32 (CondOp GPR:$rs1, GPR:$rs2)), bb:$imm12),
-          (InstBcc GPR:$rs2, GPR:$rs1, bb:$imm12)>;
-
-// Condition codes that don't have matching RISC-V branch instructions, but
-// are trivially supported by swapping the two input operands
-def : BccSwapPat<setgt, BLT>;
-def : BccSwapPat<setle, BGE>;
-def : BccSwapPat<setugt, BLTU>;
-def : BccSwapPat<setule, BGEU>;
-
-// An extra pattern is needed for a brcond without a setcc (i.e. where the
-// condition was calculated elsewhere).
-def : Pat<(brcond GPR:$cond, bb:$imm12), (BNE GPR:$cond, X0, bb:$imm12)>;
-
-let isBarrier = 1, isBranch = 1, isTerminator = 1 in
-def PseudoBR : Pseudo<(outs), (ins simm21_lsb0:$imm20), [(br bb:$imm20)]>,
-               PseudoInstExpansion<(JAL X0, simm21_lsb0:$imm20)>;
-
-let isCall = 1, Defs=[X1] in
-let isBarrier = 1, isBranch = 1, isIndirectBranch = 1, isTerminator = 1 in
-def PseudoBRIND : Pseudo<(outs), (ins GPR:$rs1, simm12:$imm12), []>,
-                  PseudoInstExpansion<(JALR X0, GPR:$rs1, simm12:$imm12)>;
-
-def : Pat<(brind GPR:$rs1), (PseudoBRIND GPR:$rs1, 0)>;
-def : Pat<(brind (add GPR:$rs1, simm12:$imm12)),
-          (PseudoBRIND GPR:$rs1, simm12:$imm12)>;
-
-let isCall = 1, Defs = [X1] in
-def PseudoCALL : Pseudo<(outs), (ins GPR:$rs1), [(Call GPR:$rs1)]>,
-                 PseudoInstExpansion<(JALR X1, GPR:$rs1, 0)>;
-
-let isBarrier = 1, isReturn = 1, isTerminator = 1 in
-def PseudoRET : Pseudo<(outs), (ins), [(RetFlag)]>,
-                PseudoInstExpansion<(JALR X0, X1, 0)>;
-
-/// Loads
-
-multiclass LdPat<PatFrag LoadOp, RVInst Inst> {
-  def : Pat<(LoadOp GPR:$rs1), (Inst GPR:$rs1, 0)>;
-  def : Pat<(LoadOp AddrFI:$rs1), (Inst AddrFI:$rs1, 0)>;
-  def : Pat<(LoadOp (add GPR:$rs1, simm12:$imm12)),
-            (Inst GPR:$rs1, simm12:$imm12)>;
-  def : Pat<(LoadOp (add AddrFI:$rs1, simm12:$imm12)),
-            (Inst AddrFI:$rs1, simm12:$imm12)>;
-  def : Pat<(LoadOp (IsOrAdd AddrFI:$rs1, simm12:$imm12)),
-            (Inst AddrFI:$rs1, simm12:$imm12)>;
-}
-
-defm : LdPat<sextloadi8, LB>;
-defm : LdPat<extloadi8, LB>;
-defm : LdPat<sextloadi16, LH>;
-defm : LdPat<extloadi16, LH>;
-defm : LdPat<load, LW>;
-defm : LdPat<zextloadi8, LBU>;
-defm : LdPat<zextloadi16, LHU>;
-
-/// Stores
-
-multiclass StPat<PatFrag StoreOp, RVInst Inst> {
-  def : Pat<(StoreOp GPR:$rs2, GPR:$rs1), (Inst GPR:$rs2, GPR:$rs1, 0)>;
-  def : Pat<(StoreOp GPR:$rs2, AddrFI:$rs1), (Inst GPR:$rs2, AddrFI:$rs1, 0)>;
-  def : Pat<(StoreOp GPR:$rs2, (add GPR:$rs1, simm12:$imm12)),
-            (Inst GPR:$rs2, GPR:$rs1, simm12:$imm12)>;
-  def : Pat<(StoreOp GPR:$rs2, (add AddrFI:$rs1, simm12:$imm12)),
-            (Inst GPR:$rs2, AddrFI:$rs1, simm12:$imm12)>;
-  def : Pat<(StoreOp GPR:$rs2, (IsOrAdd AddrFI:$rs1, simm12:$imm12)),
-            (Inst GPR:$rs2, AddrFI:$rs1, simm12:$imm12)>;
-}
-
-defm : StPat<truncstorei8, SB>;
-defm : StPat<truncstorei16, SH>;
-defm : StPat<store, SW>;
-
-/// Other pseudo-instructions
-
-// Pessimistically assume the stack pointer will be clobbered
-let Defs = [X2], Uses = [X2] in {
-def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i32imm:$amt1, i32imm:$amt2),
-                              [(CallSeqStart timm:$amt1, timm:$amt2)]>;
-def ADJCALLSTACKUP   : Pseudo<(outs), (ins i32imm:$amt1, i32imm:$amt2),
-                              [(CallSeqEnd timm:$amt1, timm:$amt2)]>;
-} // Defs = [X2], Uses = [X2]
-
-//===----------------------------------------------------------------------===//
-// Standard extensions
-//===----------------------------------------------------------------------===//
-
-include "RISCVInstrInfoM.td"
-include "RISCVInstrInfoA.td"
-include "RISCVInstrInfoF.td"
-include "RISCVInstrInfoD.td"
-include "RISCVInstrInfoC.td"
diff --git a/lib/Target/RISCV/RISCVInstrInfoA.td b/lib/Target/RISCV/RISCVInstrInfoA.td
deleted file mode 100644
index 33e863ba6a1..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoA.td
+++ /dev/null
@@ -1,77 +0,0 @@
-//===-- RISCVInstrInfoA.td - RISC-V 'A' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'A', Atomic
-// Instructions extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Instruction class templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class LR_r<bit aq, bit rl, bits<3> funct3, string opcodestr>
-    : RVInstRAtomic<0b00010, aq, rl, funct3, OPC_AMO,
-                    (outs GPR:$rd), (ins GPR:$rs1),
-                    opcodestr, "$rd, (${rs1})"> {
-  let rs2 = 0;
-}
-
-multiclass LR_r_aq_rl<bits<3> funct3, string opcodestr> {
-  def ""     : LR_r<0, 0, funct3, opcodestr>;
-  def _AQ    : LR_r<1, 0, funct3, opcodestr # ".aq">;
-  def _RL    : LR_r<0, 1, funct3, opcodestr # ".rl">;
-  def _AQ_RL : LR_r<1, 1, funct3, opcodestr # ".aqrl">;
-}
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 1 in
-class AMO_rr<bits<5> funct5, bit aq, bit rl, bits<3> funct3, string opcodestr>
-    : RVInstRAtomic<funct5, aq, rl, funct3, OPC_AMO,
-                    (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
-                    opcodestr, "$rd, $rs2, (${rs1})">;
-
-multiclass AMO_rr_aq_rl<bits<5> funct5, bits<3> funct3, string opcodestr> {
-  def ""     : AMO_rr<funct5, 0, 0, funct3, opcodestr>;
-  def _AQ    : AMO_rr<funct5, 1, 0, funct3, opcodestr # ".aq">;
-  def _RL    : AMO_rr<funct5, 0, 1, funct3, opcodestr # ".rl">;
-  def _AQ_RL : AMO_rr<funct5, 1, 1, funct3, opcodestr # ".aqrl">;
-}
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtA] in {
-defm LR_W       : LR_r_aq_rl<0b010, "lr.w">;
-defm SC_W       : AMO_rr_aq_rl<0b00011, 0b010, "sc.w">;
-defm AMOSWAP_W  : AMO_rr_aq_rl<0b00001, 0b010, "amoswap.w">;
-defm AMOADD_W   : AMO_rr_aq_rl<0b00000, 0b010, "amoadd.w">;
-defm AMOXOR_W   : AMO_rr_aq_rl<0b00100, 0b010, "amoxor.w">;
-defm AMOAND_W   : AMO_rr_aq_rl<0b01100, 0b010, "amoand.w">;
-defm AMOOR_W    : AMO_rr_aq_rl<0b01000, 0b010, "amoor.w">;
-defm AMOMIN_W   : AMO_rr_aq_rl<0b10000, 0b010, "amomin.w">;
-defm AMOMAX_W   : AMO_rr_aq_rl<0b10100, 0b010, "amomax.w">;
-defm AMOMINU_W  : AMO_rr_aq_rl<0b11000, 0b010, "amominu.w">;
-defm AMOMAXU_W  : AMO_rr_aq_rl<0b11100, 0b010, "amomaxu.w">;
-} // Predicates = [HasStdExtA]
-
-let Predicates = [HasStdExtA, IsRV64] in {
-defm LR_D       : LR_r_aq_rl<0b011, "lr.d">;
-defm SC_D       : AMO_rr_aq_rl<0b00011, 0b011, "sc.d">;
-defm AMOSWAP_D  : AMO_rr_aq_rl<0b00001, 0b011, "amoswap.d">;
-defm AMOADD_D   : AMO_rr_aq_rl<0b00000, 0b011, "amoadd.d">;
-defm AMOXOR_D   : AMO_rr_aq_rl<0b00100, 0b011, "amoxor.d">;
-defm AMOAND_D   : AMO_rr_aq_rl<0b01100, 0b011, "amoand.d">;
-defm AMOOR_D    : AMO_rr_aq_rl<0b01000, 0b011, "amoor.d">;
-defm AMOMIN_D   : AMO_rr_aq_rl<0b10000, 0b011, "amomin.d">;
-defm AMOMAX_D   : AMO_rr_aq_rl<0b10100, 0b011, "amomax.d">;
-defm AMOMINU_D  : AMO_rr_aq_rl<0b11000, 0b011, "amominu.d">;
-defm AMOMAXU_D  : AMO_rr_aq_rl<0b11100, 0b011, "amomaxu.d">;
-} // Predicates = [HasStedExtA, IsRV64]
diff --git a/lib/Target/RISCV/RISCVInstrInfoC.td b/lib/Target/RISCV/RISCVInstrInfoC.td
deleted file mode 100644
index b3566878e97..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoC.td
+++ /dev/null
@@ -1,444 +0,0 @@
-//===- RISCVInstrInfoC.td - Compressed RISCV instructions -*- tblgen-*-----===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-include "RISCVInstrFormatsC.td"
-
-//===----------------------------------------------------------------------===//
-// Operand definitions.
-//===----------------------------------------------------------------------===//
-
-def UImmLog2XLenNonZeroAsmOperand : AsmOperandClass {
-  let Name = "UImmLog2XLenNonZero";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = "InvalidUImmLog2XLenNonZero";
-}
-
-def uimmlog2xlennonzero : Operand<XLenVT>, ImmLeaf<XLenVT, [{
-  if (Subtarget->is64Bit())
-    return isUInt<6>(Imm) && (Imm != 0);
-  return isUInt<5>(Imm) && (Imm != 0);
-}]> {
-  let ParserMatchClass = UImmLog2XLenNonZeroAsmOperand;
-  // TODO: should ensure invalid shamt is rejected when decoding.
-  let DecoderMethod = "decodeUImmOperand<6>";
-}
-
-def simm6 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isInt<6>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<6>;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<6>";
-}
-
-def simm6nonzero : Operand<XLenVT>,
-                   ImmLeaf<XLenVT, [{return (Imm != 0) && isInt<6>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<6, "NonZero">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<6>";
-}
-
-def CLUIImmAsmOperand : AsmOperandClass {
-  let Name = "CLUIImm";
-  let RenderMethod = "addImmOperands";
-  let DiagnosticType = !strconcat("Invalid", Name);
-}
-
-
-// c_lui_imm checks the immediate range is in [1, 31] or [0xfffe0, 0xfffff].
-// The RISC-V ISA describes the constraint as [1, 63], with that value being
-// loaded in to bits 17-12 of the destination register and sign extended from
-// bit 17. Therefore, this 6-bit immediate can represent values in the ranges
-// [1, 31] and [0xfffe0, 0xfffff].
-def c_lui_imm : Operand<XLenVT>,
-                ImmLeaf<XLenVT, [{return (Imm != 0) &&
-                                 (isUInt<5>(Imm) ||
-                                  (Imm >= 0xfffe0 && Imm <= 0xfffff));}]> {
-  let ParserMatchClass = CLUIImmAsmOperand;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeCLUIImmOperand";
-}
-
-// A 7-bit unsigned immediate where the least significant two bits are zero.
-def uimm7_lsb00 : Operand<XLenVT>,
-                  ImmLeaf<XLenVT, [{return isShiftedUInt<5, 2>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<7, "Lsb00">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<7>";
-}
-
-// A 8-bit unsigned immediate where the least significant two bits are zero.
-def uimm8_lsb00 : Operand<XLenVT>,
-                  ImmLeaf<XLenVT, [{return isShiftedUInt<6, 2>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<8, "Lsb00">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<8>";
-}
-
-// A 8-bit unsigned immediate where the least significant three bits are zero.
-def uimm8_lsb000 : Operand<XLenVT>,
-                   ImmLeaf<XLenVT, [{return isShiftedUInt<5, 3>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<8, "Lsb000">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<8>";
-}
-
-// A 9-bit signed immediate where the least significant bit is zero.
-def simm9_lsb0 : Operand<OtherVT> {
-  let ParserMatchClass = SImmAsmOperand<9, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<9>";
-}
-
-// A 9-bit unsigned immediate where the least significant three bits are zero.
-def uimm9_lsb000 : Operand<XLenVT>,
-                   ImmLeaf<XLenVT, [{return isShiftedUInt<6, 3>(Imm);}]> {
-  let ParserMatchClass = UImmAsmOperand<9, "Lsb000">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<9>";
-}
-
-// A 10-bit unsigned immediate where the least significant two bits are zero
-// and the immediate can't be zero.
-def uimm10_lsb00nonzero : Operand<XLenVT>,
-                          ImmLeaf<XLenVT,
-                          [{return isShiftedUInt<8, 2>(Imm) && (Imm != 0);}]> {
-  let ParserMatchClass = UImmAsmOperand<10, "Lsb00NonZero">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeUImmOperand<10>";
-}
-
-// A 10-bit signed immediate where the least significant four bits are zero.
-def simm10_lsb0000nonzero : Operand<XLenVT>,
-                            ImmLeaf<XLenVT,
-                            [{return (Imm != 0) && isShiftedInt<6, 4>(Imm);}]> {
-  let ParserMatchClass = SImmAsmOperand<10, "Lsb0000NonZero">;
-  let EncoderMethod = "getImmOpValue";
-  let DecoderMethod = "decodeSImmOperand<10>";
-}
-
-// A 12-bit signed immediate where the least significant bit is zero.
-def simm12_lsb0 : Operand<OtherVT> {
-  let ParserMatchClass = SImmAsmOperand<12, "Lsb0">;
-  let EncoderMethod = "getImmOpValueAsr1";
-  let DecoderMethod = "decodeSImmOperandAndLsl1<12>";
-}
-
-//===----------------------------------------------------------------------===//
-// Instruction Class Templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class CStackLoad<bits<3> funct3, string OpcodeStr,
-                 RegisterClass cls, DAGOperand opnd>
-    : RVInst16CI<funct3, 0b10, (outs cls:$rd), (ins SP:$rs1, opnd:$imm),
-                 OpcodeStr, "$rd, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-class CStackStore<bits<3> funct3, string OpcodeStr,
-                  RegisterClass cls, DAGOperand opnd>
-    : RVInst16CSS<funct3, 0b10, (outs), (ins cls:$rs2, SP:$rs1, opnd:$imm),
-                  OpcodeStr, "$rs2, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-class CLoad_ri<bits<3> funct3, string OpcodeStr,
-               RegisterClass cls, DAGOperand opnd>
-    : RVInst16CL<funct3, 0b00, (outs cls:$rd), (ins GPRC:$rs1, opnd:$imm),
-                 OpcodeStr, "$rd, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-class CStore_rri<bits<3> funct3, string OpcodeStr,
-                 RegisterClass cls, DAGOperand opnd>
-    : RVInst16CS<funct3, 0b00, (outs), (ins cls:$rs2, GPRC:$rs1, opnd:$imm),
-                 OpcodeStr, "$rs2, ${imm}(${rs1})">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class Bcz<bits<3> funct3, string OpcodeStr, PatFrag CondOp,
-          RegisterClass cls>
-    : RVInst16CB<funct3, 0b01, (outs), (ins cls:$rs1, simm9_lsb0:$imm),
-                 OpcodeStr, "$rs1, $imm"> {
-  let isBranch = 1;
-  let isTerminator = 1;
-  let Inst{12} = imm{7};
-  let Inst{11-10} = imm{3-2};
-  let Inst{6-5} = imm{6-5};
-  let Inst{4-3} = imm{1-0};
-  let Inst{2} = imm{4};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class Shift_right<bits<2> funct2, string OpcodeStr, RegisterClass cls,
-                  Operand ImmOpnd>
-    : RVInst16CB<0b100, 0b01, (outs cls:$rs1_wb), (ins cls:$rs1, ImmOpnd:$imm),
-                 OpcodeStr, "$rs1, $imm"> {
-  let Constraints = "$rs1 = $rs1_wb";
-  let Inst{12} = imm{5};
-  let Inst{11-10} = funct2;
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class CS_ALU<bits<2> funct2, string OpcodeStr, RegisterClass cls,
-             bit RV64only>
-    : RVInst16CS<0b100, 0b01, (outs cls:$rd_wb), (ins cls:$rd, cls:$rs2),
-                 OpcodeStr, "$rd, $rs2"> {
-  bits<3> rd;
-  let Constraints = "$rd = $rd_wb";
-  let Inst{12} = RV64only;
-  let Inst{11-10} = 0b11;
-  let Inst{9-7} = rd;
-  let Inst{6-5} = funct2;
-}
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtC] in {
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0, Uses = [X2] in
-def C_ADDI4SPN : RVInst16CIW<0b000, 0b00, (outs GPRC:$rd),
-                             (ins SP:$rs1, uimm10_lsb00nonzero:$imm),
-                             "c.addi4spn", "$rd, $rs1, $imm"> {
-  bits<5> rs1;
-  let Inst{12-11} = imm{5-4};
-  let Inst{10-7} = imm{9-6};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{3};
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FLD  : CLoad_ri<0b001, "c.fld", FPR64C, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-def C_LW : CLoad_ri<0b010, "c.lw", GPRC, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32] in
-def C_FLW  : CLoad_ri<0b011, "c.flw", FPR32C, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_LD : CLoad_ri<0b011, "c.ld", GPRC, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FSD  : CStore_rri<0b101, "c.fsd", FPR64C, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-def C_SW : CStore_rri<0b110, "c.sw", GPRC, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32]  in
-def C_FSW  : CStore_rri<0b111, "c.fsw", FPR32C, uimm7_lsb00> {
-  bits<7> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6} = imm{2};
-  let Inst{5} = imm{6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_SD : CStore_rri<0b111, "c.sd", GPRC, uimm8_lsb000> {
-  bits<8> imm;
-  let Inst{12-10} = imm{5-3};
-  let Inst{6-5} = imm{7-6};
-}
-
-let rd = 0, imm = 0, hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_NOP : RVInst16CI<0b000, 0b01, (outs), (ins), "c.nop", "">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ADDI : RVInst16CI<0b000, 0b01, (outs GPRNoX0:$rd_wb),
-                        (ins GPRNoX0:$rd, simm6nonzero:$imm),
-                        "c.addi", "$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0, isCall = 1,
-    DecoderNamespace = "RISCV32Only_", Defs = [X1],
-    Predicates = [HasStdExtC, IsRV32]  in
-def C_JAL : RVInst16CJ<0b001, 0b01, (outs), (ins simm12_lsb0:$offset),
-                       "c.jal", "$offset">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0,
-    Predicates = [HasStdExtC, IsRV64] in
-def C_ADDIW : RVInst16CI<0b001, 0b01, (outs GPRNoX0:$rd_wb),
-                         (ins GPRNoX0:$rd, simm6:$imm),
-                         "c.addiw", "$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_LI : RVInst16CI<0b010, 0b01, (outs GPRNoX0:$rd), (ins simm6:$imm),
-                      "c.li", "$rd, $imm"> {
-  let Inst{6-2} = imm{4-0};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ADDI16SP : RVInst16CI<0b011, 0b01, (outs SP:$rd_wb),
-                            (ins SP:$rd, simm10_lsb0000nonzero:$imm),
-                            "c.addi16sp", "$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{12} = imm{9};
-  let Inst{11-7} = 2;
-  let Inst{6} = imm{4};
-  let Inst{5} = imm{6};
-  let Inst{4-3} = imm{8-7};
-  let Inst{2} = imm{5};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_LUI : RVInst16CI<0b011, 0b01, (outs GPRNoX0X2:$rd),
-                       (ins c_lui_imm:$imm),
-                       "c.lui", "$rd, $imm"> {
-  let Inst{6-2} = imm{4-0};
-}
-
-def C_SRLI : Shift_right<0b00, "c.srli", GPRC, uimmlog2xlennonzero>;
-def C_SRAI : Shift_right<0b01, "c.srai", GPRC, uimmlog2xlennonzero>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ANDI : RVInst16CB<0b100, 0b01, (outs GPRC:$rs1_wb), (ins GPRC:$rs1, simm6:$imm),
-                        "c.andi", "$rs1, $imm"> {
-  let Constraints = "$rs1 = $rs1_wb";
-  let Inst{12} = imm{5};
-  let Inst{11-10} = 0b10;
-  let Inst{6-2} = imm{4-0};
-}
-
-def C_SUB  : CS_ALU<0b00, "c.sub", GPRC, 0>;
-def C_XOR  : CS_ALU<0b01, "c.xor", GPRC, 0>;
-def C_OR   : CS_ALU<0b10, "c.or" , GPRC, 0>;
-def C_AND  : CS_ALU<0b11, "c.and", GPRC, 0>;
-
-let Predicates = [HasStdExtC, IsRV64] in {
-def C_SUBW : CS_ALU<0b00, "c.subw", GPRC, 1>;
-def C_ADDW : CS_ALU<0b01, "c.addw", GPRC, 1>;
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_J : RVInst16CJ<0b101, 0b01, (outs), (ins simm12_lsb0:$offset),
-                     "c.j", "$offset"> {
-  let isBranch = 1;
-  let isTerminator=1;
-  let isBarrier=1;
-}
-
-def C_BEQZ : Bcz<0b110, "c.beqz",  seteq, GPRC>;
-def C_BNEZ : Bcz<0b111, "c.bnez",  setne, GPRC>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_SLLI : RVInst16CI<0b000, 0b10, (outs GPRNoX0:$rd_wb),
-                        (ins GPRNoX0:$rd, uimmlog2xlennonzero:$imm),
-                        "c.slli" ,"$rd, $imm"> {
-  let Constraints = "$rd = $rd_wb";
-  let Inst{6-2} = imm{4-0};
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FLDSP  : CStackLoad<0b001, "c.fldsp", FPR64, uimm9_lsb000> {
-  let Inst{6-5} = imm{4-3};
-  let Inst{4-2} = imm{8-6};
-}
-
-def C_LWSP : CStackLoad<0b010, "c.lwsp", GPRNoX0, uimm8_lsb00> {
-  let Inst{6-4} = imm{4-2};
-  let Inst{3-2} = imm{7-6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32] in
-def C_FLWSP  : CStackLoad<0b011, "c.flwsp", FPR32, uimm8_lsb00> {
-  let Inst{6-4} = imm{4-2};
-  let Inst{3-2} = imm{7-6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_LDSP : CStackLoad<0b011, "c.ldsp", GPRNoX0, uimm9_lsb000> {
-  let Inst{6-5} = imm{4-3};
-  let Inst{4-2} = imm{8-6};
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_JR : RVInst16CR<0b1000, 0b10, (outs), (ins GPRNoX0:$rs1),
-                      "c.jr", "$rs1"> {
-  let isBranch = 1;
-  let isBarrier = 1;
-  let isTerminator = 1;
-  let isIndirectBranch = 1;
-  let rs2 = 0;
-}
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_MV : RVInst16CR<0b1000, 0b10, (outs GPRNoX0:$rs1), (ins GPRNoX0:$rs2),
-                      "c.mv", "$rs1, $rs2">;
-
-let rs1 = 0, rs2 = 0, hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_EBREAK : RVInst16CR<0b1001, 0b10, (outs), (ins), "c.ebreak", "">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0,
-    isCall=1, Defs=[X1], rs2 = 0 in
-def C_JALR : RVInst16CR<0b1001, 0b10, (outs), (ins GPRNoX0:$rs1),
-                        "c.jalr", "$rs1">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-def C_ADD : RVInst16CR<0b1001, 0b10, (outs GPRNoX0:$rs1_wb),
-                       (ins GPRNoX0:$rs1, GPRNoX0:$rs2),
-                       "c.add", "$rs1, $rs2"> {
-  let Constraints = "$rs1 = $rs1_wb";
-}
-
-let Predicates = [HasStdExtC, HasStdExtD] in
-def C_FSDSP  : CStackStore<0b101, "c.fsdsp", FPR64, uimm9_lsb000> {
-  let Inst{12-10} = imm{5-3};
-  let Inst{9-7}   = imm{8-6};
-}
-
-def C_SWSP : CStackStore<0b110, "c.swsp", GPR, uimm8_lsb00> {
-  let Inst{12-9} = imm{5-2};
-  let Inst{8-7}  = imm{7-6};
-}
-
-let DecoderNamespace = "RISCV32Only_",
-    Predicates = [HasStdExtC, HasStdExtF, IsRV32] in
-def C_FSWSP  : CStackStore<0b111, "c.fswsp", FPR32, uimm8_lsb00> {
-  let Inst{12-9} = imm{5-2};
-  let Inst{8-7}  = imm{7-6};
-}
-
-let Predicates = [HasStdExtC, IsRV64] in
-def C_SDSP : CStackStore<0b111, "c.sdsp", GPR, uimm9_lsb000> {
-  let Inst{12-10} = imm{5-3};
-  let Inst{9-7}   = imm{8-6};
-}
-
-} // Predicates = [HasStdExtC]
diff --git a/lib/Target/RISCV/RISCVInstrInfoD.td b/lib/Target/RISCV/RISCVInstrInfoD.td
deleted file mode 100644
index 48d91c0054d..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoD.td
+++ /dev/null
@@ -1,174 +0,0 @@
-//===-- RISCVInstrInfoD.td - RISC-V 'D' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'D',
-// Double-Precision Floating-Point instruction set extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Instruction Class Templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPFMAD_rrr_frm<RISCVOpcode opcode, string opcodestr>
-    : RVInstR4<0b01, opcode, (outs FPR64:$rd),
-               (ins FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, frmarg:$funct3),
-                opcodestr, "$rd, $rs1, $rs2, $rs3, $funct3">;
-
-class FPFMADDynFrmAlias<FPFMAD_rrr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2, $rs3",
-                (Inst FPR64:$rd, FPR64:$rs1, FPR64:$rs2, FPR64:$rs3, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUD_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_FP, (outs FPR64:$rd),
-              (ins FPR64:$rs1, FPR64:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUD_rr_frm<bits<7> funct7, string opcodestr>
-    : RVInstRFrm<funct7, OPC_OP_FP, (outs FPR64:$rd),
-                (ins FPR64:$rs1, FPR64:$rs2, frmarg:$funct3), opcodestr,
-                 "$rd, $rs1, $rs2, $funct3">;
-
-class FPALUDDynFrmAlias<FPALUD_rr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2",
-                (Inst FPR64:$rd, FPR64:$rs1, FPR64:$rs2, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPCmpD_rr<bits<3> funct3, string opcodestr>
-    : RVInstR<0b1010001, funct3, OPC_OP_FP, (outs GPR:$rd),
-              (ins FPR64:$rs1, FPR64:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtD] in {
-
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-def FLD : RVInstI<0b011, OPC_LOAD_FP, (outs FPR64:$rd),
-                  (ins GPR:$rs1, simm12:$imm12),
-                  "fld", "$rd, ${imm12}(${rs1})">;
-
-// Operands for stores are in the order srcreg, base, offset rather than
-// reflecting the order these fields are specified in the instruction
-// encoding.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-def FSD : RVInstS<0b011, OPC_STORE_FP, (outs),
-                  (ins FPR64:$rs2, GPR:$rs1, simm12:$imm12),
-                   "fsd", "$rs2, ${imm12}(${rs1})">;
-
-def FMADD_D  : FPFMAD_rrr_frm<OPC_MADD, "fmadd.d">;
-def          : FPFMADDynFrmAlias<FMADD_D, "fmadd.d">;
-def FMSUB_D  : FPFMAD_rrr_frm<OPC_MSUB, "fmsub.d">;
-def          : FPFMADDynFrmAlias<FMSUB_D, "fmsub.d">;
-def FNMSUB_D : FPFMAD_rrr_frm<OPC_NMSUB, "fnmsub.d">;
-def          : FPFMADDynFrmAlias<FNMSUB_D, "fnmsub.d">;
-def FNMADD_D : FPFMAD_rrr_frm<OPC_NMADD, "fnmadd.d">;
-def          : FPFMADDynFrmAlias<FNMADD_D, "fnmadd.d">;
-
-def FADD_D : FPALUD_rr_frm<0b0000001, "fadd.d">;
-def        : FPALUDDynFrmAlias<FADD_D, "fadd.d">;
-def FSUB_D : FPALUD_rr_frm<0b0000101, "fsub.d">;
-def        : FPALUDDynFrmAlias<FSUB_D, "fsub.d">;
-def FMUL_D : FPALUD_rr_frm<0b0001001, "fmul.d">;
-def        : FPALUDDynFrmAlias<FMUL_D, "fmul.d">;
-def FDIV_D : FPALUD_rr_frm<0b0001101, "fdiv.d">;
-def        : FPALUDDynFrmAlias<FDIV_D, "fdiv.d">;
-
-def FSQRT_D : FPUnaryOp_r_frm<0b0101101, FPR64, FPR64, "fsqrt.d"> {
-  let rs2 = 0b00000;
-}
-def         : FPUnaryOpDynFrmAlias<FSQRT_D, "fsqrt.d", FPR64, FPR64>;
-
-def FSGNJ_D  : FPALUD_rr<0b0010001, 0b000, "fsgnj.d">;
-def FSGNJN_D : FPALUD_rr<0b0010001, 0b001, "fsgnjn.d">;
-def FSGNJX_D : FPALUD_rr<0b0010001, 0b010, "fsgnjx.d">;
-def FMIN_D   : FPALUD_rr<0b0010101, 0b000, "fmin.d">;
-def FMAX_D   : FPALUD_rr<0b0010101, 0b001, "fmax.d">;
-
-def FCVT_S_D : FPUnaryOp_r_frm<0b0100000, FPR32, FPR64, "fcvt.s.d"> {
-  let rs2 = 0b00001;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_S_D, "fcvt.s.d", FPR32, FPR64>;
-
-def FCVT_D_S : FPUnaryOp_r<0b0100001, 0b000, FPR64, FPR32, "fcvt.d.s"> {
-  let rs2 = 0b00000;
-}
-
-def FEQ_D : FPCmpD_rr<0b010, "feq.d">;
-def FLT_D : FPCmpD_rr<0b001, "flt.d">;
-def FLE_D : FPCmpD_rr<0b000, "fle.d">;
-
-def FCLASS_D : FPUnaryOp_r<0b1110001, 0b001, GPR, FPR64, "fclass.d"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_W_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.w.d"> {
-  let rs2 = 0b00000;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_W_D, "fcvt.w.d", GPR, FPR64>;
-
-def FCVT_WU_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.wu.d"> {
-  let rs2 = 0b00001;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_WU_D, "fcvt.wu.d", GPR, FPR64>;
-
-def FCVT_D_W : FPUnaryOp_r<0b1101001, 0b000, FPR64, GPR, "fcvt.d.w"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_D_WU : FPUnaryOp_r<0b1101001, 0b000, FPR64, GPR, "fcvt.d.wu"> {
-  let rs2 = 0b00001;
-}
-} // Predicates = [HasStdExtD]
-
-let Predicates = [HasStdExtD, IsRV64] in {
-def FCVT_L_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.l.d"> {
-  let rs2 = 0b00010;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_L_D, "fcvt.l.d", GPR, FPR64>;
-
-def FCVT_LU_D : FPUnaryOp_r_frm<0b1100001, GPR, FPR64, "fcvt.lu.d"> {
-  let rs2 = 0b00011;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_LU_D, "fcvt.lu.d", GPR, FPR64>;
-
-def FMV_X_D : FPUnaryOp_r<0b1110001, 0b000, GPR, FPR64, "fmv.x.d"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_D_L : FPUnaryOp_r_frm<0b1101001, FPR64, GPR, "fcvt.d.l"> {
-  let rs2 = 0b00010;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_D_L, "fcvt.d.l", FPR64, GPR>;
-
-def FCVT_D_LU : FPUnaryOp_r_frm<0b1101001, FPR64, GPR, "fcvt.d.lu"> {
-  let rs2 = 0b00011;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_D_LU, "fcvt.d.lu", FPR64, GPR>;
-
-def FMV_D_X : FPUnaryOp_r<0b1111001, 0b000, FPR64, GPR, "fmv.d.x"> {
-  let rs2 = 0b00000;
-}
-} // Predicates = [HasStdExtD, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtD] in {
-// TODO fld
-// TODO fsd
-
-def : InstAlias<"fmv.d $rd, $rs",  (FSGNJ_D  FPR64:$rd, FPR64:$rs, FPR64:$rs)>;
-def : InstAlias<"fabs.d $rd, $rs", (FSGNJX_D FPR64:$rd, FPR64:$rs, FPR64:$rs)>;
-def : InstAlias<"fneg.d $rd, $rs", (FSGNJN_D FPR64:$rd, FPR64:$rs, FPR64:$rs)>;
-} // Predicates = [HasStdExtD]
diff --git a/lib/Target/RISCV/RISCVInstrInfoF.td b/lib/Target/RISCV/RISCVInstrInfoF.td
deleted file mode 100644
index 07722d2cbf3..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoF.td
+++ /dev/null
@@ -1,222 +0,0 @@
-//===-- RISCVInstrInfoF.td - RISC-V 'F' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'F',
-// Single-Precision Floating-Point instruction set extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Operand and SDNode transformation definitions.
-//===----------------------------------------------------------------------===//
-
-// Floating-point rounding mode
-
-def FRMArg : AsmOperandClass {
-  let Name = "FRMArg";
-  let RenderMethod = "addFRMArgOperands";
-  let DiagnosticType = "InvalidFRMArg";
-}
-
-def frmarg : Operand<XLenVT> {
-  let ParserMatchClass = FRMArg;
-  let PrintMethod = "printFRMArg";
-  let DecoderMethod = "decodeUImmOperand<3>";
-}
-
-//===----------------------------------------------------------------------===//
-// Instruction class templates
-//===----------------------------------------------------------------------===//
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPFMAS_rrr_frm<RISCVOpcode opcode, string opcodestr>
-    : RVInstR4<0b00, opcode, (outs FPR32:$rd),
-               (ins FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, frmarg:$funct3),
-                opcodestr, "$rd, $rs1, $rs2, $rs3, $funct3">;
-
-class FPFMASDynFrmAlias<FPFMAS_rrr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2, $rs3",
-                (Inst FPR32:$rd, FPR32:$rs1, FPR32:$rs2, FPR32:$rs3, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUS_rr<bits<7> funct7, bits<3> funct3, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_FP, (outs FPR32:$rd),
-              (ins FPR32:$rs1, FPR32:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPALUS_rr_frm<bits<7> funct7, string opcodestr>
-    : RVInstRFrm<funct7, OPC_OP_FP, (outs FPR32:$rd),
-                 (ins FPR32:$rs1, FPR32:$rs2, frmarg:$funct3), opcodestr,
-                  "$rd, $rs1, $rs2, $funct3">;
-
-class FPALUSDynFrmAlias<FPALUS_rr_frm Inst, string OpcodeStr>
-    : InstAlias<OpcodeStr#" $rd, $rs1, $rs2",
-                (Inst FPR32:$rd, FPR32:$rs1, FPR32:$rs2, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPUnaryOp_r<bits<7> funct7, bits<3> funct3, RegisterClass rdty,
-                RegisterClass rs1ty, string opcodestr>
-    : RVInstR<funct7, funct3, OPC_OP_FP, (outs rdty:$rd), (ins rs1ty:$rs1),
-              opcodestr, "$rd, $rs1">;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPUnaryOp_r_frm<bits<7> funct7, RegisterClass rdty, RegisterClass rs1ty,
-                      string opcodestr>
-    : RVInstRFrm<funct7, OPC_OP_FP, (outs rdty:$rd),
-                 (ins rs1ty:$rs1, frmarg:$funct3), opcodestr,
-                  "$rd, $rs1, $funct3">;
-
-class FPUnaryOpDynFrmAlias<FPUnaryOp_r_frm Inst, string OpcodeStr,
-                           RegisterClass rdty, RegisterClass rs1ty>
-    : InstAlias<OpcodeStr#" $rd, $rs1",
-                (Inst rdty:$rd, rs1ty:$rs1, 0b111)>;
-
-let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
-class FPCmpS_rr<bits<3> funct3, string opcodestr>
-    : RVInstR<0b1010000, funct3, OPC_OP_FP, (outs GPR:$rd),
-              (ins FPR32:$rs1, FPR32:$rs2), opcodestr, "$rd, $rs1, $rs2">;
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtF] in {
-let hasSideEffects = 0, mayLoad = 1, mayStore = 0 in
-def FLW : RVInstI<0b010, OPC_LOAD_FP, (outs FPR32:$rd),
-                  (ins GPR:$rs1, simm12:$imm12),
-                   "flw", "$rd, ${imm12}(${rs1})">;
-
-// Operands for stores are in the order srcreg, base, offset rather than
-// reflecting the order these fields are specified in the instruction
-// encoding.
-let hasSideEffects = 0, mayLoad = 0, mayStore = 1 in
-def FSW : RVInstS<0b010, OPC_STORE_FP, (outs),
-                  (ins FPR32:$rs2, GPR:$rs1, simm12:$imm12),
-                   "fsw", "$rs2, ${imm12}(${rs1})">;
-
-def FMADD_S  : FPFMAS_rrr_frm<OPC_MADD, "fmadd.s">;
-def          : FPFMASDynFrmAlias<FMADD_S, "fmadd.s">;
-def FMSUB_S  : FPFMAS_rrr_frm<OPC_MSUB, "fmsub.s">;
-def          : FPFMASDynFrmAlias<FMSUB_S, "fmsub.s">;
-def FNMSUB_S : FPFMAS_rrr_frm<OPC_NMSUB, "fnmsub.s">;
-def          : FPFMASDynFrmAlias<FNMSUB_S, "fnmsub.s">;
-def FNMADD_S : FPFMAS_rrr_frm<OPC_NMADD, "fnmadd.s">;
-def          : FPFMASDynFrmAlias<FNMADD_S, "fnmadd.s">;
-
-def FADD_S : FPALUS_rr_frm<0b0000000, "fadd.s">;
-def        : FPALUSDynFrmAlias<FADD_S, "fadd.s">;
-def FSUB_S : FPALUS_rr_frm<0b0000100, "fsub.s">;
-def        : FPALUSDynFrmAlias<FSUB_S, "fsub.s">;
-def FMUL_S : FPALUS_rr_frm<0b0001000, "fmul.s">;
-def        : FPALUSDynFrmAlias<FMUL_S, "fmul.s">;
-def FDIV_S : FPALUS_rr_frm<0b0001100, "fdiv.s">;
-def        : FPALUSDynFrmAlias<FDIV_S, "fdiv.s">;
-
-def FSQRT_S : FPUnaryOp_r_frm<0b0101100, FPR32, FPR32, "fsqrt.s"> {
-  let rs2 = 0b00000;
-}
-def         : FPUnaryOpDynFrmAlias<FSQRT_S, "fsqrt.s", FPR32, FPR32>;
-
-def FSGNJ_S  : FPALUS_rr<0b0010000, 0b000, "fsgnj.s">;
-def FSGNJN_S : FPALUS_rr<0b0010000, 0b001, "fsgnjn.s">;
-def FSGNJX_S : FPALUS_rr<0b0010000, 0b010, "fsgnjx.s">;
-def FMIN_S   : FPALUS_rr<0b0010100, 0b000, "fmin.s">;
-def FMAX_S   : FPALUS_rr<0b0010100, 0b001, "fmax.s">;
-
-def FCVT_W_S : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.w.s"> {
-  let rs2 = 0b00000;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_W_S, "fcvt.w.s", GPR, FPR32>;
-
-def FCVT_WU_S : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.wu.s"> {
-  let rs2 = 0b00001;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_WU_S, "fcvt.wu.s", GPR, FPR32>;
-
-def FMV_X_W : FPUnaryOp_r<0b1110000, 0b000, GPR, FPR32, "fmv.x.w"> {
-  let rs2 = 0b00000;
-}
-
-def FEQ_S : FPCmpS_rr<0b010, "feq.s">;
-def FLT_S : FPCmpS_rr<0b001, "flt.s">;
-def FLE_S : FPCmpS_rr<0b000, "fle.s">;
-
-def FCLASS_S : FPUnaryOp_r<0b1110000, 0b001, GPR, FPR32, "fclass.s"> {
-  let rs2 = 0b00000;
-}
-
-def FCVT_S_W : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.w"> {
-  let rs2 = 0b00000;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_S_W, "fcvt.s.w", FPR32, GPR>;
-
-def FCVT_S_WU : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.wu"> {
-  let rs2 = 0b00001;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_S_WU, "fcvt.s.wu", FPR32, GPR>;
-
-def FMV_W_X : FPUnaryOp_r<0b1111000, 0b000, FPR32, GPR, "fmv.w.x"> {
-  let rs2 = 0b00000;
-}
-} // Predicates = [HasStdExtF]
-
-let Predicates = [HasStdExtF, IsRV64] in {
-def FCVT_L_S  : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.l.s"> {
-  let rs2 = 0b00010;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_L_S, "fcvt.l.s", GPR, FPR32>;
-
-def FCVT_LU_S  : FPUnaryOp_r_frm<0b1100000, GPR, FPR32, "fcvt.lu.s"> {
-  let rs2 = 0b00011;
-}
-def            : FPUnaryOpDynFrmAlias<FCVT_LU_S, "fcvt.lu.s", GPR, FPR32>;
-
-def FCVT_S_L : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.l"> {
-  let rs2 = 0b00010;
-}
-def          : FPUnaryOpDynFrmAlias<FCVT_S_L, "fcvt.s.l", FPR32, GPR>;
-
-def FCVT_S_LU : FPUnaryOp_r_frm<0b1101000, FPR32, GPR, "fcvt.s.lu"> {
-  let rs2 = 0b00011;
-}
-def           : FPUnaryOpDynFrmAlias<FCVT_S_LU, "fcvt.s.lu", FPR32, GPR>;
-} // Predicates = [HasStdExtF, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtF] in {
-// TODO flw
-// TODO fsw
-
-def : InstAlias<"fmv.s $rd, $rs",  (FSGNJ_S  FPR32:$rd, FPR32:$rs, FPR32:$rs)>;
-def : InstAlias<"fabs.s $rd, $rs", (FSGNJX_S FPR32:$rd, FPR32:$rs, FPR32:$rs)>;
-def : InstAlias<"fneg.s $rd, $rs", (FSGNJN_S FPR32:$rd, FPR32:$rs, FPR32:$rs)>;
-
-// The following csr instructions actually alias instructions from the base ISA.
-// However, it only makes sense to support them when the F extension is enabled.
-// CSR Addresses: 0x003 == fcsr, 0x002 == frm, 0x001 == fflags
-// NOTE: "frcsr", "frrm", and "frflags" are more specialized version of "csrr".
-def : InstAlias<"frcsr $rd",      (CSRRS GPR:$rd, 0x003, X0), 2>;
-def : InstAlias<"fscsr $rd, $rs", (CSRRW GPR:$rd, 0x003, GPR:$rs)>;
-def : InstAlias<"fscsr $rs",      (CSRRW      X0, 0x003, GPR:$rs), 2>;
-
-def : InstAlias<"frrm $rd",        (CSRRS  GPR:$rd, 0x002, X0), 2>;
-def : InstAlias<"fsrm $rd, $rs",   (CSRRW  GPR:$rd, 0x002, GPR:$rs)>;
-def : InstAlias<"fsrm $rs",        (CSRRW       X0, 0x002, GPR:$rs), 2>;
-def : InstAlias<"fsrmi $rd, $imm", (CSRRWI GPR:$rd, 0x002, uimm5:$imm)>;
-def : InstAlias<"fsrmi $imm",      (CSRRWI      X0, 0x002, uimm5:$imm), 2>;
-
-def : InstAlias<"frflags $rd",        (CSRRS  GPR:$rd, 0x001, X0), 2>;
-def : InstAlias<"fsflags $rd, $rs",   (CSRRW  GPR:$rd, 0x001, GPR:$rs)>;
-def : InstAlias<"fsflags $rs",        (CSRRW       X0, 0x001, GPR:$rs), 2>;
-def : InstAlias<"fsflagsi $rd, $imm", (CSRRWI GPR:$rd, 0x001, uimm5:$imm)>;
-def : InstAlias<"fsflagsi $imm",      (CSRRWI      X0, 0x001, uimm5:$imm), 2>;
-} // Predicates = [HasStdExtF]
diff --git a/lib/Target/RISCV/RISCVInstrInfoM.td b/lib/Target/RISCV/RISCVInstrInfoM.td
deleted file mode 100644
index 2dd10ada400..00000000000
--- a/lib/Target/RISCV/RISCVInstrInfoM.td
+++ /dev/null
@@ -1,51 +0,0 @@
-//===-- RISCVInstrInfoM.td - RISC-V 'M' instructions -------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file describes the RISC-V instructions from the standard 'M', Integer
-// Multiplication and Division instruction set extension.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-// Instructions
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtM] in {
-def MUL     : ALU_rr<0b0000001, 0b000, "mul">;
-def MULH    : ALU_rr<0b0000001, 0b001, "mulh">;
-def MULHSU  : ALU_rr<0b0000001, 0b010, "mulhsu">;
-def MULHU   : ALU_rr<0b0000001, 0b011, "mulhu">;
-def DIV     : ALU_rr<0b0000001, 0b100, "div">;
-def DIVU    : ALU_rr<0b0000001, 0b101, "divu">;
-def REM     : ALU_rr<0b0000001, 0b110, "rem">;
-def REMU    : ALU_rr<0b0000001, 0b111, "remu">;
-} // Predicates = [HasStdExtM]
-
-let Predicates = [HasStdExtM, IsRV64] in {
-def MULW    : ALUW_rr<0b0000001, 0b000, "mulw">;
-def DIVW    : ALUW_rr<0b0000001, 0b100, "divw">;
-def DIVUW   : ALUW_rr<0b0000001, 0b101, "divuw">;
-def REMW    : ALUW_rr<0b0000001, 0b110, "remw">;
-def REMUW   : ALUW_rr<0b0000001, 0b111, "remuw">;
-} // Predicates = [HasStdExtM, IsRV64]
-
-//===----------------------------------------------------------------------===//
-// Pseudo-instructions and codegen patterns
-//===----------------------------------------------------------------------===//
-
-let Predicates = [HasStdExtM] in {
-def : PatGprGpr<mul, MUL>;
-def : PatGprGpr<mulhs, MULH>;
-def : PatGprGpr<mulhu, MULHU>;
-// No ISDOpcode for mulhsu
-def : PatGprGpr<sdiv, DIV>;
-def : PatGprGpr<udiv, DIVU>;
-def : PatGprGpr<srem, REM>;
-def : PatGprGpr<urem, REMU>;
-} // Predicates = [HasStdExtM]
diff --git a/lib/Target/RISCV/RISCVMCInstLower.cpp b/lib/Target/RISCV/RISCVMCInstLower.cpp
deleted file mode 100644
index b72b45c3dcc..00000000000
--- a/lib/Target/RISCV/RISCVMCInstLower.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-//===-- RISCVMCInstLower.cpp - Convert RISCV MachineInstr to an MCInst ------=//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains code to lower RISCV MachineInstrs to their corresponding
-// MCInst records.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "MCTargetDesc/RISCVMCExpr.h"
-#include "llvm/CodeGen/AsmPrinter.h"
-#include "llvm/CodeGen/MachineBasicBlock.h"
-#include "llvm/CodeGen/MachineInstr.h"
-#include "llvm/MC/MCAsmInfo.h"
-#include "llvm/MC/MCContext.h"
-#include "llvm/MC/MCExpr.h"
-#include "llvm/MC/MCInst.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/raw_ostream.h"
-
-using namespace llvm;
-
-static MCOperand lowerSymbolOperand(const MachineOperand &MO, MCSymbol *Sym,
-                                    const AsmPrinter &AP) {
-  MCContext &Ctx = AP.OutContext;
-  RISCVMCExpr::VariantKind Kind;
-
-  switch (MO.getTargetFlags()) {
-  default:
-    llvm_unreachable("Unknown target flag on GV operand");
-  case RISCVII::MO_None:
-    Kind = RISCVMCExpr::VK_RISCV_None;
-    break;
-  case RISCVII::MO_LO:
-    Kind = RISCVMCExpr::VK_RISCV_LO;
-    break;
-  case RISCVII::MO_HI:
-    Kind = RISCVMCExpr::VK_RISCV_HI;
-    break;
-  }
-
-  const MCExpr *ME =
-      MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, Ctx);
-
-  if (!MO.isJTI() && !MO.isMBB() && MO.getOffset())
-    ME = MCBinaryExpr::createAdd(
-        ME, MCConstantExpr::create(MO.getOffset(), Ctx), Ctx);
-
-  if (Kind != RISCVMCExpr::VK_RISCV_None)
-    ME = RISCVMCExpr::create(ME, Kind, Ctx);
-  return MCOperand::createExpr(ME);
-}
-
-bool llvm::LowerRISCVMachineOperandToMCOperand(const MachineOperand &MO,
-                                               MCOperand &MCOp,
-                                               const AsmPrinter &AP) {
-  switch (MO.getType()) {
-  default:
-    report_fatal_error("LowerRISCVMachineInstrToMCInst: unknown operand type");
-  case MachineOperand::MO_Register:
-    // Ignore all implicit register operands.
-    if (MO.isImplicit())
-      return false;
-    MCOp = MCOperand::createReg(MO.getReg());
-    break;
-  case MachineOperand::MO_RegisterMask:
-    // Regmasks are like implicit defs.
-    return false;
-  case MachineOperand::MO_Immediate:
-    MCOp = MCOperand::createImm(MO.getImm());
-    break;
-  case MachineOperand::MO_MachineBasicBlock:
-    MCOp = lowerSymbolOperand(MO, MO.getMBB()->getSymbol(), AP);
-    break;
-  case MachineOperand::MO_GlobalAddress:
-    MCOp = lowerSymbolOperand(MO, AP.getSymbol(MO.getGlobal()), AP);
-    break;
-  case MachineOperand::MO_BlockAddress:
-    MCOp = lowerSymbolOperand(
-        MO, AP.GetBlockAddressSymbol(MO.getBlockAddress()), AP);
-    break;
-  case MachineOperand::MO_ExternalSymbol:
-    MCOp = lowerSymbolOperand(
-        MO, AP.GetExternalSymbolSymbol(MO.getSymbolName()), AP);
-    break;
-  }
-  return true;
-}
-
-void llvm::LowerRISCVMachineInstrToMCInst(const MachineInstr *MI, MCInst &OutMI,
-                                          const AsmPrinter &AP) {
-  OutMI.setOpcode(MI->getOpcode());
-
-  for (const MachineOperand &MO : MI->operands()) {
-    MCOperand MCOp;
-    if (LowerRISCVMachineOperandToMCOperand(MO, MCOp, AP))
-      OutMI.addOperand(MCOp);
-  }
-}
diff --git a/lib/Target/RISCV/RISCVMachineFunctionInfo.h b/lib/Target/RISCV/RISCVMachineFunctionInfo.h
deleted file mode 100644
index 433a3fb1543..00000000000
--- a/lib/Target/RISCV/RISCVMachineFunctionInfo.h
+++ /dev/null
@@ -1,44 +0,0 @@
-//=- RISCVMachineFunctionInfo.h - RISCV machine function info -----*- C++ -*-=//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file declares RISCV-specific per-machine-function information.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVMACHINEFUNCTIONINFO_H
-#define LLVM_LIB_TARGET_RISCV_RISCVMACHINEFUNCTIONINFO_H
-
-#include "llvm/CodeGen/MachineFunction.h"
-
-namespace llvm {
-
-/// RISCVMachineFunctionInfo - This class is derived from MachineFunctionInfo
-/// and contains private RISCV-specific information for each MachineFunction.
-class RISCVMachineFunctionInfo : public MachineFunctionInfo {
-
-  /// FrameIndex for start of varargs area
-  int VarArgsFrameIndex = 0;
-  /// Size of the save area used for varargs
-  int VarArgsSaveSize = 0;
-
-public:
-  RISCVMachineFunctionInfo() = default;
-
-  explicit RISCVMachineFunctionInfo(MachineFunction &MF) {}
-
-  int getVarArgsFrameIndex() const { return VarArgsFrameIndex; }
-  void setVarArgsFrameIndex(int Index) { VarArgsFrameIndex = Index; }
-
-  unsigned getVarArgsSaveSize() const { return VarArgsSaveSize; }
-  void setVarArgsSaveSize(int Size) { VarArgsSaveSize = Size; }
-};
-
-} // end namespace llvm
-
-#endif // LLVM_LIB_TARGET_RISCV_RISCVMACHINEFUNCTIONINFO_H
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.cpp b/lib/Target/RISCV/RISCVRegisterInfo.cpp
deleted file mode 100644
index 6ad8bf7bca0..00000000000
--- a/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-//===-- RISCVRegisterInfo.cpp - RISCV Register Information ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetRegisterInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVRegisterInfo.h"
-#include "RISCV.h"
-#include "RISCVSubtarget.h"
-#include "llvm/CodeGen/MachineFrameInfo.h"
-#include "llvm/CodeGen/MachineFunction.h"
-#include "llvm/CodeGen/MachineInstrBuilder.h"
-#include "llvm/CodeGen/RegisterScavenging.h"
-#include "llvm/CodeGen/TargetFrameLowering.h"
-#include "llvm/CodeGen/TargetInstrInfo.h"
-#include "llvm/Support/ErrorHandling.h"
-
-#define GET_REGINFO_TARGET_DESC
-#include "RISCVGenRegisterInfo.inc"
-
-using namespace llvm;
-
-RISCVRegisterInfo::RISCVRegisterInfo(unsigned HwMode)
-    : RISCVGenRegisterInfo(RISCV::X1, /*DwarfFlavour*/0, /*EHFlavor*/0,
-                           /*PC*/0, HwMode) {}
-
-const MCPhysReg *
-RISCVRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
-  return CSR_SaveList;
-}
-
-BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
-  BitVector Reserved(getNumRegs());
-
-  // Use markSuperRegs to ensure any register aliases are also reserved
-  markSuperRegs(Reserved, RISCV::X0); // zero
-  markSuperRegs(Reserved, RISCV::X1); // ra
-  markSuperRegs(Reserved, RISCV::X2); // sp
-  markSuperRegs(Reserved, RISCV::X3); // gp
-  markSuperRegs(Reserved, RISCV::X4); // tp
-  markSuperRegs(Reserved, RISCV::X8); // fp
-  assert(checkAllSuperRegsMarked(Reserved));
-  return Reserved;
-}
-
-const uint32_t *RISCVRegisterInfo::getNoPreservedMask() const {
-  return CSR_NoRegs_RegMask;
-}
-
-void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
-                                            int SPAdj, unsigned FIOperandNum,
-                                            RegScavenger *RS) const {
-  assert(SPAdj == 0 && "Unexpected non-zero SPAdj value");
-
-  MachineInstr &MI = *II;
-  MachineFunction &MF = *MI.getParent()->getParent();
-  MachineRegisterInfo &MRI = MF.getRegInfo();
-  const RISCVInstrInfo *TII = MF.getSubtarget<RISCVSubtarget>().getInstrInfo();
-  DebugLoc DL = MI.getDebugLoc();
-
-  int FrameIndex = MI.getOperand(FIOperandNum).getIndex();
-  unsigned FrameReg;
-  int Offset =
-      getFrameLowering(MF)->getFrameIndexReference(MF, FrameIndex, FrameReg) +
-      MI.getOperand(FIOperandNum + 1).getImm();
-
-  if (!isInt<32>(Offset)) {
-    report_fatal_error(
-        "Frame offsets outside of the signed 32-bit range not supported");
-  }
-
-  MachineBasicBlock &MBB = *MI.getParent();
-  bool FrameRegIsKill = false;
-
-  if (!isInt<12>(Offset)) {
-    assert(isInt<32>(Offset) && "Int32 expected");
-    // The offset won't fit in an immediate, so use a scratch register instead
-    // Modify Offset and FrameReg appropriately
-    unsigned ScratchReg = MRI.createVirtualRegister(&RISCV::GPRRegClass);
-    TII->movImm32(MBB, II, DL, ScratchReg, Offset);
-    BuildMI(MBB, II, DL, TII->get(RISCV::ADD), ScratchReg)
-        .addReg(FrameReg)
-        .addReg(ScratchReg, RegState::Kill);
-    Offset = 0;
-    FrameReg = ScratchReg;
-    FrameRegIsKill = true;
-  }
-
-  MI.getOperand(FIOperandNum)
-      .ChangeToRegister(FrameReg, false, false, FrameRegIsKill);
-  MI.getOperand(FIOperandNum + 1).ChangeToImmediate(Offset);
-}
-
-unsigned RISCVRegisterInfo::getFrameRegister(const MachineFunction &MF) const {
-  const TargetFrameLowering *TFI = getFrameLowering(MF);
-  return TFI->hasFP(MF) ? RISCV::X8 : RISCV::X2;
-}
-
-const uint32_t *
-RISCVRegisterInfo::getCallPreservedMask(const MachineFunction & /*MF*/,
-                                        CallingConv::ID /*CC*/) const {
-  return CSR_RegMask;
-}
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.h b/lib/Target/RISCV/RISCVRegisterInfo.h
deleted file mode 100644
index a81dea09401..00000000000
--- a/lib/Target/RISCV/RISCVRegisterInfo.h
+++ /dev/null
@@ -1,57 +0,0 @@
-//===-- RISCVRegisterInfo.h - RISCV Register Information Impl ---*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file contains the RISCV implementation of the TargetRegisterInfo class.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVREGISTERINFO_H
-#define LLVM_LIB_TARGET_RISCV_RISCVREGISTERINFO_H
-
-#include "llvm/CodeGen/TargetRegisterInfo.h"
-
-#define GET_REGINFO_HEADER
-#include "RISCVGenRegisterInfo.inc"
-
-namespace llvm {
-
-struct RISCVRegisterInfo : public RISCVGenRegisterInfo {
-
-  RISCVRegisterInfo(unsigned HwMode);
-
-  const uint32_t *getCallPreservedMask(const MachineFunction &MF,
-                                       CallingConv::ID) const override;
-
-  const MCPhysReg *getCalleeSavedRegs(const MachineFunction *MF) const override;
-
-  BitVector getReservedRegs(const MachineFunction &MF) const override;
-
-  const uint32_t *getNoPreservedMask() const override;
-
-  void eliminateFrameIndex(MachineBasicBlock::iterator MI, int SPAdj,
-                           unsigned FIOperandNum,
-                           RegScavenger *RS = nullptr) const override;
-
-  unsigned getFrameRegister(const MachineFunction &MF) const override;
-
-  bool requiresRegisterScavenging(const MachineFunction &MF) const override {
-    return true;
-  }
-
-  bool requiresFrameIndexScavenging(const MachineFunction &MF) const override {
-    return true;
-  }
-
-  bool trackLivenessAfterRegAlloc(const MachineFunction &) const override {
-    return true;
-  }
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.td b/lib/Target/RISCV/RISCVRegisterInfo.td
deleted file mode 100644
index 21be2e332e5..00000000000
--- a/lib/Target/RISCV/RISCVRegisterInfo.td
+++ /dev/null
@@ -1,206 +0,0 @@
-//===-- RISCVRegisterInfo.td - RISC-V Register defs --------*- tablegen -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-//===----------------------------------------------------------------------===//
-//  Declarations that describe the RISC-V register files
-//===----------------------------------------------------------------------===//
-
-let Namespace = "RISCV" in {
-class RISCVReg<bits<5> Enc, string n, list<string> alt = []> : Register<n> {
-  let HWEncoding{4-0} = Enc;
-  let AltNames = alt;
-}
-
-class RISCVReg32<bits<5> Enc, string n, list<string> alt = []> : Register<n> {
-  let HWEncoding{4-0} = Enc;
-  let AltNames = alt;
-}
-
-// Because RISCVReg64 register have AsmName and AltNames that alias with their
-// 32-bit sub-register, RISCVAsmParser will need to coerce a register number
-// from a RISCVReg32 to the equivalent RISCVReg64 when appropriate.
-def sub_32 : SubRegIndex<32>;
-class RISCVReg64<RISCVReg32 subreg> : Register<""> {
-  let HWEncoding{4-0} = subreg.HWEncoding{4-0};
-  let SubRegs = [subreg];
-  let SubRegIndices = [sub_32];
-  let AsmName = subreg.AsmName;
-  let AltNames = subreg.AltNames;
-}
-
-def ABIRegAltName : RegAltNameIndex;
-} // Namespace = "RISCV"
-
-// Integer registers
-let RegAltNameIndices = [ABIRegAltName] in {
-  def X0  : RISCVReg<0, "x0", ["zero"]>, DwarfRegNum<[0]>;
-  def X1  : RISCVReg<1, "x1", ["ra"]>, DwarfRegNum<[1]>;
-  def X2  : RISCVReg<2, "x2", ["sp"]>, DwarfRegNum<[2]>;
-  def X3  : RISCVReg<3, "x3", ["gp"]>, DwarfRegNum<[3]>;
-  def X4  : RISCVReg<4, "x4", ["tp"]>, DwarfRegNum<[4]>;
-  def X5  : RISCVReg<5, "x5", ["t0"]>, DwarfRegNum<[5]>;
-  def X6  : RISCVReg<6, "x6", ["t1"]>, DwarfRegNum<[6]>;
-  def X7  : RISCVReg<7, "x7", ["t2"]>, DwarfRegNum<[7]>;
-  def X8  : RISCVReg<8, "x8", ["s0"]>, DwarfRegNum<[8]>;
-  def X9  : RISCVReg<9, "x9", ["s1"]>, DwarfRegNum<[9]>;
-  def X10 : RISCVReg<10,"x10", ["a0"]>, DwarfRegNum<[10]>;
-  def X11 : RISCVReg<11,"x11", ["a1"]>, DwarfRegNum<[11]>;
-  def X12 : RISCVReg<12,"x12", ["a2"]>, DwarfRegNum<[12]>;
-  def X13 : RISCVReg<13,"x13", ["a3"]>, DwarfRegNum<[13]>;
-  def X14 : RISCVReg<14,"x14", ["a4"]>, DwarfRegNum<[14]>;
-  def X15 : RISCVReg<15,"x15", ["a5"]>, DwarfRegNum<[15]>;
-  def X16 : RISCVReg<16,"x16", ["a6"]>, DwarfRegNum<[16]>;
-  def X17 : RISCVReg<17,"x17", ["a7"]>, DwarfRegNum<[17]>;
-  def X18 : RISCVReg<18,"x18", ["s2"]>, DwarfRegNum<[18]>;
-  def X19 : RISCVReg<19,"x19", ["s3"]>, DwarfRegNum<[19]>;
-  def X20 : RISCVReg<20,"x20", ["s4"]>, DwarfRegNum<[20]>;
-  def X21 : RISCVReg<21,"x21", ["s5"]>, DwarfRegNum<[21]>;
-  def X22 : RISCVReg<22,"x22", ["s6"]>, DwarfRegNum<[22]>;
-  def X23 : RISCVReg<23,"x23", ["s7"]>, DwarfRegNum<[23]>;
-  def X24 : RISCVReg<24,"x24", ["s8"]>, DwarfRegNum<[24]>;
-  def X25 : RISCVReg<25,"x25", ["s9"]>, DwarfRegNum<[25]>;
-  def X26 : RISCVReg<26,"x26", ["s10"]>, DwarfRegNum<[26]>;
-  def X27 : RISCVReg<27,"x27", ["s11"]>, DwarfRegNum<[27]>;
-  def X28 : RISCVReg<28,"x28", ["t3"]>, DwarfRegNum<[28]>;
-  def X29 : RISCVReg<29,"x29", ["t4"]>, DwarfRegNum<[29]>;
-  def X30 : RISCVReg<30,"x30", ["t5"]>, DwarfRegNum<[30]>;
-  def X31 : RISCVReg<31,"x31", ["t6"]>, DwarfRegNum<[31]>;
-}
-
-def XLenVT : ValueTypeByHwMode<[RV32, RV64, DefaultMode],
-                               [i32,  i64,  i32]>;
-
-// The order of registers represents the preferred allocation sequence.
-// Registers are listed in the order caller-save, callee-save, specials.
-def GPR : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 28, 31),
-    (sequence "X%u", 8, 9),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 0, 4)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-// The order of registers represents the preferred allocation sequence.
-// Registers are listed in the order caller-save, callee-save, specials.
-def GPRNoX0 : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 28, 31),
-    (sequence "X%u", 8, 9),
-    (sequence "X%u", 18, 27),
-    (sequence "X%u", 1, 4)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-def GPRNoX0X2 : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 17),
-    (sequence "X%u", 5, 7),
-    (sequence "X%u", 28, 31),
-    (sequence "X%u", 8, 9),
-    (sequence "X%u", 18, 27),
-    X1, X3, X4
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-def GPRC : RegisterClass<"RISCV", [XLenVT], 32, (add
-    (sequence "X%u", 10, 15),
-    (sequence "X%u", 8, 9)
-  )> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-def SP : RegisterClass<"RISCV", [XLenVT], 32, (add X2)> {
-  let RegInfos = RegInfoByHwMode<
-      [RV32,              RV64,              DefaultMode],
-      [RegInfo<32,32,32>, RegInfo<64,64,64>, RegInfo<32,32,32>]>;
-}
-
-// Floating point registers
-let RegAltNameIndices = [ABIRegAltName] in {
-  def F0_32  : RISCVReg32<0, "f0", ["ft0"]>, DwarfRegNum<[32]>;
-  def F1_32  : RISCVReg32<1, "f1", ["ft1"]>, DwarfRegNum<[33]>;
-  def F2_32  : RISCVReg32<2, "f2", ["ft2"]>, DwarfRegNum<[34]>;
-  def F3_32  : RISCVReg32<3, "f3", ["ft3"]>, DwarfRegNum<[35]>;
-  def F4_32  : RISCVReg32<4, "f4", ["ft4"]>, DwarfRegNum<[36]>;
-  def F5_32  : RISCVReg32<5, "f5", ["ft5"]>, DwarfRegNum<[37]>;
-  def F6_32  : RISCVReg32<6, "f6", ["ft6"]>, DwarfRegNum<[38]>;
-  def F7_32  : RISCVReg32<7, "f7", ["ft7"]>, DwarfRegNum<[39]>;
-  def F8_32  : RISCVReg32<8, "f8", ["fs0"]>, DwarfRegNum<[40]>;
-  def F9_32  : RISCVReg32<9, "f9", ["fs1"]>, DwarfRegNum<[41]>;
-  def F10_32 : RISCVReg32<10,"f10", ["fa0"]>, DwarfRegNum<[42]>;
-  def F11_32 : RISCVReg32<11,"f11", ["fa1"]>, DwarfRegNum<[43]>;
-  def F12_32 : RISCVReg32<12,"f12", ["fa2"]>, DwarfRegNum<[44]>;
-  def F13_32 : RISCVReg32<13,"f13", ["fa3"]>, DwarfRegNum<[45]>;
-  def F14_32 : RISCVReg32<14,"f14", ["fa4"]>, DwarfRegNum<[46]>;
-  def F15_32 : RISCVReg32<15,"f15", ["fa5"]>, DwarfRegNum<[47]>;
-  def F16_32 : RISCVReg32<16,"f16", ["fa6"]>, DwarfRegNum<[48]>;
-  def F17_32 : RISCVReg32<17,"f17", ["fa7"]>, DwarfRegNum<[49]>;
-  def F18_32 : RISCVReg32<18,"f18", ["fs2"]>, DwarfRegNum<[50]>;
-  def F19_32 : RISCVReg32<19,"f19", ["fs3"]>, DwarfRegNum<[51]>;
-  def F20_32 : RISCVReg32<20,"f20", ["fs4"]>, DwarfRegNum<[52]>;
-  def F21_32 : RISCVReg32<21,"f21", ["fs5"]>, DwarfRegNum<[53]>;
-  def F22_32 : RISCVReg32<22,"f22", ["fs6"]>, DwarfRegNum<[54]>;
-  def F23_32 : RISCVReg32<23,"f23", ["fs7"]>, DwarfRegNum<[55]>;
-  def F24_32 : RISCVReg32<24,"f24", ["fs8"]>, DwarfRegNum<[56]>;
-  def F25_32 : RISCVReg32<25,"f25", ["fs9"]>, DwarfRegNum<[57]>;
-  def F26_32 : RISCVReg32<26,"f26", ["fs10"]>, DwarfRegNum<[58]>;
-  def F27_32 : RISCVReg32<27,"f27", ["fs11"]>, DwarfRegNum<[59]>;
-  def F28_32 : RISCVReg32<28,"f28", ["ft8"]>, DwarfRegNum<[60]>;
-  def F29_32 : RISCVReg32<29,"f29", ["ft9"]>, DwarfRegNum<[61]>;
-  def F30_32 : RISCVReg32<30,"f30", ["ft10"]>, DwarfRegNum<[62]>;
-  def F31_32 : RISCVReg32<31,"f31", ["ft11"]>, DwarfRegNum<[63]>;
-
-  foreach Index = 0-31 in {
-    def F#Index#_64 : RISCVReg64<!cast<RISCVReg32>("F"#Index#"_32")>,
-      DwarfRegNum<[!add(Index, 32)]>;
-  }
-}
-
-// The order of registers represents the preferred allocation sequence,
-// meaning caller-save regs are listed before callee-save.
-def FPR32 : RegisterClass<"RISCV", [f32], 32, (add
-    (sequence "F%u_32", 0, 7),
-    (sequence "F%u_32", 10, 17),
-    (sequence "F%u_32", 28, 31),
-    (sequence "F%u_32", 8, 9),
-    (sequence "F%u_32", 18, 27)
-)>;
-
-def FPR32C : RegisterClass<"RISCV", [f32], 32, (add
-  (sequence "F%u_32", 10, 15),
-  (sequence "F%u_32", 8, 9)
-)>;
-
-// The order of registers represents the preferred allocation sequence,
-// meaning caller-save regs are listed before callee-save.
-def FPR64 : RegisterClass<"RISCV", [f64], 64, (add
-    (sequence "F%u_64", 0, 7),
-    (sequence "F%u_64", 10, 17),
-    (sequence "F%u_64", 28, 31),
-    (sequence "F%u_64", 8, 9),
-    (sequence "F%u_64", 18, 27)
-)>;
-
-def FPR64C : RegisterClass<"RISCV", [f64], 64, (add
-  (sequence "F%u_64", 10, 15),
-  (sequence "F%u_64", 8, 9)
-)>;
diff --git a/lib/Target/RISCV/RISCVSubtarget.cpp b/lib/Target/RISCV/RISCVSubtarget.cpp
deleted file mode 100644
index b221ea84a33..00000000000
--- a/lib/Target/RISCV/RISCVSubtarget.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//===-- RISCVSubtarget.cpp - RISCV Subtarget Information ------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file implements the RISCV specific subclass of TargetSubtargetInfo.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCVSubtarget.h"
-#include "RISCV.h"
-#include "RISCVFrameLowering.h"
-#include "llvm/Support/TargetRegistry.h"
-
-using namespace llvm;
-
-#define DEBUG_TYPE "riscv-subtarget"
-
-#define GET_SUBTARGETINFO_TARGET_DESC
-#define GET_SUBTARGETINFO_CTOR
-#include "RISCVGenSubtargetInfo.inc"
-
-void RISCVSubtarget::anchor() {}
-
-RISCVSubtarget &RISCVSubtarget::initializeSubtargetDependencies(StringRef CPU,
-                                                                StringRef FS,
-                                                                bool Is64Bit) {
-  // Determine default and user-specified characteristics
-  std::string CPUName = CPU;
-  if (CPUName.empty())
-    CPUName = Is64Bit ? "generic-rv64" : "generic-rv32";
-  ParseSubtargetFeatures(CPUName, FS);
-  if (Is64Bit) {
-    XLenVT = MVT::i64;
-    XLen = 64;
-  }
-  return *this;
-}
-
-RISCVSubtarget::RISCVSubtarget(const Triple &TT, const std::string &CPU,
-                               const std::string &FS, const TargetMachine &TM)
-    : RISCVGenSubtargetInfo(TT, CPU, FS),
-      FrameLowering(initializeSubtargetDependencies(CPU, FS, TT.isArch64Bit())),
-      InstrInfo(), RegInfo(getHwMode()), TLInfo(TM, *this) {}
diff --git a/lib/Target/RISCV/RISCVSubtarget.h b/lib/Target/RISCV/RISCVSubtarget.h
deleted file mode 100644
index 928ba5815a2..00000000000
--- a/lib/Target/RISCV/RISCVSubtarget.h
+++ /dev/null
@@ -1,85 +0,0 @@
-//===-- RISCVSubtarget.h - Define Subtarget for the RISCV -------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file declares the RISCV specific subclass of TargetSubtargetInfo.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVSUBTARGET_H
-#define LLVM_LIB_TARGET_RISCV_RISCVSUBTARGET_H
-
-#include "RISCVFrameLowering.h"
-#include "RISCVISelLowering.h"
-#include "RISCVInstrInfo.h"
-#include "llvm/CodeGen/SelectionDAGTargetInfo.h"
-#include "llvm/CodeGen/TargetSubtargetInfo.h"
-#include "llvm/IR/DataLayout.h"
-#include "llvm/Target/TargetMachine.h"
-
-#define GET_SUBTARGETINFO_HEADER
-#include "RISCVGenSubtargetInfo.inc"
-
-namespace llvm {
-class StringRef;
-
-class RISCVSubtarget : public RISCVGenSubtargetInfo {
-  virtual void anchor();
-  bool HasStdExtM = false;
-  bool HasStdExtA = false;
-  bool HasStdExtF = false;
-  bool HasStdExtD = false;
-  bool HasStdExtC = false;
-  bool HasRV64 = false;
-  unsigned XLen = 32;
-  MVT XLenVT = MVT::i32;
-  RISCVFrameLowering FrameLowering;
-  RISCVInstrInfo InstrInfo;
-  RISCVRegisterInfo RegInfo;
-  RISCVTargetLowering TLInfo;
-  SelectionDAGTargetInfo TSInfo;
-
-  /// Initializes using the passed in CPU and feature strings so that we can
-  /// use initializer lists for subtarget initialization.
-  RISCVSubtarget &initializeSubtargetDependencies(StringRef CPU, StringRef FS,
-                                                  bool Is64Bit);
-
-public:
-  // Initializes the data members to match that of the specified triple.
-  RISCVSubtarget(const Triple &TT, const std::string &CPU,
-                 const std::string &FS, const TargetMachine &TM);
-
-  // Parses features string setting specified subtarget options. The
-  // definition of this function is auto-generated by tblgen.
-  void ParseSubtargetFeatures(StringRef CPU, StringRef FS);
-
-  const RISCVFrameLowering *getFrameLowering() const override {
-    return &FrameLowering;
-  }
-  const RISCVInstrInfo *getInstrInfo() const override { return &InstrInfo; }
-  const RISCVRegisterInfo *getRegisterInfo() const override {
-    return &RegInfo;
-  }
-  const RISCVTargetLowering *getTargetLowering() const override {
-    return &TLInfo;
-  }
-  const SelectionDAGTargetInfo *getSelectionDAGInfo() const override {
-    return &TSInfo;
-  }
-  bool hasStdExtM() const { return HasStdExtM; }
-  bool hasStdExtA() const { return HasStdExtA; }
-  bool hasStdExtF() const { return HasStdExtF; }
-  bool hasStdExtD() const { return HasStdExtD; }
-  bool hasStdExtC() const { return HasStdExtC; }
-  bool is64Bit() const { return HasRV64; }
-  MVT getXLenVT() const { return XLenVT; }
-  unsigned getXLen() const { return XLen; }
-};
-} // End llvm namespace
-
-#endif
diff --git a/lib/Target/RISCV/RISCVTargetMachine.cpp b/lib/Target/RISCV/RISCVTargetMachine.cpp
deleted file mode 100644
index e75fb3b701c..00000000000
--- a/lib/Target/RISCV/RISCVTargetMachine.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-//===-- RISCVTargetMachine.cpp - Define TargetMachine for RISCV -----------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// Implements the info about RISCV target spec.
-//
-//===----------------------------------------------------------------------===//
-
-#include "RISCV.h"
-#include "RISCVTargetMachine.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/CodeGen/Passes.h"
-#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
-#include "llvm/CodeGen/TargetPassConfig.h"
-#include "llvm/IR/LegacyPassManager.h"
-#include "llvm/Support/FormattedStream.h"
-#include "llvm/Support/TargetRegistry.h"
-#include "llvm/Target/TargetOptions.h"
-using namespace llvm;
-
-extern "C" void LLVMInitializeRISCVTarget() {
-  RegisterTargetMachine<RISCVTargetMachine> X(getTheRISCV32Target());
-  RegisterTargetMachine<RISCVTargetMachine> Y(getTheRISCV64Target());
-}
-
-static std::string computeDataLayout(const Triple &TT) {
-  if (TT.isArch64Bit()) {
-    return "e-m:e-p:64:64-i64:64-i128:128-n64-S128";
-  } else {
-    assert(TT.isArch32Bit() && "only RV32 and RV64 are currently supported");
-    return "e-m:e-p:32:32-i64:64-n32-S128";
-  }
-}
-
-static Reloc::Model getEffectiveRelocModel(const Triple &TT,
-                                           Optional<Reloc::Model> RM) {
-  if (!RM.hasValue())
-    return Reloc::Static;
-  return *RM;
-}
-
-static CodeModel::Model getEffectiveCodeModel(Optional<CodeModel::Model> CM) {
-  if (CM)
-    return *CM;
-  return CodeModel::Small;
-}
-
-RISCVTargetMachine::RISCVTargetMachine(const Target &T, const Triple &TT,
-                                       StringRef CPU, StringRef FS,
-                                       const TargetOptions &Options,
-                                       Optional<Reloc::Model> RM,
-                                       Optional<CodeModel::Model> CM,
-                                       CodeGenOpt::Level OL, bool JIT)
-    : LLVMTargetMachine(T, computeDataLayout(TT), TT, CPU, FS, Options,
-                        getEffectiveRelocModel(TT, RM),
-                        getEffectiveCodeModel(CM), OL),
-      TLOF(make_unique<TargetLoweringObjectFileELF>()),
-      Subtarget(TT, CPU, FS, *this) {
-  initAsmInfo();
-}
-
-namespace {
-class RISCVPassConfig : public TargetPassConfig {
-public:
-  RISCVPassConfig(RISCVTargetMachine &TM, PassManagerBase &PM)
-      : TargetPassConfig(TM, PM) {}
-
-  RISCVTargetMachine &getRISCVTargetMachine() const {
-    return getTM<RISCVTargetMachine>();
-  }
-
-  bool addInstSelector() override;
-  void addPreEmitPass() override;
-};
-}
-
-TargetPassConfig *RISCVTargetMachine::createPassConfig(PassManagerBase &PM) {
-  return new RISCVPassConfig(*this, PM);
-}
-
-bool RISCVPassConfig::addInstSelector() {
-  addPass(createRISCVISelDag(getRISCVTargetMachine()));
-
-  return false;
-}
-
-void RISCVPassConfig::addPreEmitPass() { addPass(&BranchRelaxationPassID); }
diff --git a/lib/Target/RISCV/RISCVTargetMachine.h b/lib/Target/RISCV/RISCVTargetMachine.h
deleted file mode 100644
index 02361dddebf..00000000000
--- a/lib/Target/RISCV/RISCVTargetMachine.h
+++ /dev/null
@@ -1,46 +0,0 @@
-//===-- RISCVTargetMachine.h - Define TargetMachine for RISCV ---*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This file declares the RISCV specific subclass of TargetMachine.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_LIB_TARGET_RISCV_RISCVTARGETMACHINE_H
-#define LLVM_LIB_TARGET_RISCV_RISCVTARGETMACHINE_H
-
-#include "MCTargetDesc/RISCVMCTargetDesc.h"
-#include "RISCVSubtarget.h"
-#include "llvm/CodeGen/SelectionDAGTargetInfo.h"
-#include "llvm/IR/DataLayout.h"
-#include "llvm/Target/TargetMachine.h"
-
-namespace llvm {
-class RISCVTargetMachine : public LLVMTargetMachine {
-  std::unique_ptr<TargetLoweringObjectFile> TLOF;
-  RISCVSubtarget Subtarget;
-
-public:
-  RISCVTargetMachine(const Target &T, const Triple &TT, StringRef CPU,
-                     StringRef FS, const TargetOptions &Options,
-                     Optional<Reloc::Model> RM, Optional<CodeModel::Model> CM,
-                     CodeGenOpt::Level OL, bool JIT);
-
-  const RISCVSubtarget *getSubtargetImpl(const Function &) const override {
-    return &Subtarget;
-  }
-
-  TargetPassConfig *createPassConfig(PassManagerBase &PM) override;
-
-  TargetLoweringObjectFile *getObjFileLowering() const override {
-    return TLOF.get();
-  }
-};
-}
-
-#endif
diff --git a/lib/Target/RISCV/TargetInfo/CMakeLists.txt b/lib/Target/RISCV/TargetInfo/CMakeLists.txt
deleted file mode 100644
index f440fe2cb82..00000000000
--- a/lib/Target/RISCV/TargetInfo/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-add_llvm_library(LLVMRISCVInfo
-  RISCVTargetInfo.cpp
-  )
diff --git a/lib/Target/RISCV/TargetInfo/LLVMBuild.txt b/lib/Target/RISCV/TargetInfo/LLVMBuild.txt
deleted file mode 100644
index db7f66f94bf..00000000000
--- a/lib/Target/RISCV/TargetInfo/LLVMBuild.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-;===- ./lib/Target/RISCV/TargetInfo/LLVMBuild.txt --------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Library
-name = RISCVInfo
-parent = RISCV
-required_libraries = Support
-add_to_library_groups = RISCV
diff --git a/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp b/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp
deleted file mode 100644
index 0f369d960fe..00000000000
--- a/lib/Target/RISCV/TargetInfo/RISCVTargetInfo.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-//===-- RISCVTargetInfo.cpp - RISCV Target Implementation -----------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "llvm/Support/TargetRegistry.h"
-using namespace llvm;
-
-namespace llvm {
-Target &getTheRISCV32Target() {
-  static Target TheRISCV32Target;
-  return TheRISCV32Target;
-}
-
-Target &getTheRISCV64Target() {
-  static Target TheRISCV64Target;
-  return TheRISCV64Target;
-}
-}
-
-extern "C" void LLVMInitializeRISCVTargetInfo() {
-  RegisterTarget<Triple::riscv32> X(getTheRISCV32Target(), "riscv32",
-                                    "32-bit RISC-V", "RISCV");
-  RegisterTarget<Triple::riscv64> Y(getTheRISCV64Target(), "riscv64",
-                                    "64-bit RISC-V", "RISCV");
-}
diff --git a/test/CodeGen/RISCV/addc-adde-sube-subc.ll b/test/CodeGen/RISCV/addc-adde-sube-subc.ll
deleted file mode 100644
index 7c28df4c30f..00000000000
--- a/test/CodeGen/RISCV/addc-adde-sube-subc.ll
+++ /dev/null
@@ -1,30 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-; Ensure that the ISDOpcodes ADDC, ADDE, SUBC, SUBE are handled correctly
-
-define i64 @addc_adde(i64 %a, i64 %b) {
-; RV32I-LABEL: addc_adde:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a1, a1, a3
-; RV32I-NEXT:    add a2, a0, a2
-; RV32I-NEXT:    sltu a0, a2, a0
-; RV32I-NEXT:    add a1, a1, a0
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %1 = add i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @subc_sube(i64 %a, i64 %b) {
-; RV32I-LABEL: subc_sube:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a1, a1, a3
-; RV32I-NEXT:    sltu a3, a0, a2
-; RV32I-NEXT:    sub a1, a1, a3
-; RV32I-NEXT:    sub a0, a0, a2
-; RV32I-NEXT:    ret
-  %1 = sub i64 %a, %b
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/alloca.ll b/test/CodeGen/RISCV/alloca.ll
deleted file mode 100644
index 1472e8a302c..00000000000
--- a/test/CodeGen/RISCV/alloca.ll
+++ /dev/null
@@ -1,65 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-declare void @notdead(i8*)
-
-; These tests must ensure the stack pointer is restored using the frame
-; pointer
-
-define void @simple_alloca(i32 %n) nounwind {
-; RV32I-LABEL: simple_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    addi a0, a0, 15
-; RV32I-NEXT:    andi a0, a0, -16
-; RV32I-NEXT:    sub a0, sp, a0
-; RV32I-NEXT:    mv sp, a0
-; RV32I-NEXT:    lui a1, %hi(notdead)
-; RV32I-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    addi sp, s0, -16
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = alloca i8, i32 %n
-  call void @notdead(i8* %1)
-  ret void
-}
-
-declare i8* @llvm.stacksave()
-declare void @llvm.stackrestore(i8*)
-
-define void @scoped_alloca(i32 %n) nounwind {
-; RV32I-LABEL: scoped_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    sw s1, 4(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    mv s1, sp
-; RV32I-NEXT:    addi a0, a0, 15
-; RV32I-NEXT:    andi a0, a0, -16
-; RV32I-NEXT:    sub a0, sp, a0
-; RV32I-NEXT:    mv sp, a0
-; RV32I-NEXT:    lui a1, %hi(notdead)
-; RV32I-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    mv sp, s1
-; RV32I-NEXT:    addi sp, s0, -16
-; RV32I-NEXT:    lw s1, 4(sp)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %sp = call i8* @llvm.stacksave()
-  %addr = alloca i8, i32 %n
-  call void @notdead(i8* %addr)
-  call void @llvm.stackrestore(i8* %sp)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/alu32.ll b/test/CodeGen/RISCV/alu32.ll
deleted file mode 100644
index 6ecd08878dd..00000000000
--- a/test/CodeGen/RISCV/alu32.ll
+++ /dev/null
@@ -1,186 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; These tests are each targeted at a particular RISC-V ALU instruction. Other
-; files in this folder exercise LLVM IR instructions that don't directly match a
-; RISC-V instruction
-
-; Register-immediate instructions
-
-define i32 @addi(i32 %a) nounwind {
-; RV32I-LABEL: addi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = add i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @slti(i32 %a) nounwind {
-; RV32I-LABEL: slti:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slti a0, a0, 2
-; RV32I-NEXT:    ret
-  %1 = icmp slt i32 %a, 2
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @sltiu(i32 %a) nounwind {
-; RV32I-LABEL: sltiu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltiu a0, a0, 3
-; RV32I-NEXT:    ret
-  %1 = icmp ult i32 %a, 3
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @xori(i32 %a) nounwind {
-; RV32I-LABEL: xori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xori a0, a0, 4
-; RV32I-NEXT:    ret
-  %1 = xor i32 %a, 4
-  ret i32 %1
-}
-
-define i32 @ori(i32 %a) nounwind {
-; RV32I-LABEL: ori:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ori a0, a0, 5
-; RV32I-NEXT:    ret
-  %1 = or i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @andi(i32 %a) nounwind {
-; RV32I-LABEL: andi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 6
-; RV32I-NEXT:    ret
-  %1 = and i32 %a, 6
-  ret i32 %1
-}
-
-define i32 @slli(i32 %a) nounwind {
-; RV32I-LABEL: slli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 7
-; RV32I-NEXT:    ret
-  %1 = shl i32 %a, 7
-  ret i32 %1
-}
-
-define i32 @srli(i32 %a) nounwind {
-; RV32I-LABEL: srli:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 8
-; RV32I-NEXT:    ret
-  %1 = lshr i32 %a, 8
-  ret i32 %1
-}
-
-define i32 @srai(i32 %a) nounwind {
-; RV32I-LABEL: srai:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a0, a0, 9
-; RV32I-NEXT:    ret
-  %1 = ashr i32 %a, 9
-  ret i32 %1
-}
-
-; Register-register instructions
-
-define i32 @add(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: add:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = add i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sub(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sub:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = sub i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sll(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sll:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sll a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = shl i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @slt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = icmp slt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @sltu(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sltu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = icmp ult i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @xor(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: xor:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = xor i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @srl(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: srl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srl a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = lshr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sra(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sra:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sra a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = ashr i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @or(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: or:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = or i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @and(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: and:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = and i32 %a, %b
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/analyze-branch.ll b/test/CodeGen/RISCV/analyze-branch.ll
deleted file mode 100644
index bf34a0d9f9f..00000000000
--- a/test/CodeGen/RISCV/analyze-branch.ll
+++ /dev/null
@@ -1,85 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-; This test checks that LLVM can do basic stripping and reapplying of branches
-; to basic blocks.
-
-declare void @test_true()
-declare void @test_false()
-
-; !0 corresponds to a branch being taken, !1 to not being takne.
-!0 = !{!"branch_weights", i32 64, i32 4}
-!1 = !{!"branch_weights", i32 4, i32 64}
-
-define void @test_bcc_fallthrough_taken(i32 %in) nounwind {
-; RV32I-LABEL: test_bcc_fallthrough_taken:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 42
-; RV32I-NEXT:    bne a0, a1, .LBB0_3
-; RV32I-NEXT:  # %bb.1: # %true
-; RV32I-NEXT:    lui a0, %hi(test_true)
-; RV32I-NEXT:    addi a0, a0, %lo(test_true)
-; RV32I-NEXT:  .LBB0_2: # %true
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_3: # %false
-; RV32I-NEXT:    lui a0, %hi(test_false)
-; RV32I-NEXT:    addi a0, a0, %lo(test_false)
-; RV32I-NEXT:    j .LBB0_2
-  %tst = icmp eq i32 %in, 42
-  br i1 %tst, label %true, label %false, !prof !0
-
-; Expected layout order is: Entry, TrueBlock, FalseBlock
-; Entry->TrueBlock is the common path, which should be taken whenever the
-; conditional branch is false.
-
-true:
-  call void @test_true()
-  ret void
-
-false:
-  call void @test_false()
-  ret void
-}
-
-define void @test_bcc_fallthrough_nottaken(i32 %in) nounwind {
-; RV32I-LABEL: test_bcc_fallthrough_nottaken:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, zero, 42
-; RV32I-NEXT:    beq a0, a1, .LBB1_3
-; RV32I-NEXT:  # %bb.1: # %false
-; RV32I-NEXT:    lui a0, %hi(test_false)
-; RV32I-NEXT:    addi a0, a0, %lo(test_false)
-; RV32I-NEXT:  .LBB1_2: # %true
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB1_3: # %true
-; RV32I-NEXT:    lui a0, %hi(test_true)
-; RV32I-NEXT:    addi a0, a0, %lo(test_true)
-; RV32I-NEXT:    j .LBB1_2
-  %tst = icmp eq i32 %in, 42
-  br i1 %tst, label %true, label %false, !prof !1
-
-; Expected layout order is: Entry, FalseBlock, TrueBlock
-; Entry->FalseBlock is the common path, which should be taken whenever the
-; conditional branch is false
-
-true:
-  call void @test_true()
-  ret void
-
-false:
-  call void @test_false()
-  ret void
-}
-
-; TODO: how can we expand the coverage of the branch analysis functions?
diff --git a/test/CodeGen/RISCV/bare-select.ll b/test/CodeGen/RISCV/bare-select.ll
deleted file mode 100644
index 3b7287ff679..00000000000
--- a/test/CodeGen/RISCV/bare-select.ll
+++ /dev/null
@@ -1,17 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define i32 @bare_select(i1 %a, i32 %b, i32 %c) {
-; RV32I-LABEL: bare_select:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    bnez a0, .LBB0_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    mv a1, a2
-; RV32I-NEXT:  .LBB0_2:
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = select i1 %a, i32 %b, i32 %c
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/blockaddress.ll b/test/CodeGen/RISCV/blockaddress.ll
deleted file mode 100644
index 9099251f0d2..00000000000
--- a/test/CodeGen/RISCV/blockaddress.ll
+++ /dev/null
@@ -1,30 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-@addr = global i8* null
-
-define void @test_blockaddress() nounwind {
-; RV32I-LABEL: test_blockaddress:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(addr)
-; RV32I-NEXT:    addi a0, a0, %lo(addr)
-; RV32I-NEXT:    lui a1, %hi(.Ltmp0)
-; RV32I-NEXT:    addi a1, a1, %lo(.Ltmp0)
-; RV32I-NEXT:    sw a1, 0(a0)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    jr a0
-; RV32I-NEXT:  .Ltmp0: # Block address taken
-; RV32I-NEXT:  .LBB0_1: # %block
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  store volatile i8* blockaddress(@test_blockaddress, %block), i8** @addr
-  %val = load volatile i8*, i8** @addr
-  indirectbr i8* %val, [label %block]
-
-block:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/branch-relaxation.ll b/test/CodeGen/RISCV/branch-relaxation.ll
deleted file mode 100644
index 2be50d10ae9..00000000000
--- a/test/CodeGen/RISCV/branch-relaxation.ll
+++ /dev/null
@@ -1,65 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -filetype=obj < %s \
-; RUN:   -o /dev/null 2>&1
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s | FileCheck %s
-
-define void @relax_bcc(i1 %a) {
-; CHECK-LABEL: relax_bcc:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    andi a0, a0, 1
-; CHECK-NEXT:    bnez a0, .LBB0_1
-; CHECK-NEXT:    j .LBB0_2
-; CHECK-NEXT:  .LBB0_1: # %iftrue
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    .space 4096
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:  .LBB0_2: # %tail
-; CHECK-NEXT:    ret
-  br i1 %a, label %iftrue, label %tail
-
-iftrue:
-  call void asm sideeffect ".space 4096", ""()
-  br label %tail
-
-tail:
-  ret void
-}
-
-define i32 @relax_jal(i1 %a) {
-; CHECK-LABEL: relax_jal:
-; CHECK:       # %bb.0:
-; CHECK-NEXT:    andi a0, a0, 1
-; CHECK-NEXT:    bnez a0, .LBB1_1
-; CHECK-NEXT:  # %bb.3:
-; CHECK-NEXT:    lui a0, %hi(.LBB1_2)
-; CHECK-NEXT:    jalr zero, a0, %lo(.LBB1_2)
-; CHECK-NEXT:  .LBB1_1: # %iftrue
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    .space 1048576
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:    addi a0, zero, 1
-; CHECK-NEXT:    ret
-; CHECK-NEXT:  .LBB1_2: # %jmp
-; CHECK-NEXT:    #APP
-; CHECK-NEXT:    #NO_APP
-; CHECK-NEXT:    addi a0, zero, 1
-; CHECK-NEXT:    ret
-  br i1 %a, label %iftrue, label %jmp
-
-jmp:
-  call void asm sideeffect "", ""()
-  br label %tail
-
-iftrue:
-  call void asm sideeffect "", ""()
-  br label %space
-
-space:
-  call void asm sideeffect ".space 1048576", ""()
-  br label %tail
-
-tail:
-  ret i32 1
-}
diff --git a/test/CodeGen/RISCV/branch.ll b/test/CodeGen/RISCV/branch.ll
deleted file mode 100644
index 53092c37561..00000000000
--- a/test/CodeGen/RISCV/branch.ll
+++ /dev/null
@@ -1,110 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define void @foo(i32 %a, i32 *%b, i1 %c) {
-; RV32I-LABEL: foo:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    beq a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.1: # %test2
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bne a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.2: # %test3
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    blt a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.3: # %test4
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bge a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.4: # %test5
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bltu a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.5: # %test6
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bgeu a3, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.6: # %test7
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    blt a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.7: # %test8
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bge a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.8: # %test9
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bltu a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.9: # %test10
-; RV32I-NEXT:    lw a3, 0(a1)
-; RV32I-NEXT:    bgeu a0, a3, .LBB0_12
-; RV32I-NEXT:  # %bb.10: # %test11
-; RV32I-NEXT:    lw a0, 0(a1)
-; RV32I-NEXT:    andi a0, a2, 1
-; RV32I-NEXT:    bnez a0, .LBB0_12
-; RV32I-NEXT:  # %bb.11: # %test12
-; RV32I-NEXT:    lw a0, 0(a1)
-; RV32I-NEXT:  .LBB0_12: # %end
-; RV32I-NEXT:    ret
-
-  %val1 = load volatile i32, i32* %b
-  %tst1 = icmp eq i32 %val1, %a
-  br i1 %tst1, label %end, label %test2
-
-test2:
-  %val2 = load volatile i32, i32* %b
-  %tst2 = icmp ne i32 %val2, %a
-  br i1 %tst2, label %end, label %test3
-
-test3:
-  %val3 = load volatile i32, i32* %b
-  %tst3 = icmp slt i32 %val3, %a
-  br i1 %tst3, label %end, label %test4
-
-test4:
-  %val4 = load volatile i32, i32* %b
-  %tst4 = icmp sge i32 %val4, %a
-  br i1 %tst4, label %end, label %test5
-
-test5:
-  %val5 = load volatile i32, i32* %b
-  %tst5 = icmp ult i32 %val5, %a
-  br i1 %tst5, label %end, label %test6
-
-test6:
-  %val6 = load volatile i32, i32* %b
-  %tst6 = icmp uge i32 %val6, %a
-  br i1 %tst6, label %end, label %test7
-
-; Check for condition codes that don't have a matching instruction
-
-test7:
-  %val7 = load volatile i32, i32* %b
-  %tst7 = icmp sgt i32 %val7, %a
-  br i1 %tst7, label %end, label %test8
-
-test8:
-  %val8 = load volatile i32, i32* %b
-  %tst8 = icmp sle i32 %val8, %a
-  br i1 %tst8, label %end, label %test9
-
-test9:
-  %val9 = load volatile i32, i32* %b
-  %tst9 = icmp ugt i32 %val9, %a
-  br i1 %tst9, label %end, label %test10
-
-test10:
-  %val10 = load volatile i32, i32* %b
-  %tst10 = icmp ule i32 %val10, %a
-  br i1 %tst10, label %end, label %test11
-
-; Check the case of a branch where the condition was generated in another
-; function
-
-test11:
-  %val11 = load volatile i32, i32* %b
-  br i1 %c, label %end, label %test12
-
-test12:
-  %val12 = load volatile i32, i32* %b
-  br label %end
-
-end:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll b/test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll
deleted file mode 100644
index 1fbc429cae4..00000000000
--- a/test/CodeGen/RISCV/bswap-ctlz-cttz-ctpop.ll
+++ /dev/null
@@ -1,569 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-declare i16 @llvm.bswap.i16(i16)
-declare i32 @llvm.bswap.i32(i32)
-declare i64 @llvm.bswap.i64(i64)
-declare i8 @llvm.cttz.i8(i8, i1)
-declare i16 @llvm.cttz.i16(i16, i1)
-declare i32 @llvm.cttz.i32(i32, i1)
-declare i64 @llvm.cttz.i64(i64, i1)
-declare i32 @llvm.ctlz.i32(i32, i1)
-declare i32 @llvm.ctpop.i32(i32)
-
-define i16 @test_bswap_i16(i16 %a) nounwind {
-; RV32I-LABEL: test_bswap_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 4080
-; RV32I-NEXT:    mv a1, a1
-; RV32I-NEXT:    slli a2, a0, 8
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a0, a0, 16
-; RV32I-NEXT:    ret
-  %tmp = call i16 @llvm.bswap.i16(i16 %a)
-  ret i16 %tmp
-}
-
-define i32 @test_bswap_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_bswap_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -256
-; RV32I-NEXT:    srli a2, a0, 8
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    srli a2, a0, 24
-; RV32I-NEXT:    or a1, a1, a2
-; RV32I-NEXT:    lui a2, 4080
-; RV32I-NEXT:    mv a2, a2
-; RV32I-NEXT:    slli a3, a0, 8
-; RV32I-NEXT:    and a2, a3, a2
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    or a0, a0, a2
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.bswap.i32(i32 %a)
-  ret i32 %tmp
-}
-
-define i64 @test_bswap_i64(i64 %a) nounwind {
-; RV32I-LABEL: test_bswap_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a2, 16
-; RV32I-NEXT:    addi a3, a2, -256
-; RV32I-NEXT:    srli a2, a1, 8
-; RV32I-NEXT:    and a2, a2, a3
-; RV32I-NEXT:    srli a4, a1, 24
-; RV32I-NEXT:    or a2, a2, a4
-; RV32I-NEXT:    lui a4, 4080
-; RV32I-NEXT:    mv a4, a4
-; RV32I-NEXT:    slli a5, a1, 8
-; RV32I-NEXT:    and a5, a5, a4
-; RV32I-NEXT:    slli a1, a1, 24
-; RV32I-NEXT:    or a1, a1, a5
-; RV32I-NEXT:    or a2, a1, a2
-; RV32I-NEXT:    srli a1, a0, 8
-; RV32I-NEXT:    and a1, a1, a3
-; RV32I-NEXT:    srli a3, a0, 24
-; RV32I-NEXT:    or a1, a1, a3
-; RV32I-NEXT:    slli a3, a0, 8
-; RV32I-NEXT:    and a3, a3, a4
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    or a0, a0, a3
-; RV32I-NEXT:    or a1, a0, a1
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %tmp = call i64 @llvm.bswap.i64(i64 %a)
-  ret i64 %tmp
-}
-
-define i8 @test_cttz_i8(i8 %a) nounwind {
-; RV32I-LABEL: test_cttz_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    andi a1, a0, 255
-; RV32I-NEXT:    beqz a1, .LBB3_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB3_3
-; RV32I-NEXT:  .LBB3_2:
-; RV32I-NEXT:    addi a0, zero, 8
-; RV32I-NEXT:  .LBB3_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i8 @llvm.cttz.i8(i8 %a, i1 false)
-  ret i8 %tmp
-}
-
-define i16 @test_cttz_i16(i16 %a) nounwind {
-; RV32I-LABEL: test_cttz_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a1, a0, a1
-; RV32I-NEXT:    beqz a1, .LBB4_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB4_3
-; RV32I-NEXT:  .LBB4_2:
-; RV32I-NEXT:    addi a0, zero, 16
-; RV32I-NEXT:  .LBB4_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i16 @llvm.cttz.i16(i16 %a, i1 false)
-  ret i16 %tmp
-}
-
-define i32 @test_cttz_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_cttz_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB5_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB5_3
-; RV32I-NEXT:  .LBB5_2:
-; RV32I-NEXT:    addi a0, zero, 32
-; RV32I-NEXT:  .LBB5_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.cttz.i32(i32 %a, i1 false)
-  ret i32 %tmp
-}
-
-define i32 @test_ctlz_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_ctlz_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    beqz a0, .LBB6_2
-; RV32I-NEXT:  # %bb.1: # %cond.false
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 2
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 8
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    srli a1, a0, 16
-; RV32I-NEXT:    or a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    j .LBB6_3
-; RV32I-NEXT:  .LBB6_2:
-; RV32I-NEXT:    addi a0, zero, 32
-; RV32I-NEXT:  .LBB6_3: # %cond.end
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.ctlz.i32(i32 %a, i1 false)
-  ret i32 %tmp
-}
-
-define i64 @test_cttz_i64(i64 %a) nounwind {
-; RV32I-LABEL: test_cttz_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    sw s7, 16(sp)
-; RV32I-NEXT:    sw s8, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    addi a0, a0, -1
-; RV32I-NEXT:    not a1, s3
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi s5, a1, 1365
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi s6, a1, 819
-; RV32I-NEXT:    and a1, a0, s6
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s6
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi s4, a1, 257
-; RV32I-NEXT:    lui a1, %hi(__mulsi3)
-; RV32I-NEXT:    addi s7, a1, %lo(__mulsi3)
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi s8, a1, -241
-; RV32I-NEXT:    and a0, a0, s8
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    jalr s7
-; RV32I-NEXT:    mv s1, a0
-; RV32I-NEXT:    addi a0, s2, -1
-; RV32I-NEXT:    not a1, s2
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    and a1, a0, s6
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s6
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    and a0, a0, s8
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    jalr s7
-; RV32I-NEXT:    bnez s3, .LBB7_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    addi a0, a0, 32
-; RV32I-NEXT:    j .LBB7_3
-; RV32I-NEXT:  .LBB7_2:
-; RV32I-NEXT:    srli a0, s1, 24
-; RV32I-NEXT:  .LBB7_3:
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    lw s8, 12(sp)
-; RV32I-NEXT:    lw s7, 16(sp)
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-  %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 false)
-  ret i64 %tmp
-}
-
-define i8 @test_cttz_i8_zero_undef(i8 %a) nounwind {
-; RV32I-LABEL: test_cttz_i8_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i8 @llvm.cttz.i8(i8 %a, i1 true)
-  ret i8 %tmp
-}
-
-define i16 @test_cttz_i16_zero_undef(i16 %a) nounwind {
-; RV32I-LABEL: test_cttz_i16_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i16 @llvm.cttz.i16(i16 %a, i1 true)
-  ret i16 %tmp
-}
-
-define i32 @test_cttz_i32_zero_undef(i32 %a) nounwind {
-; RV32I-LABEL: test_cttz_i32_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    addi a1, a0, -1
-; RV32I-NEXT:    not a0, a0
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %tmp = call i32 @llvm.cttz.i32(i32 %a, i1 true)
-  ret i32 %tmp
-}
-
-define i64 @test_cttz_i64_zero_undef(i64 %a) nounwind {
-; RV32I-LABEL: test_cttz_i64_zero_undef:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    sw s1, 40(sp)
-; RV32I-NEXT:    sw s2, 36(sp)
-; RV32I-NEXT:    sw s3, 32(sp)
-; RV32I-NEXT:    sw s4, 28(sp)
-; RV32I-NEXT:    sw s5, 24(sp)
-; RV32I-NEXT:    sw s6, 20(sp)
-; RV32I-NEXT:    sw s7, 16(sp)
-; RV32I-NEXT:    sw s8, 12(sp)
-; RV32I-NEXT:    mv s2, a1
-; RV32I-NEXT:    mv s3, a0
-; RV32I-NEXT:    addi a0, a0, -1
-; RV32I-NEXT:    not a1, s3
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi s5, a1, 1365
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi s6, a1, 819
-; RV32I-NEXT:    and a1, a0, s6
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s6
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi s4, a1, 257
-; RV32I-NEXT:    lui a1, %hi(__mulsi3)
-; RV32I-NEXT:    addi s7, a1, %lo(__mulsi3)
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi s8, a1, -241
-; RV32I-NEXT:    and a0, a0, s8
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    jalr s7
-; RV32I-NEXT:    mv s1, a0
-; RV32I-NEXT:    addi a0, s2, -1
-; RV32I-NEXT:    not a1, s2
-; RV32I-NEXT:    and a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 1
-; RV32I-NEXT:    and a1, a1, s5
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    and a1, a0, s6
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, s6
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    and a0, a0, s8
-; RV32I-NEXT:    mv a1, s4
-; RV32I-NEXT:    jalr s7
-; RV32I-NEXT:    bnez s3, .LBB11_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    addi a0, a0, 32
-; RV32I-NEXT:    j .LBB11_3
-; RV32I-NEXT:  .LBB11_2:
-; RV32I-NEXT:    srli a0, s1, 24
-; RV32I-NEXT:  .LBB11_3:
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    lw s8, 12(sp)
-; RV32I-NEXT:    lw s7, 16(sp)
-; RV32I-NEXT:    lw s6, 20(sp)
-; RV32I-NEXT:    lw s5, 24(sp)
-; RV32I-NEXT:    lw s4, 28(sp)
-; RV32I-NEXT:    lw s3, 32(sp)
-; RV32I-NEXT:    lw s2, 36(sp)
-; RV32I-NEXT:    lw s1, 40(sp)
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-  %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 true)
-  ret i64 %tmp
-}
-
-define i32 @test_ctpop_i32(i32 %a) nounwind {
-; RV32I-LABEL: test_ctpop_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, 349525
-; RV32I-NEXT:    addi a1, a1, 1365
-; RV32I-NEXT:    srli a2, a0, 1
-; RV32I-NEXT:    and a1, a2, a1
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    lui a1, 209715
-; RV32I-NEXT:    addi a1, a1, 819
-; RV32I-NEXT:    and a2, a0, a1
-; RV32I-NEXT:    srli a0, a0, 2
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    add a0, a2, a0
-; RV32I-NEXT:    srli a1, a0, 4
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    lui a1, 61681
-; RV32I-NEXT:    addi a1, a1, -241
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    lui a1, 4112
-; RV32I-NEXT:    addi a1, a1, 257
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    srli a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @llvm.ctpop.i32(i32 %a)
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/byval.ll b/test/CodeGen/RISCV/byval.ll
deleted file mode 100644
index a4060580ffc..00000000000
--- a/test/CodeGen/RISCV/byval.ll
+++ /dev/null
@@ -1,51 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-%struct.Foo = type { i32, i32, i32, i16, i8 }
-@foo = global %struct.Foo { i32 1, i32 2, i32 3, i16 4, i8 5 }, align 4
-
-define i32 @callee(%struct.Foo* byval %f) nounwind {
-; RV32I-LABEL: callee:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    ret
-entry:
-  %0 = getelementptr inbounds %struct.Foo, %struct.Foo* %f, i32 0, i32 0
-  %1 = load i32, i32* %0, align 4
-  ret i32 %1
-}
-
-
-define void @caller() nounwind {
-; RV32I-LABEL: caller:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 28(sp)
-; RV32I-NEXT:    lui a0, %hi(foo+12)
-; RV32I-NEXT:    addi a0, a0, %lo(foo+12)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 24(sp)
-; RV32I-NEXT:    lui a0, %hi(foo+8)
-; RV32I-NEXT:    addi a0, a0, %lo(foo+8)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 20(sp)
-; RV32I-NEXT:    lui a0, %hi(foo+4)
-; RV32I-NEXT:    addi a0, a0, %lo(foo+4)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    lui a0, %hi(foo)
-; RV32I-NEXT:    addi a0, a0, %lo(foo)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(callee)
-; RV32I-NEXT:    addi a1, a0, %lo(callee)
-; RV32I-NEXT:    addi a0, sp, 12
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 28(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-entry:
-  %call = call i32 @callee(%struct.Foo* byval @foo)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/calling-conv-sext-zext.ll b/test/CodeGen/RISCV/calling-conv-sext-zext.ll
deleted file mode 100644
index 8f921b630f0..00000000000
--- a/test/CodeGen/RISCV/calling-conv-sext-zext.ll
+++ /dev/null
@@ -1,380 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define zeroext i8 @uint8_arg_to_uint8_ret(i8 zeroext %a) nounwind {
-; RV32I-LABEL: uint8_arg_to_uint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-declare void @receive_uint8(i8 zeroext)
-
-define void @pass_uint8_as_uint8(i8 zeroext %a) nounwind {
-; RV32I-LABEL: pass_uint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_uint8)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_uint8)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_uint8(i8 zeroext %a)
-  ret void
-}
-
-declare zeroext i8 @return_uint8()
-
-define zeroext i8 @ret_callresult_uint8_as_uint8() nounwind {
-; RV32I-LABEL: ret_callresult_uint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_uint8)
-; RV32I-NEXT:    addi a0, a0, %lo(return_uint8)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call zeroext i8 @return_uint8()
-  ret i8 %1
-}
-
-define signext i8 @uint8_arg_to_sint8_ret(i8 zeroext %a) nounwind {
-; RV32I-LABEL: uint8_arg_to_sint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-declare void @receive_sint8(i8 signext)
-
-define void @pass_uint8_as_sint8(i8 zeroext %a) nounwind {
-; RV32I-LABEL: pass_uint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_sint8)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_sint8)
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-
-  call void @receive_sint8(i8 signext %a)
-  ret void
-}
-
-define signext i8 @ret_callresult_uint8_as_sint8() nounwind {
-; RV32I-LABEL: ret_callresult_uint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_uint8)
-; RV32I-NEXT:    addi a0, a0, %lo(return_uint8)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call zeroext i8 @return_uint8()
-  ret i8 %1
-}
-
-define signext i32 @uint8_arg_to_anyint32_ret(i8 zeroext %a) nounwind {
-; RV32I-LABEL: uint8_arg_to_anyint32_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i32
-  ret i32 %1
-}
-
-declare void @receive_anyint32(i32 signext)
-
-define void @pass_uint8_as_anyint32(i8 zeroext %a) nounwind {
-; RV32I-LABEL: pass_uint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_anyint32)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_anyint32)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i32
-  call void @receive_anyint32(i32 signext %1)
-  ret void
-}
-
-define signext i32 @ret_callresult_uint8_as_anyint32() nounwind {
-; RV32I-LABEL: ret_callresult_uint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_uint8)
-; RV32I-NEXT:    addi a0, a0, %lo(return_uint8)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call zeroext i8 @return_uint8()
-  %2 = zext i8 %1 to i32
-  ret i32 %2
-}
-
-define zeroext i8 @sint8_arg_to_uint8_ret(i8 signext %a) nounwind {
-; RV32I-LABEL: sint8_arg_to_uint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-define void @pass_sint8_as_uint8(i8 signext %a) nounwind {
-; RV32I-LABEL: pass_sint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    lui a1, %hi(receive_uint8)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_uint8)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_uint8(i8 zeroext %a)
-  ret void
-}
-
-declare signext i8 @return_sint8()
-
-define zeroext i8 @ret_callresult_sint8_as_uint8() nounwind {
-; RV32I-LABEL: ret_callresult_sint8_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_sint8)
-; RV32I-NEXT:    addi a0, a0, %lo(return_sint8)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i8 @return_sint8()
-  ret i8 %1
-}
-
-define signext i8 @sint8_arg_to_sint8_ret(i8 signext %a) nounwind {
-; RV32I-LABEL: sint8_arg_to_sint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i8 %a
-}
-
-define void @pass_sint8_as_sint8(i8 signext %a) nounwind {
-; RV32I-LABEL: pass_sint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_sint8)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_sint8)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_sint8(i8 signext %a)
-  ret void
-}
-
-define signext i8 @ret_callresult_sint8_as_sint8() nounwind {
-; RV32I-LABEL: ret_callresult_sint8_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_sint8)
-; RV32I-NEXT:    addi a0, a0, %lo(return_sint8)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i8 @return_sint8()
-  ret i8 %1
-}
-
-define signext i32 @sint8_arg_to_anyint32_ret(i8 signext %a) nounwind {
-; RV32I-LABEL: sint8_arg_to_anyint32_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i32
-  ret i32 %1
-}
-
-define void @pass_sint8_as_anyint32(i8 signext %a) nounwind {
-; RV32I-LABEL: pass_sint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_anyint32)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_anyint32)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i32
-  call void @receive_anyint32(i32 signext %1)
-  ret void
-}
-
-define signext i32 @ret_callresult_sint8_as_anyint32() nounwind {
-; RV32I-LABEL: ret_callresult_sint8_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_sint8)
-; RV32I-NEXT:    addi a0, a0, %lo(return_sint8)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i8 @return_sint8()
-  %2 = sext i8 %1 to i32
-  ret i32 %2
-}
-
-define zeroext i8 @anyint32_arg_to_uint8_ret(i32 signext %a) nounwind {
-; RV32I-LABEL: anyint32_arg_to_uint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  ret i8 %1
-}
-
-define void @pass_anyint32_as_uint8(i32 signext %a) nounwind {
-; RV32I-LABEL: pass_anyint32_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    lui a1, %hi(receive_uint8)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_uint8)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  call void @receive_uint8(i8 zeroext %1)
-  ret void
-}
-
-declare signext i32 @return_anyint32()
-
-define zeroext i8 @ret_callresult_anyint32_as_uint8() nounwind {
-; RV32I-LABEL: ret_callresult_anyint32_as_uint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_anyint32)
-; RV32I-NEXT:    addi a0, a0, %lo(return_anyint32)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i32 @return_anyint32()
-  %2 = trunc i32 %1 to i8
-  ret i8 %2
-}
-
-define signext i8 @anyint32_arg_to_sint8_ret(i32 signext %a) nounwind {
-; RV32I-LABEL: anyint32_arg_to_sint8_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  ret i8 %1
-}
-
-define void @pass_anyint32_as_sint8(i32 signext %a) nounwind {
-; RV32I-LABEL: pass_anyint32_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_sint8)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_sint8)
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  call void @receive_sint8(i8 signext %1)
-  ret void
-}
-
-define signext i8 @ret_callresult_anyint32_as_sint8() nounwind {
-; RV32I-LABEL: ret_callresult_anyint32_as_sint8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_anyint32)
-; RV32I-NEXT:    addi a0, a0, %lo(return_anyint32)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i32 @return_anyint32()
-  %2 = trunc i32 %1 to i8
-  ret i8 %2
-}
-
-define signext i32 @anyint32_arg_to_anyint32_ret(i32 signext %a) nounwind {
-; RV32I-LABEL: anyint32_arg_to_anyint32_ret:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  ret i32 %a
-}
-
-define void @pass_anyint32_as_anyint32(i32 signext %a) nounwind {
-; RV32I-LABEL: pass_anyint32_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(receive_anyint32)
-; RV32I-NEXT:    addi a1, a1, %lo(receive_anyint32)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  call void @receive_anyint32(i32 signext %a)
-  ret void
-}
-
-define signext i32 @ret_callresult_anyint32_as_anyint32() nounwind {
-; RV32I-LABEL: ret_callresult_anyint32_as_anyint32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(return_anyint32)
-; RV32I-NEXT:    addi a0, a0, %lo(return_anyint32)
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call signext i32 @return_anyint32()
-  ret i32 %1
-}
-
diff --git a/test/CodeGen/RISCV/calling-conv.ll b/test/CodeGen/RISCV/calling-conv.ll
deleted file mode 100644
index 1d6f4c50731..00000000000
--- a/test/CodeGen/RISCV/calling-conv.ll
+++ /dev/null
@@ -1,1132 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -disable-fp-elim < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-; As well as calling convention details, we check that ra and fp are
-; consistently stored to fp-4 and fp-8.
-
-; Check that on RV32, i64 and double are passed in a pair of registers. Unlike
-; the convention for varargs, this need not be an aligned pair.
-
-define i32 @callee_scalars(i32 %a, i64 %b, i32 %c, i32 %d, double %e) nounwind {
-; RV32I-FPELIM-LABEL: callee_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 24(sp)
-; RV32I-FPELIM-NEXT:    sw s2, 20(sp)
-; RV32I-FPELIM-NEXT:    sw s3, 16(sp)
-; RV32I-FPELIM-NEXT:    sw s4, 12(sp)
-; RV32I-FPELIM-NEXT:    mv s1, a4
-; RV32I-FPELIM-NEXT:    mv s2, a3
-; RV32I-FPELIM-NEXT:    mv s3, a1
-; RV32I-FPELIM-NEXT:    mv s4, a0
-; RV32I-FPELIM-NEXT:    lui a0, %hi(__fixdfsi)
-; RV32I-FPELIM-NEXT:    addi a2, a0, %lo(__fixdfsi)
-; RV32I-FPELIM-NEXT:    mv a0, a5
-; RV32I-FPELIM-NEXT:    mv a1, a6
-; RV32I-FPELIM-NEXT:    jalr a2
-; RV32I-FPELIM-NEXT:    add a1, s4, s3
-; RV32I-FPELIM-NEXT:    add a1, a1, s2
-; RV32I-FPELIM-NEXT:    add a1, a1, s1
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    lw s4, 12(sp)
-; RV32I-FPELIM-NEXT:    lw s3, 16(sp)
-; RV32I-FPELIM-NEXT:    lw s2, 20(sp)
-; RV32I-FPELIM-NEXT:    lw s1, 24(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    sw s2, 16(sp)
-; RV32I-WITHFP-NEXT:    sw s3, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s4, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    mv s1, a4
-; RV32I-WITHFP-NEXT:    mv s2, a3
-; RV32I-WITHFP-NEXT:    mv s3, a1
-; RV32I-WITHFP-NEXT:    mv s4, a0
-; RV32I-WITHFP-NEXT:    lui a0, %hi(__fixdfsi)
-; RV32I-WITHFP-NEXT:    addi a2, a0, %lo(__fixdfsi)
-; RV32I-WITHFP-NEXT:    mv a0, a5
-; RV32I-WITHFP-NEXT:    mv a1, a6
-; RV32I-WITHFP-NEXT:    jalr a2
-; RV32I-WITHFP-NEXT:    add a1, s4, s3
-; RV32I-WITHFP-NEXT:    add a1, a1, s2
-; RV32I-WITHFP-NEXT:    add a1, a1, s1
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    lw s4, 8(sp)
-; RV32I-WITHFP-NEXT:    lw s3, 12(sp)
-; RV32I-WITHFP-NEXT:    lw s2, 16(sp)
-; RV32I-WITHFP-NEXT:    lw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %b_trunc = trunc i64 %b to i32
-  %e_fptosi = fptosi double %e to i32
-  %1 = add i32 %a, %b_trunc
-  %2 = add i32 %1, %c
-  %3 = add i32 %2, %d
-  %4 = add i32 %3, %e_fptosi
-  ret i32 %4
-}
-
-define i32 @caller_scalars() nounwind {
-; RV32I-FPELIM-LABEL: caller_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262464
-; RV32I-FPELIM-NEXT:    mv a6, a0
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_scalars)
-; RV32I-FPELIM-NEXT:    addi a7, a0, %lo(callee_scalars)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    addi a3, zero, 3
-; RV32I-FPELIM-NEXT:    addi a4, zero, 4
-; RV32I-FPELIM-NEXT:    mv a2, zero
-; RV32I-FPELIM-NEXT:    mv a5, zero
-; RV32I-FPELIM-NEXT:    jalr a7
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 262464
-; RV32I-WITHFP-NEXT:    mv a6, a0
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_scalars)
-; RV32I-WITHFP-NEXT:    addi a7, a0, %lo(callee_scalars)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    addi a3, zero, 3
-; RV32I-WITHFP-NEXT:    addi a4, zero, 4
-; RV32I-WITHFP-NEXT:    mv a2, zero
-; RV32I-WITHFP-NEXT:    mv a5, zero
-; RV32I-WITHFP-NEXT:    jalr a7
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_scalars(i32 1, i64 2, i32 3, i32 4, double 5.000000e+00)
-  ret i32 %1
-}
-
-; Check that i128 and fp128 are passed indirectly
-
-define i32 @callee_large_scalars(i128 %a, fp128 %b) nounwind {
-; RV32I-FPELIM-LABEL: callee_large_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a2, 12(a1)
-; RV32I-FPELIM-NEXT:    lw a3, 12(a0)
-; RV32I-FPELIM-NEXT:    xor a2, a3, a2
-; RV32I-FPELIM-NEXT:    lw a3, 4(a1)
-; RV32I-FPELIM-NEXT:    lw a4, 4(a0)
-; RV32I-FPELIM-NEXT:    xor a3, a4, a3
-; RV32I-FPELIM-NEXT:    or a2, a3, a2
-; RV32I-FPELIM-NEXT:    lw a3, 8(a1)
-; RV32I-FPELIM-NEXT:    lw a4, 8(a0)
-; RV32I-FPELIM-NEXT:    xor a3, a4, a3
-; RV32I-FPELIM-NEXT:    lw a1, 0(a1)
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    xor a0, a0, a1
-; RV32I-FPELIM-NEXT:    or a0, a0, a3
-; RV32I-FPELIM-NEXT:    or a0, a0, a2
-; RV32I-FPELIM-NEXT:    xor a0, a0, zero
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a2, 12(a1)
-; RV32I-WITHFP-NEXT:    lw a3, 12(a0)
-; RV32I-WITHFP-NEXT:    xor a2, a3, a2
-; RV32I-WITHFP-NEXT:    lw a3, 4(a1)
-; RV32I-WITHFP-NEXT:    lw a4, 4(a0)
-; RV32I-WITHFP-NEXT:    xor a3, a4, a3
-; RV32I-WITHFP-NEXT:    or a2, a3, a2
-; RV32I-WITHFP-NEXT:    lw a3, 8(a1)
-; RV32I-WITHFP-NEXT:    lw a4, 8(a0)
-; RV32I-WITHFP-NEXT:    xor a3, a4, a3
-; RV32I-WITHFP-NEXT:    lw a1, 0(a1)
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    xor a0, a0, a1
-; RV32I-WITHFP-NEXT:    or a0, a0, a3
-; RV32I-WITHFP-NEXT:    or a0, a0, a2
-; RV32I-WITHFP-NEXT:    xor a0, a0, zero
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %b_bitcast = bitcast fp128 %b to i128
-  %1 = icmp eq i128 %a, %b_bitcast
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @caller_large_scalars() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 8(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 4(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 0(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 36(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 32(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 28(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 524272
-; RV32I-FPELIM-NEXT:    mv a0, a0
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_large_scalars)
-; RV32I-FPELIM-NEXT:    addi a2, a0, %lo(callee_large_scalars)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 24
-; RV32I-FPELIM-NEXT:    mv a1, sp
-; RV32I-FPELIM-NEXT:    jalr a2
-; RV32I-FPELIM-NEXT:    lw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 48
-; RV32I-WITHFP-NEXT:    sw zero, -40(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -44(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -48(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -12(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -16(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -20(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 524272
-; RV32I-WITHFP-NEXT:    mv a0, a0
-; RV32I-WITHFP-NEXT:    sw a0, -36(s0)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_large_scalars)
-; RV32I-WITHFP-NEXT:    addi a2, a0, %lo(callee_large_scalars)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -24
-; RV32I-WITHFP-NEXT:    addi a1, s0, -48
-; RV32I-WITHFP-NEXT:    jalr a2
-; RV32I-WITHFP-NEXT:    lw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_large_scalars(i128 1, fp128 0xL00000000000000007FFF000000000000)
-  ret i32 %1
-}
-
-; Must keep define on a single line due to an update_llc_test_checks.py limitation
-define i32 @callee_large_scalars_exhausted_regs(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i128 %h, i32 %i, fp128 %j) nounwind {
-; Check that arguments larger than 2*xlen are handled correctly when their
-; address is passed on the stack rather than in memory
-; RV32I-FPELIM-LABEL: callee_large_scalars_exhausted_regs:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    lw a2, 12(a7)
-; RV32I-FPELIM-NEXT:    xor a1, a2, a1
-; RV32I-FPELIM-NEXT:    lw a2, 4(a0)
-; RV32I-FPELIM-NEXT:    lw a3, 4(a7)
-; RV32I-FPELIM-NEXT:    xor a2, a3, a2
-; RV32I-FPELIM-NEXT:    or a1, a2, a1
-; RV32I-FPELIM-NEXT:    lw a2, 8(a0)
-; RV32I-FPELIM-NEXT:    lw a3, 8(a7)
-; RV32I-FPELIM-NEXT:    xor a2, a3, a2
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    lw a3, 0(a7)
-; RV32I-FPELIM-NEXT:    xor a0, a3, a0
-; RV32I-FPELIM-NEXT:    or a0, a0, a2
-; RV32I-FPELIM-NEXT:    or a0, a0, a1
-; RV32I-FPELIM-NEXT:    xor a0, a0, zero
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_scalars_exhausted_regs:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a0, 4(s0)
-; RV32I-WITHFP-NEXT:    lw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    lw a2, 12(a7)
-; RV32I-WITHFP-NEXT:    xor a1, a2, a1
-; RV32I-WITHFP-NEXT:    lw a2, 4(a0)
-; RV32I-WITHFP-NEXT:    lw a3, 4(a7)
-; RV32I-WITHFP-NEXT:    xor a2, a3, a2
-; RV32I-WITHFP-NEXT:    or a1, a2, a1
-; RV32I-WITHFP-NEXT:    lw a2, 8(a0)
-; RV32I-WITHFP-NEXT:    lw a3, 8(a7)
-; RV32I-WITHFP-NEXT:    xor a2, a3, a2
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    lw a3, 0(a7)
-; RV32I-WITHFP-NEXT:    xor a0, a3, a0
-; RV32I-WITHFP-NEXT:    or a0, a0, a2
-; RV32I-WITHFP-NEXT:    or a0, a0, a1
-; RV32I-WITHFP-NEXT:    xor a0, a0, zero
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %j_bitcast = bitcast fp128 %j to i128
-  %1 = icmp eq i128 %h, %j_bitcast
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @caller_large_scalars_exhausted_regs() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_scalars_exhausted_regs:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -64
-; RV32I-FPELIM-NEXT:    sw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 16
-; RV32I-FPELIM-NEXT:    sw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 9
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 24(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 20(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 16(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 52(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 48(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 44(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 8
-; RV32I-FPELIM-NEXT:    sw a0, 40(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 524272
-; RV32I-FPELIM-NEXT:    mv a0, a0
-; RV32I-FPELIM-NEXT:    sw a0, 28(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_large_scalars_exhausted_regs)
-; RV32I-FPELIM-NEXT:    addi t0, a0, %lo(callee_large_scalars_exhausted_regs)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    addi a2, zero, 3
-; RV32I-FPELIM-NEXT:    addi a3, zero, 4
-; RV32I-FPELIM-NEXT:    addi a4, zero, 5
-; RV32I-FPELIM-NEXT:    addi a5, zero, 6
-; RV32I-FPELIM-NEXT:    addi a6, zero, 7
-; RV32I-FPELIM-NEXT:    addi a7, sp, 40
-; RV32I-FPELIM-NEXT:    jalr t0
-; RV32I-FPELIM-NEXT:    lw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 64
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_scalars_exhausted_regs:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 64
-; RV32I-WITHFP-NEXT:    addi a0, s0, -48
-; RV32I-WITHFP-NEXT:    sw a0, 4(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 9
-; RV32I-WITHFP-NEXT:    sw a0, 0(sp)
-; RV32I-WITHFP-NEXT:    sw zero, -40(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -44(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -48(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -12(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -16(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -20(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 8
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 524272
-; RV32I-WITHFP-NEXT:    mv a0, a0
-; RV32I-WITHFP-NEXT:    sw a0, -36(s0)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_large_scalars_exhausted_regs)
-; RV32I-WITHFP-NEXT:    addi t0, a0, %lo(callee_large_scalars_exhausted_regs)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    addi a2, zero, 3
-; RV32I-WITHFP-NEXT:    addi a3, zero, 4
-; RV32I-WITHFP-NEXT:    addi a4, zero, 5
-; RV32I-WITHFP-NEXT:    addi a5, zero, 6
-; RV32I-WITHFP-NEXT:    addi a6, zero, 7
-; RV32I-WITHFP-NEXT:    addi a7, s0, -24
-; RV32I-WITHFP-NEXT:    jalr t0
-; RV32I-WITHFP-NEXT:    lw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_large_scalars_exhausted_regs(
-      i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i128 8, i32 9,
-      fp128 0xL00000000000000007FFF000000000000)
-  ret i32 %1
-}
-
-; Ensure that libcalls generated in the middle-end obey the calling convention
-
-define i32 @caller_mixed_scalar_libcalls(i64 %a) nounwind {
-; RV32I-FPELIM-LABEL: caller_mixed_scalar_libcalls:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    mv a2, a1
-; RV32I-FPELIM-NEXT:    mv a1, a0
-; RV32I-FPELIM-NEXT:    lui a0, %hi(__floatditf)
-; RV32I-FPELIM-NEXT:    addi a3, a0, %lo(__floatditf)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 8
-; RV32I-FPELIM-NEXT:    jalr a3
-; RV32I-FPELIM-NEXT:    lw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_mixed_scalar_libcalls:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    mv a2, a1
-; RV32I-WITHFP-NEXT:    mv a1, a0
-; RV32I-WITHFP-NEXT:    lui a0, %hi(__floatditf)
-; RV32I-WITHFP-NEXT:    addi a3, a0, %lo(__floatditf)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -24
-; RV32I-WITHFP-NEXT:    jalr a3
-; RV32I-WITHFP-NEXT:    lw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = sitofp i64 %a to fp128
-  %2 = bitcast fp128 %1 to i128
-  %3 = trunc i128 %2 to i32
-  ret i32 %3
-}
-
-; Check that the stack is used once the GPRs are exhausted
-
-define i32 @callee_many_scalars(i8 %a, i16 %b, i32 %c, i64 %d, i32 %e, i32 %f, i64 %g, i32 %h) nounwind {
-; RV32I-FPELIM-LABEL: callee_many_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw t0, 0(sp)
-; RV32I-FPELIM-NEXT:    xor a4, a4, t0
-; RV32I-FPELIM-NEXT:    xor a3, a3, a7
-; RV32I-FPELIM-NEXT:    or a3, a3, a4
-; RV32I-FPELIM-NEXT:    xor a3, a3, zero
-; RV32I-FPELIM-NEXT:    lui a4, 16
-; RV32I-FPELIM-NEXT:    addi a4, a4, -1
-; RV32I-FPELIM-NEXT:    and a1, a1, a4
-; RV32I-FPELIM-NEXT:    andi a0, a0, 255
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    add a0, a0, a2
-; RV32I-FPELIM-NEXT:    seqz a1, a3
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    add a0, a0, a5
-; RV32I-FPELIM-NEXT:    add a0, a0, a6
-; RV32I-FPELIM-NEXT:    lw a1, 4(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_many_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw t0, 0(s0)
-; RV32I-WITHFP-NEXT:    xor a4, a4, t0
-; RV32I-WITHFP-NEXT:    xor a3, a3, a7
-; RV32I-WITHFP-NEXT:    or a3, a3, a4
-; RV32I-WITHFP-NEXT:    xor a3, a3, zero
-; RV32I-WITHFP-NEXT:    lui a4, 16
-; RV32I-WITHFP-NEXT:    addi a4, a4, -1
-; RV32I-WITHFP-NEXT:    and a1, a1, a4
-; RV32I-WITHFP-NEXT:    andi a0, a0, 255
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    add a0, a0, a2
-; RV32I-WITHFP-NEXT:    seqz a1, a3
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    add a0, a0, a5
-; RV32I-WITHFP-NEXT:    add a0, a0, a6
-; RV32I-WITHFP-NEXT:    lw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %a_ext = zext i8 %a to i32
-  %b_ext = zext i16 %b to i32
-  %1 = add i32 %a_ext, %b_ext
-  %2 = add i32 %1, %c
-  %3 = icmp eq i64 %d, %g
-  %4 = zext i1 %3 to i32
-  %5 = add i32 %4, %2
-  %6 = add i32 %5, %e
-  %7 = add i32 %6, %f
-  %8 = add i32 %7, %h
-  ret i32 %8
-}
-
-define i32 @caller_many_scalars() nounwind {
-; RV32I-FPELIM-LABEL: caller_many_scalars:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 8
-; RV32I-FPELIM-NEXT:    sw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_many_scalars)
-; RV32I-FPELIM-NEXT:    addi t0, a0, %lo(callee_many_scalars)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    addi a2, zero, 3
-; RV32I-FPELIM-NEXT:    addi a3, zero, 4
-; RV32I-FPELIM-NEXT:    addi a5, zero, 5
-; RV32I-FPELIM-NEXT:    addi a6, zero, 6
-; RV32I-FPELIM-NEXT:    addi a7, zero, 7
-; RV32I-FPELIM-NEXT:    mv a4, zero
-; RV32I-FPELIM-NEXT:    jalr t0
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_many_scalars:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    addi a0, zero, 8
-; RV32I-WITHFP-NEXT:    sw a0, 4(sp)
-; RV32I-WITHFP-NEXT:    sw zero, 0(sp)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_many_scalars)
-; RV32I-WITHFP-NEXT:    addi t0, a0, %lo(callee_many_scalars)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    addi a2, zero, 3
-; RV32I-WITHFP-NEXT:    addi a3, zero, 4
-; RV32I-WITHFP-NEXT:    addi a5, zero, 5
-; RV32I-WITHFP-NEXT:    addi a6, zero, 6
-; RV32I-WITHFP-NEXT:    addi a7, zero, 7
-; RV32I-WITHFP-NEXT:    mv a4, zero
-; RV32I-WITHFP-NEXT:    jalr t0
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_many_scalars(i8 1, i16 2, i32 3, i64 4, i32 5, i32 6, i64 7, i32 8)
-  ret i32 %1
-}
-
-; Check passing of coerced integer arrays
-
-%struct.small = type { i32, i32* }
-
-define i32 @callee_small_coerced_struct([2 x i32] %a.coerce) nounwind {
-; RV32I-FPELIM-LABEL: callee_small_coerced_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    xor a0, a0, a1
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_small_coerced_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    xor a0, a0, a1
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = extractvalue [2 x i32] %a.coerce, 0
-  %2 = extractvalue [2 x i32] %a.coerce, 1
-  %3 = icmp eq i32 %1, %2
-  %4 = zext i1 %3 to i32
-  ret i32 %4
-}
-
-define i32 @caller_small_coerced_struct() nounwind {
-; RV32I-FPELIM-LABEL: caller_small_coerced_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_small_coerced_struct)
-; RV32I-FPELIM-NEXT:    addi a2, a0, %lo(callee_small_coerced_struct)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    jalr a2
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_small_coerced_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_small_coerced_struct)
-; RV32I-WITHFP-NEXT:    addi a2, a0, %lo(callee_small_coerced_struct)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    jalr a2
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_small_coerced_struct([2 x i32] [i32 1, i32 2])
-  ret i32 %1
-}
-
-; Check large struct arguments, which are passed byval
-
-%struct.large = type { i32, i32, i32, i32 }
-
-define i32 @callee_large_struct(%struct.large* byval align 4 %a) nounwind {
-; RV32I-FPELIM-LABEL: callee_large_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 0
-  %2 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 3
-  %3 = load i32, i32* %1
-  %4 = load i32, i32* %2
-  %5 = add i32 %3, %4
-  ret i32 %5
-}
-
-define i32 @caller_large_struct() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_struct:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 2
-; RV32I-FPELIM-NEXT:    sw a0, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 3
-; RV32I-FPELIM-NEXT:    sw a0, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 4
-; RV32I-FPELIM-NEXT:    sw a0, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_large_struct)
-; RV32I-FPELIM-NEXT:    addi a1, a0, %lo(callee_large_struct)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 8
-; RV32I-FPELIM-NEXT:    jalr a1
-; RV32I-FPELIM-NEXT:    lw ra, 44(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_struct:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 48
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -40(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 2
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -36(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 3
-; RV32I-WITHFP-NEXT:    sw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -32(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 4
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -28(s0)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_large_struct)
-; RV32I-WITHFP-NEXT:    addi a1, a0, %lo(callee_large_struct)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -40
-; RV32I-WITHFP-NEXT:    jalr a1
-; RV32I-WITHFP-NEXT:    lw s0, 40(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 44(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %ls = alloca %struct.large, align 4
-  %1 = bitcast %struct.large* %ls to i8*
-  %a = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 0
-  store i32 1, i32* %a
-  %b = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 1
-  store i32 2, i32* %b
-  %c = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 2
-  store i32 3, i32* %c
-  %d = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 3
-  store i32 4, i32* %d
-  %2 = call i32 @callee_large_struct(%struct.large* byval align 4 %ls)
-  ret i32 %2
-}
-
-; Check 2x*xlen values are aligned appropriately when passed on the stack
-; Must keep define on a single line due to an update_llc_test_checks.py limitation
-define i32 @callee_aligned_stack(i32 %a, i32 %b, fp128 %c, i32 %d, i32 %e, i64 %f, i32 %g, i32 %h, double %i, i32 %j, [2 x i32] %k) nounwind {
-; The double should be 8-byte aligned on the stack, but the two-element array
-; should only be 4-byte aligned
-; RV32I-FPELIM-LABEL: callee_aligned_stack:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lw a0, 0(a2)
-; RV32I-FPELIM-NEXT:    add a0, a0, a7
-; RV32I-FPELIM-NEXT:    lw a1, 0(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw a1, 8(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw a1, 16(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_aligned_stack:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lw a0, 0(a2)
-; RV32I-WITHFP-NEXT:    add a0, a0, a7
-; RV32I-WITHFP-NEXT:    lw a1, 0(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw a1, 8(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw a1, 16(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw a1, 20(s0)
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = bitcast fp128 %c to i128
-  %2 = trunc i128 %1 to i32
-  %3 = add i32 %2, %g
-  %4 = add i32 %3, %h
-  %5 = bitcast double %i to i64
-  %6 = trunc i64 %5 to i32
-  %7 = add i32 %4, %6
-  %8 = add i32 %7, %j
-  %9 = extractvalue [2 x i32] %k, 0
-  %10 = add i32 %8, %9
-  ret i32 %10
-}
-
-define void @caller_aligned_stack() nounwind {
-; The double should be 8-byte aligned on the stack, but the two-element array
-; should only be 4-byte aligned
-; RV32I-FPELIM-LABEL: caller_aligned_stack:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -64
-; RV32I-FPELIM-NEXT:    sw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 18
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 17
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 16
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262236
-; RV32I-FPELIM-NEXT:    addi a0, a0, 655
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 377487
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1475
-; RV32I-FPELIM-NEXT:    sw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 15
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262153
-; RV32I-FPELIM-NEXT:    addi a0, a0, 491
-; RV32I-FPELIM-NEXT:    sw a0, 44(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 545260
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1967
-; RV32I-FPELIM-NEXT:    sw a0, 40(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 964690
-; RV32I-FPELIM-NEXT:    addi a0, a0, -328
-; RV32I-FPELIM-NEXT:    sw a0, 36(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 335544
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1311
-; RV32I-FPELIM-NEXT:    sw a0, 32(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 688509
-; RV32I-FPELIM-NEXT:    addi a5, a0, -2048
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_aligned_stack)
-; RV32I-FPELIM-NEXT:    addi t0, a0, %lo(callee_aligned_stack)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 11
-; RV32I-FPELIM-NEXT:    addi a2, sp, 32
-; RV32I-FPELIM-NEXT:    addi a3, zero, 12
-; RV32I-FPELIM-NEXT:    addi a4, zero, 13
-; RV32I-FPELIM-NEXT:    addi a6, zero, 4
-; RV32I-FPELIM-NEXT:    addi a7, zero, 14
-; RV32I-FPELIM-NEXT:    jalr t0
-; RV32I-FPELIM-NEXT:    lw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 64
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_aligned_stack:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 64
-; RV32I-WITHFP-NEXT:    addi a0, zero, 18
-; RV32I-WITHFP-NEXT:    sw a0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 17
-; RV32I-WITHFP-NEXT:    sw a0, 20(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 16
-; RV32I-WITHFP-NEXT:    sw a0, 16(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262236
-; RV32I-WITHFP-NEXT:    addi a0, a0, 655
-; RV32I-WITHFP-NEXT:    sw a0, 12(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 377487
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1475
-; RV32I-WITHFP-NEXT:    sw a0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 15
-; RV32I-WITHFP-NEXT:    sw a0, 0(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262153
-; RV32I-WITHFP-NEXT:    addi a0, a0, 491
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 545260
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1967
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 964690
-; RV32I-WITHFP-NEXT:    addi a0, a0, -328
-; RV32I-WITHFP-NEXT:    sw a0, -28(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 335544
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1311
-; RV32I-WITHFP-NEXT:    sw a0, -32(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 688509
-; RV32I-WITHFP-NEXT:    addi a5, a0, -2048
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_aligned_stack)
-; RV32I-WITHFP-NEXT:    addi t0, a0, %lo(callee_aligned_stack)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 11
-; RV32I-WITHFP-NEXT:    addi a2, s0, -32
-; RV32I-WITHFP-NEXT:    addi a3, zero, 12
-; RV32I-WITHFP-NEXT:    addi a4, zero, 13
-; RV32I-WITHFP-NEXT:    addi a6, zero, 4
-; RV32I-WITHFP-NEXT:    addi a7, zero, 14
-; RV32I-WITHFP-NEXT:    jalr t0
-; RV32I-WITHFP-NEXT:    lw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 @callee_aligned_stack(i32 1, i32 11,
-    fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13,
-    i64 20000000000, i32 14, i32 15, double 2.720000e+00, i32 16,
-    [2 x i32] [i32 17, i32 18])
-  ret void
-}
-
-; Check return of 2x xlen scalars
-
-define i64 @callee_small_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: callee_small_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a0, 466866
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1677
-; RV32I-FPELIM-NEXT:    addi a1, zero, 287
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_small_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 466866
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1677
-; RV32I-WITHFP-NEXT:    addi a1, zero, 287
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  ret i64 1234567898765
-}
-
-define i32 @caller_small_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_small_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_small_scalar_ret)
-; RV32I-FPELIM-NEXT:    addi a0, a0, %lo(callee_small_scalar_ret)
-; RV32I-FPELIM-NEXT:    jalr a0
-; RV32I-FPELIM-NEXT:    lui a2, 56
-; RV32I-FPELIM-NEXT:    addi a2, a2, 580
-; RV32I-FPELIM-NEXT:    xor a1, a1, a2
-; RV32I-FPELIM-NEXT:    lui a2, 200614
-; RV32I-FPELIM-NEXT:    addi a2, a2, 647
-; RV32I-FPELIM-NEXT:    xor a0, a0, a2
-; RV32I-FPELIM-NEXT:    or a0, a0, a1
-; RV32I-FPELIM-NEXT:    xor a0, a0, zero
-; RV32I-FPELIM-NEXT:    seqz a0, a0
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_small_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_small_scalar_ret)
-; RV32I-WITHFP-NEXT:    addi a0, a0, %lo(callee_small_scalar_ret)
-; RV32I-WITHFP-NEXT:    jalr a0
-; RV32I-WITHFP-NEXT:    lui a2, 56
-; RV32I-WITHFP-NEXT:    addi a2, a2, 580
-; RV32I-WITHFP-NEXT:    xor a1, a1, a2
-; RV32I-WITHFP-NEXT:    lui a2, 200614
-; RV32I-WITHFP-NEXT:    addi a2, a2, 647
-; RV32I-WITHFP-NEXT:    xor a0, a0, a2
-; RV32I-WITHFP-NEXT:    or a0, a0, a1
-; RV32I-WITHFP-NEXT:    xor a0, a0, zero
-; RV32I-WITHFP-NEXT:    seqz a0, a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i64 @callee_small_scalar_ret()
-  %2 = icmp eq i64 987654321234567, %1
-  %3 = zext i1 %2 to i32
-  ret i32 %3
-}
-
-; Check return of 2x xlen structs
-
-define %struct.small @callee_small_struct_ret() nounwind {
-; RV32I-FPELIM-LABEL: callee_small_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    mv a1, zero
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_small_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    mv a1, zero
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  ret %struct.small { i32 1, i32* null }
-}
-
-define i32 @caller_small_struct_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_small_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_small_struct_ret)
-; RV32I-FPELIM-NEXT:    addi a0, a0, %lo(callee_small_struct_ret)
-; RV32I-FPELIM-NEXT:    jalr a0
-; RV32I-FPELIM-NEXT:    add a0, a0, a1
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_small_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_small_struct_ret)
-; RV32I-WITHFP-NEXT:    addi a0, a0, %lo(callee_small_struct_ret)
-; RV32I-WITHFP-NEXT:    jalr a0
-; RV32I-WITHFP-NEXT:    add a0, a0, a1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call %struct.small @callee_small_struct_ret()
-  %2 = extractvalue %struct.small %1, 0
-  %3 = extractvalue %struct.small %1, 1
-  %4 = ptrtoint i32* %3 to i32
-  %5 = add i32 %2, %4
-  ret i32 %5
-}
-
-; Check return of >2x xlen scalars
-
-define fp128 @callee_large_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: callee_large_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a1, 524272
-; RV32I-FPELIM-NEXT:    mv a1, a1
-; RV32I-FPELIM-NEXT:    sw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    sw zero, 8(a0)
-; RV32I-FPELIM-NEXT:    sw zero, 4(a0)
-; RV32I-FPELIM-NEXT:    sw zero, 0(a0)
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a1, 524272
-; RV32I-WITHFP-NEXT:    mv a1, a1
-; RV32I-WITHFP-NEXT:    sw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    sw zero, 8(a0)
-; RV32I-WITHFP-NEXT:    sw zero, 4(a0)
-; RV32I-WITHFP-NEXT:    sw zero, 0(a0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  ret fp128 0xL00000000000000007FFF000000000000
-}
-
-define void @caller_large_scalar_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_scalar_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_large_scalar_ret)
-; RV32I-FPELIM-NEXT:    addi a1, a0, %lo(callee_large_scalar_ret)
-; RV32I-FPELIM-NEXT:    mv a0, sp
-; RV32I-FPELIM-NEXT:    jalr a1
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_scalar_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_large_scalar_ret)
-; RV32I-WITHFP-NEXT:    addi a1, a0, %lo(callee_large_scalar_ret)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -32
-; RV32I-WITHFP-NEXT:    jalr a1
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call fp128 @callee_large_scalar_ret()
-  ret void
-}
-
-; Check return of >2x xlen structs
-
-define void @callee_large_struct_ret(%struct.large* noalias sret %agg.result) nounwind {
-; RV32I-FPELIM-LABEL: callee_large_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi a1, zero, 2
-; RV32I-FPELIM-NEXT:    sw a1, 4(a0)
-; RV32I-FPELIM-NEXT:    addi a1, zero, 1
-; RV32I-FPELIM-NEXT:    sw a1, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a1, zero, 3
-; RV32I-FPELIM-NEXT:    sw a1, 8(a0)
-; RV32I-FPELIM-NEXT:    addi a1, zero, 4
-; RV32I-FPELIM-NEXT:    sw a1, 12(a0)
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: callee_large_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    addi a1, zero, 2
-; RV32I-WITHFP-NEXT:    sw a1, 4(a0)
-; RV32I-WITHFP-NEXT:    addi a1, zero, 1
-; RV32I-WITHFP-NEXT:    sw a1, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a1, zero, 3
-; RV32I-WITHFP-NEXT:    sw a1, 8(a0)
-; RV32I-WITHFP-NEXT:    addi a1, zero, 4
-; RV32I-WITHFP-NEXT:    sw a1, 12(a0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %a = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 0
-  store i32 1, i32* %a, align 4
-  %b = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 1
-  store i32 2, i32* %b, align 4
-  %c = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 2
-  store i32 3, i32* %c, align 4
-  %d = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 3
-  store i32 4, i32* %d, align 4
-  ret void
-}
-
-define i32 @caller_large_struct_ret() nounwind {
-; RV32I-FPELIM-LABEL: caller_large_struct_ret:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(callee_large_struct_ret)
-; RV32I-FPELIM-NEXT:    addi a1, a0, %lo(callee_large_struct_ret)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 8
-; RV32I-FPELIM-NEXT:    jalr a1
-; RV32I-FPELIM-NEXT:    lw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 8(sp)
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: caller_large_struct_ret:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    lui a0, %hi(callee_large_struct_ret)
-; RV32I-WITHFP-NEXT:    addi a1, a0, %lo(callee_large_struct_ret)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -24
-; RV32I-WITHFP-NEXT:    jalr a1
-; RV32I-WITHFP-NEXT:    lw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a1, -24(s0)
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %1 = alloca %struct.large
-  call void @callee_large_struct_ret(%struct.large* sret %1)
-  %2 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 0
-  %3 = load i32, i32* %2
-  %4 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 3
-  %5 = load i32, i32* %4
-  %6 = add i32 %3, %5
-  ret i32 %6
-}
diff --git a/test/CodeGen/RISCV/calls.ll b/test/CodeGen/RISCV/calls.ll
deleted file mode 100644
index 8875015e5b3..00000000000
--- a/test/CodeGen/RISCV/calls.ll
+++ /dev/null
@@ -1,158 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-declare i32 @external_function(i32)
-
-define i32 @test_call_external(i32 %a) nounwind {
-; RV32I-LABEL: test_call_external:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(external_function)
-; RV32I-NEXT:    addi a1, a1, %lo(external_function)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @external_function(i32 %a)
-  ret i32 %1
-}
-
-define i32 @defined_function(i32 %a) nounwind {
-; RV32I-LABEL: defined_function:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = add i32 %a, 1
-  ret i32 %1
-}
-
-define i32 @test_call_defined(i32 %a) nounwind {
-; RV32I-LABEL: test_call_defined:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(defined_function)
-; RV32I-NEXT:    addi a1, a1, %lo(defined_function)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @defined_function(i32 %a)
-  ret i32 %1
-}
-
-define i32 @test_call_indirect(i32 (i32)* %a, i32 %b) nounwind {
-; RV32I-LABEL: test_call_indirect:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 %a(i32 %b)
-  ret i32 %1
-}
-
-; Ensure that calls to fastcc functions aren't rejected. Such calls may be
-; introduced when compiling with optimisation.
-
-define fastcc i32 @fastcc_function(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: fastcc_function:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
- %1 = add i32 %a, %b
- ret i32 %1
-}
-
-define i32 @test_call_fastcc(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: test_call_fastcc:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s1, 8(sp)
-; RV32I-NEXT:    mv s1, a0
-; RV32I-NEXT:    lui a0, %hi(fastcc_function)
-; RV32I-NEXT:    addi a2, a0, %lo(fastcc_function)
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    lw s1, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call fastcc i32 @fastcc_function(i32 %a, i32 %b)
-  ret i32 %a
-}
-
-declare i32 @external_many_args(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) nounwind
-
-define i32 @test_call_external_many_args(i32 %a) nounwind {
-; RV32I-LABEL: test_call_external_many_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s1, 8(sp)
-; RV32I-NEXT:    mv s1, a0
-; RV32I-NEXT:    sw a0, 4(sp)
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    lui a0, %hi(external_many_args)
-; RV32I-NEXT:    addi t0, a0, %lo(external_many_args)
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    mv a1, s1
-; RV32I-NEXT:    mv a2, s1
-; RV32I-NEXT:    mv a3, s1
-; RV32I-NEXT:    mv a4, s1
-; RV32I-NEXT:    mv a5, s1
-; RV32I-NEXT:    mv a6, s1
-; RV32I-NEXT:    mv a7, s1
-; RV32I-NEXT:    jalr t0
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    lw s1, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @external_many_args(i32 %a, i32 %a, i32 %a, i32 %a, i32 %a,
-                                    i32 %a, i32 %a, i32 %a, i32 %a, i32 %a)
-  ret i32 %a
-}
-
-define i32 @defined_many_args(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 %j) nounwind {
-; RV32I-LABEL: defined_many_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a0, 4(sp)
-; RV32I-NEXT:    addi a0, a0, 1
-; RV32I-NEXT:    ret
-  %added = add i32 %j, 1
-  ret i32 %added
-}
-
-define i32 @test_call_defined_many_args(i32 %a) nounwind {
-; RV32I-LABEL: test_call_defined_many_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw a0, 4(sp)
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    lui a1, %hi(defined_many_args)
-; RV32I-NEXT:    addi t0, a1, %lo(defined_many_args)
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    mv a3, a0
-; RV32I-NEXT:    mv a4, a0
-; RV32I-NEXT:    mv a5, a0
-; RV32I-NEXT:    mv a6, a0
-; RV32I-NEXT:    mv a7, a0
-; RV32I-NEXT:    jalr t0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i32 @defined_many_args(i32 %a, i32 %a, i32 %a, i32 %a, i32 %a,
-                                   i32 %a, i32 %a, i32 %a, i32 %a, i32 %a)
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/div.ll b/test/CodeGen/RISCV/div.ll
deleted file mode 100644
index 96484459ecc..00000000000
--- a/test/CodeGen/RISCV/div.ll
+++ /dev/null
@@ -1,241 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IM %s
-
-define i32 @udiv(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: udiv:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__udivsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__udivsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    divu a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = udiv i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @udiv_constant(i32 %a) nounwind {
-; RV32I-LABEL: udiv_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(__udivsi3)
-; RV32I-NEXT:    addi a2, a1, %lo(__udivsi3)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    lui a1, 838861
-; RV32IM-NEXT:    addi a1, a1, -819
-; RV32IM-NEXT:    mulhu a0, a0, a1
-; RV32IM-NEXT:    srli a0, a0, 2
-; RV32IM-NEXT:    ret
-  %1 = udiv i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @udiv_pow2(i32 %a) nounwind {
-; RV32I-LABEL: udiv_pow2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srli a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv_pow2:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    srli a0, a0, 3
-; RV32IM-NEXT:    ret
-  %1 = udiv i32 %a, 8
-  ret i32 %1
-}
-
-define i64 @udiv64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: udiv64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a4, %hi(__udivdi3)
-; RV32I-NEXT:    addi a4, a4, %lo(__udivdi3)
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv64:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    lui a4, %hi(__udivdi3)
-; RV32IM-NEXT:    addi a4, a4, %lo(__udivdi3)
-; RV32IM-NEXT:    jalr a4
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = udiv i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @udiv64_constant(i64 %a) nounwind {
-; RV32I-LABEL: udiv64_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__udivdi3)
-; RV32I-NEXT:    addi a4, a2, %lo(__udivdi3)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: udiv64_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    lui a2, %hi(__udivdi3)
-; RV32IM-NEXT:    addi a4, a2, %lo(__udivdi3)
-; RV32IM-NEXT:    addi a2, zero, 5
-; RV32IM-NEXT:    mv a3, zero
-; RV32IM-NEXT:    jalr a4
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = udiv i64 %a, 5
-  ret i64 %1
-}
-
-define i32 @sdiv(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: sdiv:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__divsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__divsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    div a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = sdiv i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @sdiv_constant(i32 %a) nounwind {
-; RV32I-LABEL: sdiv_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(__divsi3)
-; RV32I-NEXT:    addi a2, a1, %lo(__divsi3)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    lui a1, 419430
-; RV32IM-NEXT:    addi a1, a1, 1639
-; RV32IM-NEXT:    mulh a0, a0, a1
-; RV32IM-NEXT:    srli a1, a0, 31
-; RV32IM-NEXT:    srai a0, a0, 1
-; RV32IM-NEXT:    add a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = sdiv i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @sdiv_pow2(i32 %a) nounwind {
-; RV32I-LABEL: sdiv_pow2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a1, a0, 31
-; RV32I-NEXT:    srli a1, a1, 29
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    srai a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv_pow2:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    srai a1, a0, 31
-; RV32IM-NEXT:    srli a1, a1, 29
-; RV32IM-NEXT:    add a0, a0, a1
-; RV32IM-NEXT:    srai a0, a0, 3
-; RV32IM-NEXT:    ret
-  %1 = sdiv i32 %a, 8
-  ret i32 %1
-}
-
-define i64 @sdiv64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: sdiv64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a4, %hi(__divdi3)
-; RV32I-NEXT:    addi a4, a4, %lo(__divdi3)
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv64:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    lui a4, %hi(__divdi3)
-; RV32IM-NEXT:    addi a4, a4, %lo(__divdi3)
-; RV32IM-NEXT:    jalr a4
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = sdiv i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @sdiv64_constant(i64 %a) nounwind {
-; RV32I-LABEL: sdiv64_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__divdi3)
-; RV32I-NEXT:    addi a4, a2, %lo(__divdi3)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: sdiv64_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi sp, sp, -16
-; RV32IM-NEXT:    sw ra, 12(sp)
-; RV32IM-NEXT:    lui a2, %hi(__divdi3)
-; RV32IM-NEXT:    addi a4, a2, %lo(__divdi3)
-; RV32IM-NEXT:    addi a2, zero, 5
-; RV32IM-NEXT:    mv a3, zero
-; RV32IM-NEXT:    jalr a4
-; RV32IM-NEXT:    lw ra, 12(sp)
-; RV32IM-NEXT:    addi sp, sp, 16
-; RV32IM-NEXT:    ret
-  %1 = sdiv i64 %a, 5
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/fp128.ll b/test/CodeGen/RISCV/fp128.ll
deleted file mode 100644
index e8a34fda8f8..00000000000
--- a/test/CodeGen/RISCV/fp128.ll
+++ /dev/null
@@ -1,128 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-@x = local_unnamed_addr global fp128 0xL00000000000000007FFF000000000000, align 16
-@y = local_unnamed_addr global fp128 0xL00000000000000007FFF000000000000, align 16
-
-; Besides anything else, these tests help verify that libcall ABI lowering
-; works correctly
-
-define i32 @test_load_and_cmp() nounwind {
-; RV32I-LABEL: test_load_and_cmp:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 44(sp)
-; RV32I-NEXT:    lui a0, %hi(y+12)
-; RV32I-NEXT:    addi a0, a0, %lo(y+12)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 20(sp)
-; RV32I-NEXT:    lui a0, %hi(y+8)
-; RV32I-NEXT:    addi a0, a0, %lo(y+8)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    lui a0, %hi(y+4)
-; RV32I-NEXT:    addi a0, a0, %lo(y+4)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lui a0, %hi(y)
-; RV32I-NEXT:    addi a0, a0, %lo(y)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 8(sp)
-; RV32I-NEXT:    lui a0, %hi(x+12)
-; RV32I-NEXT:    addi a0, a0, %lo(x+12)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 36(sp)
-; RV32I-NEXT:    lui a0, %hi(x+8)
-; RV32I-NEXT:    addi a0, a0, %lo(x+8)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 32(sp)
-; RV32I-NEXT:    lui a0, %hi(x+4)
-; RV32I-NEXT:    addi a0, a0, %lo(x+4)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 28(sp)
-; RV32I-NEXT:    lui a0, %hi(x)
-; RV32I-NEXT:    addi a0, a0, %lo(x)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 24(sp)
-; RV32I-NEXT:    lui a0, %hi(__netf2)
-; RV32I-NEXT:    addi a2, a0, %lo(__netf2)
-; RV32I-NEXT:    addi a0, sp, 24
-; RV32I-NEXT:    addi a1, sp, 8
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    xor a0, a0, zero
-; RV32I-NEXT:    snez a0, a0
-; RV32I-NEXT:    lw ra, 44(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-  %1 = load fp128, fp128* @x, align 16
-  %2 = load fp128, fp128* @y, align 16
-  %cmp = fcmp une fp128 %1, %2
-  %3 = zext i1 %cmp to i32
-  ret i32 %3
-}
-
-define i32 @test_add_and_fptosi() nounwind {
-; RV32I-LABEL: test_add_and_fptosi:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -80
-; RV32I-NEXT:    sw ra, 76(sp)
-; RV32I-NEXT:    lui a0, %hi(y+12)
-; RV32I-NEXT:    addi a0, a0, %lo(y+12)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 36(sp)
-; RV32I-NEXT:    lui a0, %hi(y+8)
-; RV32I-NEXT:    addi a0, a0, %lo(y+8)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 32(sp)
-; RV32I-NEXT:    lui a0, %hi(y+4)
-; RV32I-NEXT:    addi a0, a0, %lo(y+4)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 28(sp)
-; RV32I-NEXT:    lui a0, %hi(y)
-; RV32I-NEXT:    addi a0, a0, %lo(y)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 24(sp)
-; RV32I-NEXT:    lui a0, %hi(x+12)
-; RV32I-NEXT:    addi a0, a0, %lo(x+12)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 52(sp)
-; RV32I-NEXT:    lui a0, %hi(x+8)
-; RV32I-NEXT:    addi a0, a0, %lo(x+8)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 48(sp)
-; RV32I-NEXT:    lui a0, %hi(x+4)
-; RV32I-NEXT:    addi a0, a0, %lo(x+4)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 44(sp)
-; RV32I-NEXT:    lui a0, %hi(x)
-; RV32I-NEXT:    addi a0, a0, %lo(x)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    sw a0, 40(sp)
-; RV32I-NEXT:    lui a0, %hi(__addtf3)
-; RV32I-NEXT:    addi a3, a0, %lo(__addtf3)
-; RV32I-NEXT:    addi a0, sp, 56
-; RV32I-NEXT:    addi a1, sp, 40
-; RV32I-NEXT:    addi a2, sp, 24
-; RV32I-NEXT:    jalr a3
-; RV32I-NEXT:    lw a0, 68(sp)
-; RV32I-NEXT:    sw a0, 20(sp)
-; RV32I-NEXT:    lw a0, 64(sp)
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    lw a0, 60(sp)
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lw a0, 56(sp)
-; RV32I-NEXT:    sw a0, 8(sp)
-; RV32I-NEXT:    lui a0, %hi(__fixtfsi)
-; RV32I-NEXT:    addi a1, a0, %lo(__fixtfsi)
-; RV32I-NEXT:    addi a0, sp, 8
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw ra, 76(sp)
-; RV32I-NEXT:    addi sp, sp, 80
-; RV32I-NEXT:    ret
-  %1 = load fp128, fp128* @x, align 16
-  %2 = load fp128, fp128* @y, align 16
-  %3 = fadd fp128 %1, %2
-  %4 = fptosi fp128 %3 to i32
-  ret i32 %4
-}
diff --git a/test/CodeGen/RISCV/frame.ll b/test/CodeGen/RISCV/frame.ll
deleted file mode 100644
index 11dc784426e..00000000000
--- a/test/CodeGen/RISCV/frame.ll
+++ /dev/null
@@ -1,58 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -disable-fp-elim -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-%struct.key_t = type { i32, [16 x i8] }
-
-define i32 @test() nounwind {
-; RV32I-FPELIM-LABEL: test:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 24(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 20(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 16(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 12(sp)
-; RV32I-FPELIM-NEXT:    sw zero, 8(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(test1)
-; RV32I-FPELIM-NEXT:    addi a1, a0, %lo(test1)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 12
-; RV32I-FPELIM-NEXT:    jalr a1
-; RV32I-FPELIM-NEXT:    mv a0, zero
-; RV32I-FPELIM-NEXT:    lw ra, 28(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: test:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -32
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    sw zero, -16(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -20(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -24(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -28(s0)
-; RV32I-WITHFP-NEXT:    sw zero, -32(s0)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(test1)
-; RV32I-WITHFP-NEXT:    addi a1, a0, %lo(test1)
-; RV32I-WITHFP-NEXT:    addi a0, s0, -28
-; RV32I-WITHFP-NEXT:    jalr a1
-; RV32I-WITHFP-NEXT:    mv a0, zero
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 32
-; RV32I-WITHFP-NEXT:    ret
-  %key = alloca %struct.key_t, align 4
-  %1 = bitcast %struct.key_t* %key to i8*
-  call void @llvm.memset.p0i8.i64(i8* align 4 %1, i8 0, i64 20, i1 false)
-  %2 = getelementptr inbounds %struct.key_t, %struct.key_t* %key, i64 0, i32 1, i64 0
-  call void @test1(i8* %2) #3
-  ret i32 0
-}
-
-declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i1)
-
-declare void @test1(i8*)
diff --git a/test/CodeGen/RISCV/frameaddr-returnaddr.ll b/test/CodeGen/RISCV/frameaddr-returnaddr.ll
deleted file mode 100644
index ab9e4bf6891..00000000000
--- a/test/CodeGen/RISCV/frameaddr-returnaddr.ll
+++ /dev/null
@@ -1,92 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-declare void @notdead(i8*)
-declare i8* @llvm.frameaddress(i32)
-declare i8* @llvm.returnaddress(i32)
-
-define i8* @test_frameaddress_0() nounwind {
-; RV32I-LABEL: test_frameaddress_0:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    mv a0, s0
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i8* @llvm.frameaddress(i32 0)
-  ret i8* %1
-}
-
-define i8* @test_frameaddress_2() nounwind {
-; RV32I-LABEL: test_frameaddress_2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    lw a0, -8(s0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i8* @llvm.frameaddress(i32 2)
-  ret i8* %1
-}
-
-define i8* @test_frameaddress_3_alloca() nounwind {
-; RV32I-LABEL: test_frameaddress_3_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -112
-; RV32I-NEXT:    sw ra, 108(sp)
-; RV32I-NEXT:    sw s0, 104(sp)
-; RV32I-NEXT:    addi s0, sp, 112
-; RV32I-NEXT:    lui a0, %hi(notdead)
-; RV32I-NEXT:    addi a1, a0, %lo(notdead)
-; RV32I-NEXT:    addi a0, s0, -108
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw a0, -8(s0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw s0, 104(sp)
-; RV32I-NEXT:    lw ra, 108(sp)
-; RV32I-NEXT:    addi sp, sp, 112
-; RV32I-NEXT:    ret
-  %1 = alloca [100 x i8]
-  %2 = bitcast [100 x i8]* %1 to i8*
-  call void @notdead(i8* %2)
-  %3 = call i8* @llvm.frameaddress(i32 3)
-  ret i8* %3
-}
-
-define i8* @test_returnaddress_0() nounwind {
-; RV32I-LABEL: test_returnaddress_0:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    mv a0, ra
-; RV32I-NEXT:    ret
-  %1 = call i8* @llvm.returnaddress(i32 0)
-  ret i8* %1
-}
-
-define i8* @test_returnaddress_2() nounwind {
-; RV32I-LABEL: test_returnaddress_2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    lw a0, -8(s0)
-; RV32I-NEXT:    lw a0, -8(a0)
-; RV32I-NEXT:    lw a0, -4(a0)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = call i8* @llvm.returnaddress(i32 2)
-  ret i8* %1
-}
diff --git a/test/CodeGen/RISCV/get-setcc-result-type.ll b/test/CodeGen/RISCV/get-setcc-result-type.ll
deleted file mode 100644
index 003f3b367cf..00000000000
--- a/test/CodeGen/RISCV/get-setcc-result-type.ll
+++ /dev/null
@@ -1,35 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define void @getSetCCResultType(<4 x i32>* %p, <4 x i32>* %q) {
-; RV32I-LABEL: getSetCCResultType:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    lw a1, 12(a0)
-; RV32I-NEXT:    xor a1, a1, zero
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 12(a0)
-; RV32I-NEXT:    lw a1, 8(a0)
-; RV32I-NEXT:    xor a1, a1, zero
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 8(a0)
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    xor a1, a1, zero
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 4(a0)
-; RV32I-NEXT:    lw a1, 0(a0)
-; RV32I-NEXT:    xor a1, a1, zero
-; RV32I-NEXT:    seqz a1, a1
-; RV32I-NEXT:    neg a1, a1
-; RV32I-NEXT:    sw a1, 0(a0)
-; RV32I-NEXT:    ret
-entry:
-  %0 = load <4 x i32>, <4 x i32>* %p, align 16
-  %cmp = icmp eq <4 x i32> %0, zeroinitializer
-  %sext = sext <4 x i1> %cmp to <4 x i32>
-  store <4 x i32> %sext, <4 x i32>* %p, align 16
-  ret void
-}
diff --git a/test/CodeGen/RISCV/i32-icmp.ll b/test/CodeGen/RISCV/i32-icmp.ll
deleted file mode 100644
index e1154948812..00000000000
--- a/test/CodeGen/RISCV/i32-icmp.ll
+++ /dev/null
@@ -1,114 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; TODO: check the generated instructions for the equivalent of seqz, snez,
-; sltz, sgtz map to something simple
-
-define i32 @icmp_eq(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_eq:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    seqz a0, a0
-; RV32I-NEXT:    ret
-  %1 = icmp eq i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ne(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ne:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    xor a0, a0, a1
-; RV32I-NEXT:    snez a0, a0
-; RV32I-NEXT:    ret
-  %1 = icmp ne i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ugt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ugt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a1, a0
-; RV32I-NEXT:    ret
-  %1 = icmp ugt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_uge(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_uge:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp uge i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ult(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ult:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = icmp ult i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_ule(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_ule:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sltu a0, a1, a0
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp ule i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_sgt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_sgt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a1, a0
-; RV32I-NEXT:    ret
-  %1 = icmp sgt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_sge(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_sge:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp sge i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_slt(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_slt:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = icmp slt i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-define i32 @icmp_sle(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: icmp_sle:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slt a0, a1, a0
-; RV32I-NEXT:    xori a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = icmp sle i32 %a, %b
-  %2 = zext i1 %1 to i32
-  ret i32 %2
-}
-
-; TODO: check variants with an immediate?
diff --git a/test/CodeGen/RISCV/imm.ll b/test/CodeGen/RISCV/imm.ll
deleted file mode 100644
index dca1c5e1e1e..00000000000
--- a/test/CodeGen/RISCV/imm.ll
+++ /dev/null
@@ -1,47 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Materializing constants
-
-define i32 @zero() nounwind {
-; RV32I-LABEL: zero:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    ret
-  ret i32 0
-}
-
-define i32 @pos_small() nounwind {
-; RV32I-LABEL: pos_small:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, 2047
-; RV32I-NEXT:    ret
-  ret i32 2047
-}
-
-define i32 @neg_small() nounwind {
-; RV32I-LABEL: neg_small:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a0, zero, -2048
-; RV32I-NEXT:    ret
-  ret i32 -2048
-}
-
-define i32 @pos_i32() nounwind {
-; RV32I-LABEL: pos_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 423811
-; RV32I-NEXT:    addi a0, a0, -1297
-; RV32I-NEXT:    ret
-  ret i32 1735928559
-}
-
-define i32 @neg_i32() nounwind {
-; RV32I-LABEL: neg_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, 912092
-; RV32I-NEXT:    addi a0, a0, -273
-; RV32I-NEXT:    ret
-  ret i32 -559038737
-}
diff --git a/test/CodeGen/RISCV/indirectbr.ll b/test/CodeGen/RISCV/indirectbr.ll
deleted file mode 100644
index 7ba63dfe9dc..00000000000
--- a/test/CodeGen/RISCV/indirectbr.ll
+++ /dev/null
@@ -1,40 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define i32 @indirectbr(i8* %target) nounwind {
-; RV32I-LABEL: indirectbr:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    jr a0
-; RV32I-NEXT:  .LBB0_1: # %ret
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  indirectbr i8* %target, [label %test_label]
-test_label:
-  br label %ret
-ret:
-  ret i32 0
-}
-
-define i32 @indirectbr_with_offset(i8* %a) nounwind {
-; RV32I-LABEL: indirectbr_with_offset:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    jalr zero, a0, 1380
-; RV32I-NEXT:  .LBB1_1: # %ret
-; RV32I-NEXT:    mv a0, zero
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %target = getelementptr inbounds i8, i8* %a, i32 1380
-  indirectbr i8* %target, [label %test_label]
-test_label:
-  br label %ret
-ret:
-  ret i32 0
-}
diff --git a/test/CodeGen/RISCV/inline-asm.ll b/test/CodeGen/RISCV/inline-asm.ll
deleted file mode 100644
index 5c46b82321e..00000000000
--- a/test/CodeGen/RISCV/inline-asm.ll
+++ /dev/null
@@ -1,55 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-@gi = external global i32
-
-define i32 @constraint_r(i32 %a) {
-; RV32I-LABEL: constraint_r:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, %hi(gi)
-; RV32I-NEXT:    addi a1, a1, %lo(gi)
-; RV32I-NEXT:    lw a1, 0(a1)
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  %1 = load i32, i32* @gi
-  %2 = tail call i32 asm "add $0, $1, $2", "=r,r,r"(i32 %a, i32 %1)
-  ret i32 %2
-}
-
-define i32 @constraint_i(i32 %a) {
-; RV32I-LABEL: constraint_i:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    addi a0, a0, 113
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  %1 = load i32, i32* @gi
-  %2 = tail call i32 asm "addi $0, $1, $2", "=r,r,i"(i32 %a, i32 113)
-  ret i32 %2
-}
-
-define void @constraint_m(i32* %a) {
-; RV32I-LABEL: constraint_m:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  call void asm sideeffect "", "=*m"(i32* %a)
-  ret void
-}
-
-define i32 @constraint_m2(i32* %a) {
-; RV32I-LABEL: constraint_m2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    #APP
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    #NO_APP
-; RV32I-NEXT:    ret
-  %1 = tail call i32 asm "lw $0, $1", "=r,*m"(i32* %a) nounwind
-  ret i32 %1
-}
-
-; TODO: expend tests for more complex constraints, out of range immediates etc
diff --git a/test/CodeGen/RISCV/jumptable.ll b/test/CodeGen/RISCV/jumptable.ll
deleted file mode 100644
index f54f51edada..00000000000
--- a/test/CodeGen/RISCV/jumptable.ll
+++ /dev/null
@@ -1,58 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define void @jt(i32 %in, i32* %out) {
-; RV32I-LABEL: jt:
-; RV32I:       # %bb.0: # %entry
-; RV32I-NEXT:    addi a2, zero, 2
-; RV32I-NEXT:    blt a2, a0, .LBB0_4
-; RV32I-NEXT:  # %bb.1: # %entry
-; RV32I-NEXT:    addi a3, zero, 1
-; RV32I-NEXT:    beq a0, a3, .LBB0_7
-; RV32I-NEXT:  # %bb.2: # %entry
-; RV32I-NEXT:    bne a0, a2, .LBB0_9
-; RV32I-NEXT:  # %bb.3: # %bb2
-; RV32I-NEXT:    addi a0, zero, 3
-; RV32I-NEXT:    sw a0, 0(a1)
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_4: # %entry
-; RV32I-NEXT:    addi a3, zero, 3
-; RV32I-NEXT:    beq a0, a3, .LBB0_8
-; RV32I-NEXT:  # %bb.5: # %entry
-; RV32I-NEXT:    addi a2, zero, 4
-; RV32I-NEXT:    bne a0, a2, .LBB0_9
-; RV32I-NEXT:  # %bb.6: # %bb4
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    sw a0, 0(a1)
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_7: # %bb1
-; RV32I-NEXT:    addi a0, zero, 4
-; RV32I-NEXT:    sw a0, 0(a1)
-; RV32I-NEXT:    ret
-; RV32I-NEXT:  .LBB0_8: # %bb3
-; RV32I-NEXT:    sw a2, 0(a1)
-; RV32I-NEXT:  .LBB0_9: # %exit
-; RV32I-NEXT:    ret
-entry:
-  switch i32 %in, label %exit [
-    i32 1, label %bb1
-    i32 2, label %bb2
-    i32 3, label %bb3
-    i32 4, label %bb4
-  ]
-bb1:
-  store i32 4, i32* %out
-  br label %exit
-bb2:
-  store i32 3, i32* %out
-  br label %exit
-bb3:
-  store i32 2, i32* %out
-  br label %exit
-bb4:
-  store i32 1, i32* %out
-  br label %exit
-exit:
-  ret void
-}
diff --git a/test/CodeGen/RISCV/large-stack.ll b/test/CodeGen/RISCV/large-stack.ll
deleted file mode 100644
index 51130fc2a94..00000000000
--- a/test/CodeGen/RISCV/large-stack.ll
+++ /dev/null
@@ -1,172 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -disable-fp-elim < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-; TODO: the quality of the generated code is poor
-
-define void @test() nounwind {
-; RV32I-FPELIM-LABEL: test:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a0, 74565
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1664
-; RV32I-FPELIM-NEXT:    sub sp, sp, a0
-; RV32I-FPELIM-NEXT:    lui a0, 74565
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1664
-; RV32I-FPELIM-NEXT:    add sp, sp, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: test:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1680
-; RV32I-WITHFP-NEXT:    sub sp, sp, a0
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1676
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    sw ra, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1672
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    sw s0, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1680
-; RV32I-WITHFP-NEXT:    add s0, sp, a0
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1672
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s0, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1676
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw ra, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 74565
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1680
-; RV32I-WITHFP-NEXT:    add sp, sp, a0
-; RV32I-WITHFP-NEXT:    ret
-  %tmp = alloca [ 305419896 x i8 ] , align 4
-  ret void
-}
-
-; This test case artificially produces register pressure which should force
-; use of the emergency spill slot.
-
-define void @test_emergency_spill_slot(i32 %a) nounwind {
-; RV32I-FPELIM-LABEL: test_emergency_spill_slot:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    lui a1, 98
-; RV32I-FPELIM-NEXT:    addi a1, a1, -1392
-; RV32I-FPELIM-NEXT:    sub sp, sp, a1
-; RV32I-FPELIM-NEXT:    lui a1, 98
-; RV32I-FPELIM-NEXT:    addi a1, a1, -1396
-; RV32I-FPELIM-NEXT:    add a1, sp, a1
-; RV32I-FPELIM-NEXT:    sw s1, 0(a1)
-; RV32I-FPELIM-NEXT:    lui a1, 98
-; RV32I-FPELIM-NEXT:    addi a1, a1, -1400
-; RV32I-FPELIM-NEXT:    add a1, sp, a1
-; RV32I-FPELIM-NEXT:    sw s2, 0(a1)
-; RV32I-FPELIM-NEXT:    lui a1, 78
-; RV32I-FPELIM-NEXT:    addi a1, a1, 512
-; RV32I-FPELIM-NEXT:    addi a2, sp, 8
-; RV32I-FPELIM-NEXT:    add a1, a2, a1
-; RV32I-FPELIM-NEXT:    #APP
-; RV32I-FPELIM-NEXT:    nop
-; RV32I-FPELIM-NEXT:    #NO_APP
-; RV32I-FPELIM-NEXT:    sw a0, 0(a1)
-; RV32I-FPELIM-NEXT:    #APP
-; RV32I-FPELIM-NEXT:    nop
-; RV32I-FPELIM-NEXT:    #NO_APP
-; RV32I-FPELIM-NEXT:    lui a0, 98
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1400
-; RV32I-FPELIM-NEXT:    add a0, sp, a0
-; RV32I-FPELIM-NEXT:    lw s2, 0(a0)
-; RV32I-FPELIM-NEXT:    lui a0, 98
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1396
-; RV32I-FPELIM-NEXT:    add a0, sp, a0
-; RV32I-FPELIM-NEXT:    lw s1, 0(a0)
-; RV32I-FPELIM-NEXT:    lui a0, 98
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1392
-; RV32I-FPELIM-NEXT:    add sp, sp, a0
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: test_emergency_spill_slot:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1376
-; RV32I-WITHFP-NEXT:    sub sp, sp, a1
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1380
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw ra, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1384
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw s0, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1388
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw s1, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1392
-; RV32I-WITHFP-NEXT:    add a1, sp, a1
-; RV32I-WITHFP-NEXT:    sw s2, 0(a1)
-; RV32I-WITHFP-NEXT:    lui a1, 98
-; RV32I-WITHFP-NEXT:    addi a1, a1, -1376
-; RV32I-WITHFP-NEXT:    add s0, sp, a1
-; RV32I-WITHFP-NEXT:    lui a1, 78
-; RV32I-WITHFP-NEXT:    addi a1, a1, 512
-; RV32I-WITHFP-NEXT:    lui a2, 1048478
-; RV32I-WITHFP-NEXT:    addi a2, a2, 1388
-; RV32I-WITHFP-NEXT:    add a2, s0, a2
-; RV32I-WITHFP-NEXT:    mv a2, a2
-; RV32I-WITHFP-NEXT:    add a1, a2, a1
-; RV32I-WITHFP-NEXT:    #APP
-; RV32I-WITHFP-NEXT:    nop
-; RV32I-WITHFP-NEXT:    #NO_APP
-; RV32I-WITHFP-NEXT:    sw a0, 0(a1)
-; RV32I-WITHFP-NEXT:    #APP
-; RV32I-WITHFP-NEXT:    nop
-; RV32I-WITHFP-NEXT:    #NO_APP
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1392
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s2, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1388
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s1, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1384
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw s0, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1380
-; RV32I-WITHFP-NEXT:    add a0, sp, a0
-; RV32I-WITHFP-NEXT:    lw ra, 0(a0)
-; RV32I-WITHFP-NEXT:    lui a0, 98
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1376
-; RV32I-WITHFP-NEXT:    add sp, sp, a0
-; RV32I-WITHFP-NEXT:    ret
-  %data = alloca [ 100000 x i32 ] , align 4
-  %ptr = getelementptr inbounds [100000 x i32], [100000 x i32]* %data, i32 0, i32 80000
-  %1 = tail call { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } asm sideeffect "nop", "=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r,=r"()
-  %asmresult0 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 0
-  %asmresult1 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 1
-  %asmresult2 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 2
-  %asmresult3 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 3
-  %asmresult4 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 4
-  %asmresult5 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 5
-  %asmresult6 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 6
-  %asmresult7 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 7
-  %asmresult8 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 8
-  %asmresult9 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 9
-  %asmresult10 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 10
-  %asmresult11 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 11
-  %asmresult12 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 12
-  %asmresult13 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 13
-  %asmresult14 = extractvalue { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 } %1, 14
-  store volatile i32 %a, i32* %ptr
-  tail call void asm sideeffect "nop", "r,r,r,r,r,r,r,r,r,r,r,r,r,r,r"(i32 %asmresult0, i32 %asmresult1, i32 %asmresult2, i32 %asmresult3, i32 %asmresult4, i32 %asmresult5, i32 %asmresult6, i32 %asmresult7, i32 %asmresult8, i32 %asmresult9, i32 %asmresult10, i32 %asmresult11, i32 %asmresult12, i32 %asmresult13, i32 %asmresult14)
-  ret void
-}
diff --git a/test/CodeGen/RISCV/lit.local.cfg b/test/CodeGen/RISCV/lit.local.cfg
deleted file mode 100644
index c63820126f8..00000000000
--- a/test/CodeGen/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
diff --git a/test/CodeGen/RISCV/mem.ll b/test/CodeGen/RISCV/mem.ll
deleted file mode 100644
index 60c19dea10f..00000000000
--- a/test/CodeGen/RISCV/mem.ll
+++ /dev/null
@@ -1,202 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Check indexed and unindexed, sext, zext and anyext loads
-
-define i32 @lb(i8 *%a) nounwind {
-; RV32I-LABEL: lb:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lb a1, 0(a0)
-; RV32I-NEXT:    lb a0, 1(a0)
-; RV32I-NEXT:    ret
-  %1 = getelementptr i8, i8* %a, i32 1
-  %2 = load i8, i8* %1
-  %3 = sext i8 %2 to i32
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i8, i8* %a
-  ret i32 %3
-}
-
-define i32 @lh(i16 *%a) nounwind {
-; RV32I-LABEL: lh:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lh a1, 0(a0)
-; RV32I-NEXT:    lh a0, 4(a0)
-; RV32I-NEXT:    ret
-  %1 = getelementptr i16, i16* %a, i32 2
-  %2 = load i16, i16* %1
-  %3 = sext i16 %2 to i32
-  ; the unused load will produce an anyext for selection
-  %4 = load volatile i16, i16* %a
-  ret i32 %3
-}
-
-define i32 @lw(i32 *%a) nounwind {
-; RV32I-LABEL: lw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a1, 0(a0)
-; RV32I-NEXT:    lw a0, 12(a0)
-; RV32I-NEXT:    ret
-  %1 = getelementptr i32, i32* %a, i32 3
-  %2 = load i32, i32* %1
-  %3 = load volatile i32, i32* %a
-  ret i32 %2
-}
-
-define i32 @lbu(i8 *%a) nounwind {
-; RV32I-LABEL: lbu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lbu a1, 0(a0)
-; RV32I-NEXT:    lbu a0, 4(a0)
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = getelementptr i8, i8* %a, i32 4
-  %2 = load i8, i8* %1
-  %3 = zext i8 %2 to i32
-  %4 = load volatile i8, i8* %a
-  %5 = zext i8 %4 to i32
-  %6 = add i32 %3, %5
-  ret i32 %6
-}
-
-define i32 @lhu(i16 *%a) nounwind {
-; RV32I-LABEL: lhu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lhu a1, 0(a0)
-; RV32I-NEXT:    lhu a0, 10(a0)
-; RV32I-NEXT:    add a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = getelementptr i16, i16* %a, i32 5
-  %2 = load i16, i16* %1
-  %3 = zext i16 %2 to i32
-  %4 = load volatile i16, i16* %a
-  %5 = zext i16 %4 to i32
-  %6 = add i32 %3, %5
-  ret i32 %6
-}
-
-; Check indexed and unindexed stores
-
-define void @sb(i8 *%a, i8 %b) nounwind {
-; RV32I-LABEL: sb:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sb a1, 6(a0)
-; RV32I-NEXT:    sb a1, 0(a0)
-; RV32I-NEXT:    ret
-  store i8 %b, i8* %a
-  %1 = getelementptr i8, i8* %a, i32 6
-  store i8 %b, i8* %1
-  ret void
-}
-
-define void @sh(i16 *%a, i16 %b) nounwind {
-; RV32I-LABEL: sh:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sh a1, 14(a0)
-; RV32I-NEXT:    sh a1, 0(a0)
-; RV32I-NEXT:    ret
-  store i16 %b, i16* %a
-  %1 = getelementptr i16, i16* %a, i32 7
-  store i16 %b, i16* %1
-  ret void
-}
-
-define void @sw(i32 *%a, i32 %b) nounwind {
-; RV32I-LABEL: sw:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    sw a1, 32(a0)
-; RV32I-NEXT:    sw a1, 0(a0)
-; RV32I-NEXT:    ret
-  store i32 %b, i32* %a
-  %1 = getelementptr i32, i32* %a, i32 8
-  store i32 %b, i32* %1
-  ret void
-}
-
-; Check load and store to an i1 location
-define i32 @load_sext_zext_anyext_i1(i1 *%a) nounwind {
-; RV32I-LABEL: load_sext_zext_anyext_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lb a1, 0(a0)
-; RV32I-NEXT:    lbu a1, 1(a0)
-; RV32I-NEXT:    lbu a0, 2(a0)
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-  ; sextload i1
-  %1 = getelementptr i1, i1* %a, i32 1
-  %2 = load i1, i1* %1
-  %3 = sext i1 %2 to i32
-  ; zextload i1
-  %4 = getelementptr i1, i1* %a, i32 2
-  %5 = load i1, i1* %4
-  %6 = zext i1 %5 to i32
-  %7 = add i32 %3, %6
-  ; extload i1 (anyext). Produced as the load is unused.
-  %8 = load volatile i1, i1* %a
-  ret i32 %7
-}
-
-define i16 @load_sext_zext_anyext_i1_i16(i1 *%a) nounwind {
-; RV32I-LABEL: load_sext_zext_anyext_i1_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lb a1, 0(a0)
-; RV32I-NEXT:    lbu a1, 1(a0)
-; RV32I-NEXT:    lbu a0, 2(a0)
-; RV32I-NEXT:    sub a0, a0, a1
-; RV32I-NEXT:    ret
-  ; sextload i1
-  %1 = getelementptr i1, i1* %a, i32 1
-  %2 = load i1, i1* %1
-  %3 = sext i1 %2 to i16
-  ; zextload i1
-  %4 = getelementptr i1, i1* %a, i32 2
-  %5 = load i1, i1* %4
-  %6 = zext i1 %5 to i16
-  %7 = add i16 %3, %6
-  ; extload i1 (anyext). Produced as the load is unused.
-  %8 = load volatile i1, i1* %a
-  ret i16 %7
-}
-
-; Check load and store to a global
-@G = global i32 0
-
-define i32 @lw_sw_global(i32 %a) nounwind {
-; TODO: the addi should be folded in to the lw/sw operations
-; RV32I-LABEL: lw_sw_global:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, %hi(G)
-; RV32I-NEXT:    addi a2, a1, %lo(G)
-; RV32I-NEXT:    lw a1, 0(a2)
-; RV32I-NEXT:    sw a0, 0(a2)
-; RV32I-NEXT:    lui a2, %hi(G+36)
-; RV32I-NEXT:    addi a2, a2, %lo(G+36)
-; RV32I-NEXT:    lw a3, 0(a2)
-; RV32I-NEXT:    sw a0, 0(a2)
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = load volatile i32, i32* @G
-  store i32 %a, i32* @G
-  %2 = getelementptr i32, i32* @G, i32 9
-  %3 = load volatile i32, i32* %2
-  store i32 %a, i32* %2
-  ret i32 %1
-}
-
-; Ensure that 1 is added to the high 20 bits if bit 11 of the low part is 1
-define i32 @lw_sw_constant(i32 %a) nounwind {
-; TODO: the addi should be folded in to the lw/sw
-; RV32I-LABEL: lw_sw_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 912092
-; RV32I-NEXT:    addi a2, a1, -273
-; RV32I-NEXT:    lw a1, 0(a2)
-; RV32I-NEXT:    sw a0, 0(a2)
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    ret
-  %1 = inttoptr i32 3735928559 to i32*
-  %2 = load volatile i32, i32* %1
-  store i32 %a, i32* %1
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/mul.ll b/test/CodeGen/RISCV/mul.ll
deleted file mode 100644
index e1b2f6f7c2e..00000000000
--- a/test/CodeGen/RISCV/mul.ll
+++ /dev/null
@@ -1,189 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IM %s
-
-define i32 @square(i32 %a) nounwind {
-; RV32I-LABEL: square:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a1, %lo(__mulsi3)
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: square:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mul a0, a0, a0
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, %a
-  ret i32 %1
-}
-
-define i32 @mul(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: mul:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__mulsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mul a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @mul_constant(i32 %a) nounwind {
-; RV32I-LABEL: mul_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a1, %hi(__mulsi3)
-; RV32I-NEXT:    addi a2, a1, %lo(__mulsi3)
-; RV32I-NEXT:    addi a1, zero, 5
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi a1, zero, 5
-; RV32IM-NEXT:    mul a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, 5
-  ret i32 %1
-}
-
-define i32 @mul_pow2(i32 %a) nounwind {
-; RV32I-LABEL: mul_pow2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 3
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul_pow2:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    slli a0, a0, 3
-; RV32IM-NEXT:    ret
-  %1 = mul i32 %a, 8
-  ret i32 %1
-}
-
-define i64 @mul64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: mul64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a4, %hi(__muldi3)
-; RV32I-NEXT:    addi a4, a4, %lo(__muldi3)
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul64:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mul a3, a0, a3
-; RV32IM-NEXT:    mulhu a4, a0, a2
-; RV32IM-NEXT:    add a3, a4, a3
-; RV32IM-NEXT:    mul a1, a1, a2
-; RV32IM-NEXT:    add a1, a3, a1
-; RV32IM-NEXT:    mul a0, a0, a2
-; RV32IM-NEXT:    ret
-  %1 = mul i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @mul64_constant(i64 %a) nounwind {
-; RV32I-LABEL: mul64_constant:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__muldi3)
-; RV32I-NEXT:    addi a4, a2, %lo(__muldi3)
-; RV32I-NEXT:    addi a2, zero, 5
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mul64_constant:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    addi a2, zero, 5
-; RV32IM-NEXT:    mul a1, a1, a2
-; RV32IM-NEXT:    mulhu a3, a0, a2
-; RV32IM-NEXT:    add a1, a3, a1
-; RV32IM-NEXT:    mul a0, a0, a2
-; RV32IM-NEXT:    ret
-  %1 = mul i64 %a, 5
-  ret i64 %1
-}
-
-define i32 @mulhs(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: mulhs:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, a1
-; RV32I-NEXT:    lui a1, %hi(__muldi3)
-; RV32I-NEXT:    addi a4, a1, %lo(__muldi3)
-; RV32I-NEXT:    srai a1, a0, 31
-; RV32I-NEXT:    srai a3, a2, 31
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mulhs:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mulh a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = sext i32 %a to i64
-  %2 = sext i32 %b to i64
-  %3 = mul i64 %1, %2
-  %4 = lshr i64 %3, 32
-  %5 = trunc i64 %4 to i32
-  ret i32 %5
-}
-
-define i32 @mulhu(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: mulhu:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    mv a2, a1
-; RV32I-NEXT:    lui a1, %hi(__muldi3)
-; RV32I-NEXT:    addi a4, a1, %lo(__muldi3)
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    mv a3, zero
-; RV32I-NEXT:    jalr a4
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: mulhu:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    mulhu a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = zext i32 %a to i64
-  %2 = zext i32 %b to i64
-  %3 = mul i64 %1, %2
-  %4 = lshr i64 %3, 32
-  %5 = trunc i64 %4 to i32
-  ret i32 %5
-}
diff --git a/test/CodeGen/RISCV/rem.ll b/test/CodeGen/RISCV/rem.ll
deleted file mode 100644
index f9ef4c9c8e6..00000000000
--- a/test/CodeGen/RISCV/rem.ll
+++ /dev/null
@@ -1,45 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32IM %s
-
-define i32 @urem(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: urem:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__umodsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__umodsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: urem:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    remu a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = urem i32 %a, %b
-  ret i32 %1
-}
-
-define i32 @srem(i32 %a, i32 %b) nounwind {
-; RV32I-LABEL: srem:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a2, %hi(__modsi3)
-; RV32I-NEXT:    addi a2, a2, %lo(__modsi3)
-; RV32I-NEXT:    jalr a2
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-;
-; RV32IM-LABEL: srem:
-; RV32IM:       # %bb.0:
-; RV32IM-NEXT:    rem a0, a0, a1
-; RV32IM-NEXT:    ret
-  %1 = srem i32 %a, %b
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/rotl-rotr.ll b/test/CodeGen/RISCV/rotl-rotr.ll
deleted file mode 100644
index 49b540eb2b1..00000000000
--- a/test/CodeGen/RISCV/rotl-rotr.ll
+++ /dev/null
@@ -1,38 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; These IR sequences will generate ISD::ROTL and ISD::ROTR nodes, that the
-; RISC-V backend must be able to select
-
-define i32 @rotl(i32 %x, i32 %y) {
-; RV32I-LABEL: rotl:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a2, zero, 32
-; RV32I-NEXT:    sub a2, a2, a1
-; RV32I-NEXT:    sll a1, a0, a1
-; RV32I-NEXT:    srl a0, a0, a2
-; RV32I-NEXT:    or a0, a1, a0
-; RV32I-NEXT:    ret
-  %z = sub i32 32, %y
-  %b = shl i32 %x, %y
-  %c = lshr i32 %x, %z
-  %d = or i32 %b, %c
-  ret i32 %d
-}
-
-define i32 @rotr(i32 %x, i32 %y) {
-; RV32I-LABEL: rotr:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi a2, zero, 32
-; RV32I-NEXT:    sub a2, a2, a1
-; RV32I-NEXT:    srl a1, a0, a1
-; RV32I-NEXT:    sll a0, a0, a2
-; RV32I-NEXT:    or a0, a1, a0
-; RV32I-NEXT:    ret
-  %z = sub i32 32, %y
-  %b = lshr i32 %x, %y
-  %c = shl i32 %x, %z
-  %d = or i32 %b, %c
-  ret i32 %d
-}
diff --git a/test/CodeGen/RISCV/select-cc.ll b/test/CodeGen/RISCV/select-cc.ll
deleted file mode 100644
index 96eb6ff1010..00000000000
--- a/test/CodeGen/RISCV/select-cc.ll
+++ /dev/null
@@ -1,100 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -disable-block-placement -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I %s
-
-define i32 @foo(i32 %a, i32 *%b) {
-; RV32I-LABEL: foo:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    beq a0, a2, .LBB0_2
-; RV32I-NEXT:  # %bb.1:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_2:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bne a0, a2, .LBB0_4
-; RV32I-NEXT:  # %bb.3:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_4:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bltu a2, a0, .LBB0_6
-; RV32I-NEXT:  # %bb.5:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_6:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bgeu a0, a2, .LBB0_8
-; RV32I-NEXT:  # %bb.7:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_8:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bltu a0, a2, .LBB0_10
-; RV32I-NEXT:  # %bb.9:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_10:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bgeu a2, a0, .LBB0_12
-; RV32I-NEXT:  # %bb.11:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_12:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    blt a2, a0, .LBB0_14
-; RV32I-NEXT:  # %bb.13:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_14:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    bge a0, a2, .LBB0_16
-; RV32I-NEXT:  # %bb.15:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_16:
-; RV32I-NEXT:    lw a2, 0(a1)
-; RV32I-NEXT:    blt a0, a2, .LBB0_18
-; RV32I-NEXT:  # %bb.17:
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:  .LBB0_18:
-; RV32I-NEXT:    lw a1, 0(a1)
-; RV32I-NEXT:    bge a1, a0, .LBB0_20
-; RV32I-NEXT:  # %bb.19:
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:  .LBB0_20:
-; RV32I-NEXT:    ret
-  %val1 = load volatile i32, i32* %b
-  %tst1 = icmp eq i32 %a, %val1
-  %val2 = select i1 %tst1, i32 %a, i32 %val1
-
-  %val3 = load volatile i32, i32* %b
-  %tst2 = icmp ne i32 %val2, %val3
-  %val4 = select i1 %tst2, i32 %val2, i32 %val3
-
-  %val5 = load volatile i32, i32* %b
-  %tst3 = icmp ugt i32 %val4, %val5
-  %val6 = select i1 %tst3, i32 %val4, i32 %val5
-
-  %val7 = load volatile i32, i32* %b
-  %tst4 = icmp uge i32 %val6, %val7
-  %val8 = select i1 %tst4, i32 %val6, i32 %val7
-
-  %val9 = load volatile i32, i32* %b
-  %tst5 = icmp ult i32 %val8, %val9
-  %val10 = select i1 %tst5, i32 %val8, i32 %val9
-
-  %val11 = load volatile i32, i32* %b
-  %tst6 = icmp ule i32 %val10, %val11
-  %val12 = select i1 %tst6, i32 %val10, i32 %val11
-
-  %val13 = load volatile i32, i32* %b
-  %tst7 = icmp sgt i32 %val12, %val13
-  %val14 = select i1 %tst7, i32 %val12, i32 %val13
-
-  %val15 = load volatile i32, i32* %b
-  %tst8 = icmp sge i32 %val14, %val15
-  %val16 = select i1 %tst8, i32 %val14, i32 %val15
-
-  %val17 = load volatile i32, i32* %b
-  %tst9 = icmp slt i32 %val16, %val17
-  %val18 = select i1 %tst9, i32 %val16, i32 %val17
-
-  %val19 = load volatile i32, i32* %b
-  %tst10 = icmp sle i32 %val18, %val19
-  %val20 = select i1 %tst10, i32 %val18, i32 %val19
-
-  ret i32 %val20
-}
diff --git a/test/CodeGen/RISCV/sext-zext-trunc.ll b/test/CodeGen/RISCV/sext-zext-trunc.ll
deleted file mode 100644
index 88d0fedea98..00000000000
--- a/test/CodeGen/RISCV/sext-zext-trunc.ll
+++ /dev/null
@@ -1,285 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-define i8 @sext_i1_to_i8(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    ret
-  %1 = sext i1 %a to i8
-  ret i8 %1
-}
-
-define i16 @sext_i1_to_i16(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    ret
-  %1 = sext i1 %a to i16
-  ret i16 %1
-}
-
-define i32 @sext_i1_to_i32(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    ret
-  %1 = sext i1 %a to i32
-  ret i32 %1
-}
-
-define i64 @sext_i1_to_i64(i1 %a) {
-; RV32I-LABEL: sext_i1_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    neg a0, a0
-; RV32I-NEXT:    mv a1, a0
-; RV32I-NEXT:    ret
-  %1 = sext i1 %a to i64
-  ret i64 %1
-}
-
-define i16 @sext_i8_to_i16(i8 %a) {
-; RV32I-LABEL: sext_i8_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i16
-  ret i16 %1
-}
-
-define i32 @sext_i8_to_i32(i8 %a) {
-; RV32I-LABEL: sext_i8_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 24
-; RV32I-NEXT:    srai a0, a0, 24
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i32
-  ret i32 %1
-}
-
-define i64 @sext_i8_to_i64(i8 %a) {
-; RV32I-LABEL: sext_i8_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a0, 24
-; RV32I-NEXT:    srai a0, a1, 24
-; RV32I-NEXT:    srai a1, a1, 31
-; RV32I-NEXT:    ret
-  %1 = sext i8 %a to i64
-  ret i64 %1
-}
-
-define i32 @sext_i16_to_i32(i16 %a) {
-; RV32I-LABEL: sext_i16_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a0, a0, 16
-; RV32I-NEXT:    srai a0, a0, 16
-; RV32I-NEXT:    ret
-  %1 = sext i16 %a to i32
-  ret i32 %1
-}
-
-define i64 @sext_i16_to_i64(i16 %a) {
-; RV32I-LABEL: sext_i16_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    slli a1, a0, 16
-; RV32I-NEXT:    srai a0, a1, 16
-; RV32I-NEXT:    srai a1, a1, 31
-; RV32I-NEXT:    ret
-  %1 = sext i16 %a to i64
-  ret i64 %1
-}
-
-define i64 @sext_i32_to_i64(i32 %a) {
-; RV32I-LABEL: sext_i32_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    srai a1, a0, 31
-; RV32I-NEXT:    ret
-  %1 = sext i32 %a to i64
-  ret i64 %1
-}
-
-define i8 @zext_i1_to_i8(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = zext i1 %a to i8
-  ret i8 %1
-}
-
-define i16 @zext_i1_to_i16(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = zext i1 %a to i16
-  ret i16 %1
-}
-
-define i32 @zext_i1_to_i32(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    ret
-  %1 = zext i1 %a to i32
-  ret i32 %1
-}
-
-define i64 @zext_i1_to_i64(i1 %a) {
-; RV32I-LABEL: zext_i1_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 1
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = zext i1 %a to i64
-  ret i64 %1
-}
-
-define i16 @zext_i8_to_i16(i8 %a) {
-; RV32I-LABEL: zext_i8_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i16
-  ret i16 %1
-}
-
-define i32 @zext_i8_to_i32(i8 %a) {
-; RV32I-LABEL: zext_i8_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i32
-  ret i32 %1
-}
-
-define i64 @zext_i8_to_i64(i8 %a) {
-; RV32I-LABEL: zext_i8_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    andi a0, a0, 255
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = zext i8 %a to i64
-  ret i64 %1
-}
-
-define i32 @zext_i16_to_i32(i16 %a) {
-; RV32I-LABEL: zext_i16_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    ret
-  %1 = zext i16 %a to i32
-  ret i32 %1
-}
-
-define i64 @zext_i16_to_i64(i16 %a) {
-; RV32I-LABEL: zext_i16_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a1, 16
-; RV32I-NEXT:    addi a1, a1, -1
-; RV32I-NEXT:    and a0, a0, a1
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = zext i16 %a to i64
-  ret i64 %1
-}
-
-define i64 @zext_i32_to_i64(i32 %a) {
-; RV32I-LABEL: zext_i32_to_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    ret
-  %1 = zext i32 %a to i64
-  ret i64 %1
-}
-
-; TODO: should the trunc tests explicitly ensure no code is generated before
-; jalr?
-
-define i1 @trunc_i8_to_i1(i8 %a) {
-; RV32I-LABEL: trunc_i8_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i8 %a to i1
-  ret i1 %1
-}
-
-define i1 @trunc_i16_to_i1(i16 %a) {
-; RV32I-LABEL: trunc_i16_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i16 %a to i1
-  ret i1 %1
-}
-
-define i1 @trunc_i32_to_i1(i32 %a) {
-; RV32I-LABEL: trunc_i32_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i1
-  ret i1 %1
-}
-
-define i1 @trunc_i64_to_i1(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i64 %a to i1
-  ret i1 %1
-}
-
-define i8 @trunc_i16_to_i8(i16 %a) {
-; RV32I-LABEL: trunc_i16_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i16 %a to i8
-  ret i8 %1
-}
-
-define i8 @trunc_i32_to_i8(i32 %a) {
-; RV32I-LABEL: trunc_i32_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i8
-  ret i8 %1
-}
-
-define i8 @trunc_i64_to_i8(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i8:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i64 %a to i8
-  ret i8 %1
-}
-
-define i16 @trunc_i32_to_i16(i32 %a) {
-; RV32I-LABEL: trunc_i32_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i32 %a to i16
-  ret i16 %1
-}
-
-define i16 @trunc_i64_to_i16(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i16:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i64 %a to i16
-  ret i16 %1
-}
-
-define i32 @trunc_i64_to_i32(i64 %a) {
-; RV32I-LABEL: trunc_i64_to_i32:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    ret
-  %1 = trunc i64 %a to i32
-  ret i32 %1
-}
diff --git a/test/CodeGen/RISCV/shifts.ll b/test/CodeGen/RISCV/shifts.ll
deleted file mode 100644
index 0a3e07e11b5..00000000000
--- a/test/CodeGen/RISCV/shifts.ll
+++ /dev/null
@@ -1,51 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Basic shift support is tested as part of ALU.ll. This file ensures that
-; shifts which may not be supported natively are lowered properly.
-
-define i64 @lshr64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: lshr64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a3, %hi(__lshrdi3)
-; RV32I-NEXT:    addi a3, a3, %lo(__lshrdi3)
-; RV32I-NEXT:    jalr a3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = lshr i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @ashr64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: ashr64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a3, %hi(__ashrdi3)
-; RV32I-NEXT:    addi a3, a3, %lo(__ashrdi3)
-; RV32I-NEXT:    jalr a3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = ashr i64 %a, %b
-  ret i64 %1
-}
-
-define i64 @shl64(i64 %a, i64 %b) nounwind {
-; RV32I-LABEL: shl64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a3, %hi(__ashldi3)
-; RV32I-NEXT:    addi a3, a3, %lo(__ashldi3)
-; RV32I-NEXT:    jalr a3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-  %1 = shl i64 %a, %b
-  ret i64 %1
-}
diff --git a/test/CodeGen/RISCV/vararg.ll b/test/CodeGen/RISCV/vararg.ll
deleted file mode 100644
index 61a6178e095..00000000000
--- a/test/CodeGen/RISCV/vararg.ll
+++ /dev/null
@@ -1,1171 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-FPELIM %s
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs -disable-fp-elim < %s \
-; RUN:   | FileCheck -check-prefix=RV32I-WITHFP %s
-
-declare void @llvm.va_start(i8*)
-declare void @llvm.va_end(i8*)
-
-declare void @notdead(i8*)
-
-; Although frontends are recommended to not generate va_arg due to the lack of
-; support for aggregate types, we test simple cases here to ensure they are
-; lowered correctly
-
-define i32 @va1(i8* %fmt, ...) nounwind {
-; RV32I-LABEL: va1:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    sw a7, 44(sp)
-; RV32I-NEXT:    sw a6, 40(sp)
-; RV32I-NEXT:    sw a5, 36(sp)
-; RV32I-NEXT:    sw a4, 32(sp)
-; RV32I-NEXT:    sw a3, 28(sp)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    addi a0, sp, 24
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lw a0, 20(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va1:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 24
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 8
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a0, 4(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %argp.cur = load i8*, i8** %va, align 4
-  %argp.next = getelementptr inbounds i8, i8* %argp.cur, i32 4
-  store i8* %argp.next, i8** %va, align 4
-  %2 = bitcast i8* %argp.cur to i32*
-  %3 = load i32, i32* %2, align 4
-  call void @llvm.va_end(i8* %1)
-  ret i32 %3
-}
-
-define i32 @va1_va_arg(i8* %fmt, ...) nounwind {
-; RV32I-LABEL: va1_va_arg:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    sw a7, 44(sp)
-; RV32I-NEXT:    sw a6, 40(sp)
-; RV32I-NEXT:    sw a5, 36(sp)
-; RV32I-NEXT:    sw a4, 32(sp)
-; RV32I-NEXT:    sw a3, 28(sp)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    addi a0, sp, 24
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lw a0, 20(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va1_va_arg:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 24
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1_va_arg:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 8
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a0, 4(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, i32
-  call void @llvm.va_end(i8* %1)
-  ret i32 %2
-}
-
-; Ensure the adjustment when restoring the stack pointer using the frame
-; pointer is correct
-define i32 @va1_va_arg_alloca(i8* %fmt, ...) nounwind {
-; RV32I-LABEL: va1_va_arg_alloca:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s0, 8(sp)
-; RV32I-NEXT:    sw s1, 4(sp)
-; RV32I-NEXT:    addi s0, sp, 16
-; RV32I-NEXT:    sw a1, 4(s0)
-; RV32I-NEXT:    sw a7, 28(s0)
-; RV32I-NEXT:    sw a6, 24(s0)
-; RV32I-NEXT:    sw a5, 20(s0)
-; RV32I-NEXT:    sw a4, 16(s0)
-; RV32I-NEXT:    sw a3, 12(s0)
-; RV32I-NEXT:    sw a2, 8(s0)
-; RV32I-NEXT:    addi a0, s0, 8
-; RV32I-NEXT:    sw a0, -16(s0)
-; RV32I-NEXT:    lw s1, 4(s0)
-; RV32I-NEXT:    addi a0, s1, 15
-; RV32I-NEXT:    andi a0, a0, -16
-; RV32I-NEXT:    sub a0, sp, a0
-; RV32I-NEXT:    mv sp, a0
-; RV32I-NEXT:    lui a1, %hi(notdead)
-; RV32I-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    mv a0, s1
-; RV32I-NEXT:    addi sp, s0, -16
-; RV32I-NEXT:    lw s1, 4(sp)
-; RV32I-NEXT:    lw s0, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va1_va_arg_alloca:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    sw s0, 8(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 4(sp)
-; RV32I-FPELIM-NEXT:    addi s0, sp, 16
-; RV32I-FPELIM-NEXT:    sw a1, 4(s0)
-; RV32I-FPELIM-NEXT:    sw a7, 28(s0)
-; RV32I-FPELIM-NEXT:    sw a6, 24(s0)
-; RV32I-FPELIM-NEXT:    sw a5, 20(s0)
-; RV32I-FPELIM-NEXT:    sw a4, 16(s0)
-; RV32I-FPELIM-NEXT:    sw a3, 12(s0)
-; RV32I-FPELIM-NEXT:    sw a2, 8(s0)
-; RV32I-FPELIM-NEXT:    addi a0, s0, 8
-; RV32I-FPELIM-NEXT:    sw a0, -16(s0)
-; RV32I-FPELIM-NEXT:    lw s1, 4(s0)
-; RV32I-FPELIM-NEXT:    addi a0, s1, 15
-; RV32I-FPELIM-NEXT:    andi a0, a0, -16
-; RV32I-FPELIM-NEXT:    sub a0, sp, a0
-; RV32I-FPELIM-NEXT:    mv sp, a0
-; RV32I-FPELIM-NEXT:    lui a1, %hi(notdead)
-; RV32I-FPELIM-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-FPELIM-NEXT:    jalr a1
-; RV32I-FPELIM-NEXT:    mv a0, s1
-; RV32I-FPELIM-NEXT:    addi sp, s0, -16
-; RV32I-FPELIM-NEXT:    lw s1, 4(sp)
-; RV32I-FPELIM-NEXT:    lw s0, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1_va_arg_alloca:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 4(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 8
-; RV32I-WITHFP-NEXT:    sw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    lw s1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s1, 15
-; RV32I-WITHFP-NEXT:    andi a0, a0, -16
-; RV32I-WITHFP-NEXT:    sub a0, sp, a0
-; RV32I-WITHFP-NEXT:    mv sp, a0
-; RV32I-WITHFP-NEXT:    lui a1, %hi(notdead)
-; RV32I-WITHFP-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-WITHFP-NEXT:    jalr a1
-; RV32I-WITHFP-NEXT:    mv a0, s1
-; RV32I-WITHFP-NEXT:    addi sp, s0, -16
-; RV32I-WITHFP-NEXT:    lw s1, 4(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, i32
-  %3 = alloca i8, i32 %2
-  call void @notdead(i8* %3)
-  call void @llvm.va_end(i8* %1)
-  ret i32 %2
-}
-
-define void @va1_caller() nounwind {
-; RV32I-LABEL: va1_caller:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, 261888
-; RV32I-NEXT:    mv a3, a0
-; RV32I-NEXT:    lui a0, %hi(va1)
-; RV32I-NEXT:    addi a0, a0, %lo(va1)
-; RV32I-NEXT:    addi a4, zero, 2
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; Pass a double, as a float would be promoted by a C/C++ frontend
-; RV32I-FPELIM-LABEL: va1_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 261888
-; RV32I-FPELIM-NEXT:    mv a3, a0
-; RV32I-FPELIM-NEXT:    lui a0, %hi(va1)
-; RV32I-FPELIM-NEXT:    addi a0, a0, %lo(va1)
-; RV32I-FPELIM-NEXT:    addi a4, zero, 2
-; RV32I-FPELIM-NEXT:    mv a2, zero
-; RV32I-FPELIM-NEXT:    jalr a0
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va1_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 261888
-; RV32I-WITHFP-NEXT:    mv a3, a0
-; RV32I-WITHFP-NEXT:    lui a0, %hi(va1)
-; RV32I-WITHFP-NEXT:    addi a0, a0, %lo(va1)
-; RV32I-WITHFP-NEXT:    addi a4, zero, 2
-; RV32I-WITHFP-NEXT:    mv a2, zero
-; RV32I-WITHFP-NEXT:    jalr a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 (i8*, ...) @va1(i8* undef, double 1.0, i32 2)
-  ret void
-}
-
-; Ensure that 2x xlen size+alignment varargs are accessed via an "aligned"
-; register pair (where the first register is even-numbered).
-
-define double @va2(i8 *%fmt, ...) nounwind {
-; RV32I-LABEL: va2:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw a7, 44(sp)
-; RV32I-NEXT:    sw a6, 40(sp)
-; RV32I-NEXT:    sw a5, 36(sp)
-; RV32I-NEXT:    sw a4, 32(sp)
-; RV32I-NEXT:    sw a3, 28(sp)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    addi a0, sp, 35
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    addi a0, sp, 27
-; RV32I-NEXT:    andi a1, a0, -8
-; RV32I-NEXT:    lw a0, 0(a1)
-; RV32I-NEXT:    ori a1, a1, 4
-; RV32I-NEXT:    lw a1, 0(a1)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va2:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 35
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 27
-; RV32I-FPELIM-NEXT:    andi a1, a0, -8
-; RV32I-FPELIM-NEXT:    lw a0, 0(a1)
-; RV32I-FPELIM-NEXT:    ori a1, a1, 4
-; RV32I-FPELIM-NEXT:    lw a1, 0(a1)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va2:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 19
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 11
-; RV32I-WITHFP-NEXT:    andi a1, a0, -8
-; RV32I-WITHFP-NEXT:    lw a0, 0(a1)
-; RV32I-WITHFP-NEXT:    ori a1, a1, 4
-; RV32I-WITHFP-NEXT:    lw a1, 0(a1)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = bitcast i8** %va to i32*
-  %argp.cur = load i32, i32* %2, align 4
-  %3 = add i32 %argp.cur, 7
-  %4 = and i32 %3, -8
-  %argp.cur.aligned = inttoptr i32 %3 to i8*
-  %argp.next = getelementptr inbounds i8, i8* %argp.cur.aligned, i32 8
-  store i8* %argp.next, i8** %va, align 4
-  %5 = inttoptr i32 %4 to double*
-  %6 = load double, double* %5, align 8
-  call void @llvm.va_end(i8* %1)
-  ret double %6
-}
-
-define double @va2_va_arg(i8 *%fmt, ...) nounwind {
-; RV32I-LABEL: va2_va_arg:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw a7, 44(sp)
-; RV32I-NEXT:    sw a6, 40(sp)
-; RV32I-NEXT:    sw a5, 36(sp)
-; RV32I-NEXT:    sw a4, 32(sp)
-; RV32I-NEXT:    sw a3, 28(sp)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    addi a0, sp, 27
-; RV32I-NEXT:    andi a0, a0, -8
-; RV32I-NEXT:    ori a1, a0, 4
-; RV32I-NEXT:    sw a1, 12(sp)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    addi a2, a1, 4
-; RV32I-NEXT:    sw a2, 12(sp)
-; RV32I-NEXT:    lw a1, 0(a1)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va2_va_arg:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 27
-; RV32I-FPELIM-NEXT:    andi a0, a0, -8
-; RV32I-FPELIM-NEXT:    ori a1, a0, 4
-; RV32I-FPELIM-NEXT:    sw a1, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a2, a1, 4
-; RV32I-FPELIM-NEXT:    sw a2, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 0(a1)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va2_va_arg:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 11
-; RV32I-WITHFP-NEXT:    andi a0, a0, -8
-; RV32I-WITHFP-NEXT:    ori a1, a0, 4
-; RV32I-WITHFP-NEXT:    sw a1, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a2, a1, 4
-; RV32I-WITHFP-NEXT:    sw a2, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a1, 0(a1)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, double
-  call void @llvm.va_end(i8* %1)
-  ret double %2
-}
-
-define void @va2_caller() nounwind {
-; RV32I-LABEL: va2_caller:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, 261888
-; RV32I-NEXT:    mv a3, a0
-; RV32I-NEXT:    lui a0, %hi(va2)
-; RV32I-NEXT:    addi a0, a0, %lo(va2)
-; RV32I-NEXT:    mv a2, zero
-; RV32I-NEXT:    jalr a0
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va2_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 261888
-; RV32I-FPELIM-NEXT:    mv a3, a0
-; RV32I-FPELIM-NEXT:    lui a0, %hi(va2)
-; RV32I-FPELIM-NEXT:    addi a0, a0, %lo(va2)
-; RV32I-FPELIM-NEXT:    mv a2, zero
-; RV32I-FPELIM-NEXT:    jalr a0
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va2_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 261888
-; RV32I-WITHFP-NEXT:    mv a3, a0
-; RV32I-WITHFP-NEXT:    lui a0, %hi(va2)
-; RV32I-WITHFP-NEXT:    addi a0, a0, %lo(va2)
-; RV32I-WITHFP-NEXT:    mv a2, zero
-; RV32I-WITHFP-NEXT:    jalr a0
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
- %1 = call double (i8*, ...) @va2(i8* undef, double 1.000000e+00)
- ret void
-}
-
-; Ensure a named double argument is passed in a1 and a2, while the vararg
-; double is passed in a4 and a5 (rather than a3 and a4)
-
-define double @va3(i32 %a, double %b, ...) nounwind {
-; RV32I-LABEL: va3:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 4(sp)
-; RV32I-NEXT:    sw a7, 28(sp)
-; RV32I-NEXT:    sw a6, 24(sp)
-; RV32I-NEXT:    sw a5, 20(sp)
-; RV32I-NEXT:    sw a4, 16(sp)
-; RV32I-NEXT:    sw a3, 12(sp)
-; RV32I-NEXT:    addi a0, sp, 27
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    lui a0, %hi(__adddf3)
-; RV32I-NEXT:    addi a5, a0, %lo(__adddf3)
-; RV32I-NEXT:    addi a0, sp, 19
-; RV32I-NEXT:    andi a0, a0, -8
-; RV32I-NEXT:    lw a4, 0(a0)
-; RV32I-NEXT:    ori a0, a0, 4
-; RV32I-NEXT:    lw a3, 0(a0)
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    mv a1, a2
-; RV32I-NEXT:    mv a2, a4
-; RV32I-NEXT:    jalr a5
-; RV32I-NEXT:    lw ra, 4(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va3:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    sw a7, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 27
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(__adddf3)
-; RV32I-FPELIM-NEXT:    addi a5, a0, %lo(__adddf3)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 19
-; RV32I-FPELIM-NEXT:    andi a0, a0, -8
-; RV32I-FPELIM-NEXT:    lw a4, 0(a0)
-; RV32I-FPELIM-NEXT:    ori a0, a0, 4
-; RV32I-FPELIM-NEXT:    lw a3, 0(a0)
-; RV32I-FPELIM-NEXT:    mv a0, a1
-; RV32I-FPELIM-NEXT:    mv a1, a2
-; RV32I-FPELIM-NEXT:    mv a2, a4
-; RV32I-FPELIM-NEXT:    jalr a5
-; RV32I-FPELIM-NEXT:    lw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va3:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 24
-; RV32I-WITHFP-NEXT:    sw a7, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 19
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(__adddf3)
-; RV32I-WITHFP-NEXT:    addi a5, a0, %lo(__adddf3)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 11
-; RV32I-WITHFP-NEXT:    andi a0, a0, -8
-; RV32I-WITHFP-NEXT:    lw a4, 0(a0)
-; RV32I-WITHFP-NEXT:    ori a0, a0, 4
-; RV32I-WITHFP-NEXT:    lw a3, 0(a0)
-; RV32I-WITHFP-NEXT:    mv a0, a1
-; RV32I-WITHFP-NEXT:    mv a1, a2
-; RV32I-WITHFP-NEXT:    mv a2, a4
-; RV32I-WITHFP-NEXT:    jalr a5
-; RV32I-WITHFP-NEXT:    lw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = bitcast i8** %va to i32*
-  %argp.cur = load i32, i32* %2, align 4
-  %3 = add i32 %argp.cur, 7
-  %4 = and i32 %3, -8
-  %argp.cur.aligned = inttoptr i32 %3 to i8*
-  %argp.next = getelementptr inbounds i8, i8* %argp.cur.aligned, i32 8
-  store i8* %argp.next, i8** %va, align 4
-  %5 = inttoptr i32 %4 to double*
-  %6 = load double, double* %5, align 8
-  call void @llvm.va_end(i8* %1)
-  %7 = fadd double %b, %6
-  ret double %7
-}
-
-define double @va3_va_arg(i32 %a, double %b, ...) nounwind {
-; RV32I-LABEL: va3_va_arg:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw ra, 4(sp)
-; RV32I-NEXT:    sw a7, 28(sp)
-; RV32I-NEXT:    sw a6, 24(sp)
-; RV32I-NEXT:    sw a5, 20(sp)
-; RV32I-NEXT:    sw a4, 16(sp)
-; RV32I-NEXT:    sw a3, 12(sp)
-; RV32I-NEXT:    addi a0, sp, 19
-; RV32I-NEXT:    andi a0, a0, -8
-; RV32I-NEXT:    ori a3, a0, 4
-; RV32I-NEXT:    sw a3, 0(sp)
-; RV32I-NEXT:    lw a4, 0(a0)
-; RV32I-NEXT:    addi a0, a3, 4
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    lui a0, %hi(__adddf3)
-; RV32I-NEXT:    addi a5, a0, %lo(__adddf3)
-; RV32I-NEXT:    lw a3, 0(a3)
-; RV32I-NEXT:    mv a0, a1
-; RV32I-NEXT:    mv a1, a2
-; RV32I-NEXT:    mv a2, a4
-; RV32I-NEXT:    jalr a5
-; RV32I-NEXT:    lw ra, 4(sp)
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va3_va_arg:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    sw a7, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 12(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 19
-; RV32I-FPELIM-NEXT:    andi a0, a0, -8
-; RV32I-FPELIM-NEXT:    ori a3, a0, 4
-; RV32I-FPELIM-NEXT:    sw a3, 0(sp)
-; RV32I-FPELIM-NEXT:    lw a4, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a0, a3, 4
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, %hi(__adddf3)
-; RV32I-FPELIM-NEXT:    addi a5, a0, %lo(__adddf3)
-; RV32I-FPELIM-NEXT:    lw a3, 0(a3)
-; RV32I-FPELIM-NEXT:    mv a0, a1
-; RV32I-FPELIM-NEXT:    mv a1, a2
-; RV32I-FPELIM-NEXT:    mv a2, a4
-; RV32I-FPELIM-NEXT:    jalr a5
-; RV32I-FPELIM-NEXT:    lw ra, 4(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va3_va_arg:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 24
-; RV32I-WITHFP-NEXT:    sw a7, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 11
-; RV32I-WITHFP-NEXT:    andi a0, a0, -8
-; RV32I-WITHFP-NEXT:    ori a3, a0, 4
-; RV32I-WITHFP-NEXT:    sw a3, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a4, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a0, a3, 4
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lui a0, %hi(__adddf3)
-; RV32I-WITHFP-NEXT:    addi a5, a0, %lo(__adddf3)
-; RV32I-WITHFP-NEXT:    lw a3, 0(a3)
-; RV32I-WITHFP-NEXT:    mv a0, a1
-; RV32I-WITHFP-NEXT:    mv a1, a2
-; RV32I-WITHFP-NEXT:    mv a2, a4
-; RV32I-WITHFP-NEXT:    jalr a5
-; RV32I-WITHFP-NEXT:    lw s0, 16(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 20(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, double
-  call void @llvm.va_end(i8* %1)
-  %3 = fadd double %b, %2
-  ret double %3
-}
-
-define void @va3_caller() nounwind {
-; RV32I-LABEL: va3_caller:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -16
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    lui a0, 261888
-; RV32I-NEXT:    mv a2, a0
-; RV32I-NEXT:    lui a0, 262144
-; RV32I-NEXT:    mv a5, a0
-; RV32I-NEXT:    lui a0, %hi(va3)
-; RV32I-NEXT:    addi a3, a0, %lo(va3)
-; RV32I-NEXT:    addi a0, zero, 2
-; RV32I-NEXT:    mv a1, zero
-; RV32I-NEXT:    mv a4, zero
-; RV32I-NEXT:    jalr a3
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 16
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va3_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -16
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 261888
-; RV32I-FPELIM-NEXT:    mv a2, a0
-; RV32I-FPELIM-NEXT:    lui a0, 262144
-; RV32I-FPELIM-NEXT:    mv a5, a0
-; RV32I-FPELIM-NEXT:    lui a0, %hi(va3)
-; RV32I-FPELIM-NEXT:    addi a3, a0, %lo(va3)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 2
-; RV32I-FPELIM-NEXT:    mv a1, zero
-; RV32I-FPELIM-NEXT:    mv a4, zero
-; RV32I-FPELIM-NEXT:    jalr a3
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 16
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va3_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -16
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    lui a0, 261888
-; RV32I-WITHFP-NEXT:    mv a2, a0
-; RV32I-WITHFP-NEXT:    lui a0, 262144
-; RV32I-WITHFP-NEXT:    mv a5, a0
-; RV32I-WITHFP-NEXT:    lui a0, %hi(va3)
-; RV32I-WITHFP-NEXT:    addi a3, a0, %lo(va3)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 2
-; RV32I-WITHFP-NEXT:    mv a1, zero
-; RV32I-WITHFP-NEXT:    mv a4, zero
-; RV32I-WITHFP-NEXT:    jalr a3
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 16
-; RV32I-WITHFP-NEXT:    ret
- %1 = call double (i32, double, ...) @va3(i32 2, double 1.000000e+00, double 2.000000e+00)
- ret void
-}
-
-declare void @llvm.va_copy(i8*, i8*)
-
-define i32 @va4_va_copy(i32 %argno, ...) nounwind {
-; RV32I-LABEL: va4_va_copy:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw ra, 12(sp)
-; RV32I-NEXT:    sw s1, 8(sp)
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    sw a7, 44(sp)
-; RV32I-NEXT:    sw a6, 40(sp)
-; RV32I-NEXT:    sw a5, 36(sp)
-; RV32I-NEXT:    sw a4, 32(sp)
-; RV32I-NEXT:    sw a3, 28(sp)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    addi a0, sp, 24
-; RV32I-NEXT:    sw a0, 4(sp)
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    lw s1, 20(sp)
-; RV32I-NEXT:    lui a1, %hi(notdead)
-; RV32I-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-NEXT:    jalr a1
-; RV32I-NEXT:    lw a0, 4(sp)
-; RV32I-NEXT:    addi a0, a0, 3
-; RV32I-NEXT:    andi a0, a0, -4
-; RV32I-NEXT:    addi a1, a0, 4
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    lw a1, 0(a0)
-; RV32I-NEXT:    addi a0, a0, 7
-; RV32I-NEXT:    andi a0, a0, -4
-; RV32I-NEXT:    addi a2, a0, 4
-; RV32I-NEXT:    sw a2, 4(sp)
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    addi a0, a0, 7
-; RV32I-NEXT:    andi a0, a0, -4
-; RV32I-NEXT:    addi a3, a0, 4
-; RV32I-NEXT:    sw a3, 4(sp)
-; RV32I-NEXT:    add a1, a1, s1
-; RV32I-NEXT:    add a1, a1, a2
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    add a0, a1, a0
-; RV32I-NEXT:    lw s1, 8(sp)
-; RV32I-NEXT:    lw ra, 12(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va4_va_copy:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    sw s1, 8(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 24
-; RV32I-FPELIM-NEXT:    sw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lw s1, 20(sp)
-; RV32I-FPELIM-NEXT:    lui a1, %hi(notdead)
-; RV32I-FPELIM-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-FPELIM-NEXT:    jalr a1
-; RV32I-FPELIM-NEXT:    lw a0, 4(sp)
-; RV32I-FPELIM-NEXT:    addi a0, a0, 3
-; RV32I-FPELIM-NEXT:    andi a0, a0, -4
-; RV32I-FPELIM-NEXT:    addi a1, a0, 4
-; RV32I-FPELIM-NEXT:    sw a1, 4(sp)
-; RV32I-FPELIM-NEXT:    lw a1, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a0, a0, 7
-; RV32I-FPELIM-NEXT:    andi a0, a0, -4
-; RV32I-FPELIM-NEXT:    addi a2, a0, 4
-; RV32I-FPELIM-NEXT:    sw a2, 4(sp)
-; RV32I-FPELIM-NEXT:    lw a2, 0(a0)
-; RV32I-FPELIM-NEXT:    addi a0, a0, 7
-; RV32I-FPELIM-NEXT:    andi a0, a0, -4
-; RV32I-FPELIM-NEXT:    addi a3, a0, 4
-; RV32I-FPELIM-NEXT:    sw a3, 4(sp)
-; RV32I-FPELIM-NEXT:    add a1, a1, s1
-; RV32I-FPELIM-NEXT:    add a1, a1, a2
-; RV32I-FPELIM-NEXT:    lw a0, 0(a0)
-; RV32I-FPELIM-NEXT:    add a0, a1, a0
-; RV32I-FPELIM-NEXT:    lw s1, 8(sp)
-; RV32I-FPELIM-NEXT:    lw ra, 12(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va4_va_copy:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    sw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 32
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 8
-; RV32I-WITHFP-NEXT:    sw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    lw s1, 4(s0)
-; RV32I-WITHFP-NEXT:    lui a1, %hi(notdead)
-; RV32I-WITHFP-NEXT:    addi a1, a1, %lo(notdead)
-; RV32I-WITHFP-NEXT:    jalr a1
-; RV32I-WITHFP-NEXT:    lw a0, -16(s0)
-; RV32I-WITHFP-NEXT:    addi a0, a0, 3
-; RV32I-WITHFP-NEXT:    andi a0, a0, -4
-; RV32I-WITHFP-NEXT:    addi a1, a0, 4
-; RV32I-WITHFP-NEXT:    sw a1, -16(s0)
-; RV32I-WITHFP-NEXT:    lw a1, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a0, a0, 7
-; RV32I-WITHFP-NEXT:    andi a0, a0, -4
-; RV32I-WITHFP-NEXT:    addi a2, a0, 4
-; RV32I-WITHFP-NEXT:    sw a2, -16(s0)
-; RV32I-WITHFP-NEXT:    lw a2, 0(a0)
-; RV32I-WITHFP-NEXT:    addi a0, a0, 7
-; RV32I-WITHFP-NEXT:    andi a0, a0, -4
-; RV32I-WITHFP-NEXT:    addi a3, a0, 4
-; RV32I-WITHFP-NEXT:    sw a3, -16(s0)
-; RV32I-WITHFP-NEXT:    add a1, a1, s1
-; RV32I-WITHFP-NEXT:    add a1, a1, a2
-; RV32I-WITHFP-NEXT:    lw a0, 0(a0)
-; RV32I-WITHFP-NEXT:    add a0, a1, a0
-; RV32I-WITHFP-NEXT:    lw s1, 20(sp)
-; RV32I-WITHFP-NEXT:    lw s0, 24(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 28(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %vargs = alloca i8*, align 4
-  %wargs = alloca i8*, align 4
-  %1 = bitcast i8** %vargs to i8*
-  %2 = bitcast i8** %wargs to i8*
-  call void @llvm.va_start(i8* %1)
-  %3 = va_arg i8** %vargs, i32
-  call void @llvm.va_copy(i8* %2, i8* %1)
-  %4 = load i8*, i8** %wargs, align 4
-  call void @notdead(i8* %4)
-  %5 = va_arg i8** %vargs, i32
-  %6 = va_arg i8** %vargs, i32
-  %7 = va_arg i8** %vargs, i32
-  call void @llvm.va_end(i8* %1)
-  call void @llvm.va_end(i8* %2)
-  %add1 = add i32 %5, %3
-  %add2 = add i32 %add1, %6
-  %add3 = add i32 %add2, %7
-  ret i32 %add3
-}
-
-; Check 2x*xlen values are aligned appropriately when passed on the stack in a vararg call
-
-define i32 @va5_aligned_stack_callee(i32 %a, ...) nounwind {
-; RV32I-LABEL: va5_aligned_stack_callee:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -32
-; RV32I-NEXT:    sw a7, 28(sp)
-; RV32I-NEXT:    sw a6, 24(sp)
-; RV32I-NEXT:    sw a5, 20(sp)
-; RV32I-NEXT:    sw a4, 16(sp)
-; RV32I-NEXT:    sw a3, 12(sp)
-; RV32I-NEXT:    sw a2, 8(sp)
-; RV32I-NEXT:    sw a1, 4(sp)
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    addi sp, sp, 32
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va5_aligned_stack_callee:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -32
-; RV32I-FPELIM-NEXT:    sw a7, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 20(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 12(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 8(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 4(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi sp, sp, 32
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va5_aligned_stack_callee:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  ret i32 1
-}
-
-define void @va5_aligned_stack_caller() nounwind {
-; The double should be 8-byte aligned on the stack, but the two-element array
-; should only be 4-byte aligned
-; RV32I-LABEL: va5_aligned_stack_caller:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -64
-; RV32I-NEXT:    sw ra, 60(sp)
-; RV32I-NEXT:    addi a0, zero, 17
-; RV32I-NEXT:    sw a0, 24(sp)
-; RV32I-NEXT:    addi a0, zero, 16
-; RV32I-NEXT:    sw a0, 20(sp)
-; RV32I-NEXT:    addi a0, zero, 15
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    lui a0, 262236
-; RV32I-NEXT:    addi a0, a0, 655
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lui a0, 377487
-; RV32I-NEXT:    addi a0, a0, 1475
-; RV32I-NEXT:    sw a0, 8(sp)
-; RV32I-NEXT:    addi a0, zero, 14
-; RV32I-NEXT:    sw a0, 0(sp)
-; RV32I-NEXT:    lui a0, 262153
-; RV32I-NEXT:    addi a0, a0, 491
-; RV32I-NEXT:    sw a0, 44(sp)
-; RV32I-NEXT:    lui a0, 545260
-; RV32I-NEXT:    addi a0, a0, -1967
-; RV32I-NEXT:    sw a0, 40(sp)
-; RV32I-NEXT:    lui a0, 964690
-; RV32I-NEXT:    addi a0, a0, -328
-; RV32I-NEXT:    sw a0, 36(sp)
-; RV32I-NEXT:    lui a0, 335544
-; RV32I-NEXT:    addi a0, a0, 1311
-; RV32I-NEXT:    sw a0, 32(sp)
-; RV32I-NEXT:    lui a0, 688509
-; RV32I-NEXT:    addi a6, a0, -2048
-; RV32I-NEXT:    lui a0, %hi(va5_aligned_stack_callee)
-; RV32I-NEXT:    addi a5, a0, %lo(va5_aligned_stack_callee)
-; RV32I-NEXT:    addi a0, zero, 1
-; RV32I-NEXT:    addi a1, zero, 11
-; RV32I-NEXT:    addi a2, sp, 32
-; RV32I-NEXT:    addi a3, zero, 12
-; RV32I-NEXT:    addi a4, zero, 13
-; RV32I-NEXT:    addi a7, zero, 4
-; RV32I-NEXT:    jalr a5
-; RV32I-NEXT:    lw ra, 60(sp)
-; RV32I-NEXT:    addi sp, sp, 64
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va5_aligned_stack_caller:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -64
-; RV32I-FPELIM-NEXT:    sw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 17
-; RV32I-FPELIM-NEXT:    sw a0, 24(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 16
-; RV32I-FPELIM-NEXT:    sw a0, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 15
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262236
-; RV32I-FPELIM-NEXT:    addi a0, a0, 655
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 377487
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1475
-; RV32I-FPELIM-NEXT:    sw a0, 8(sp)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 14
-; RV32I-FPELIM-NEXT:    sw a0, 0(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 262153
-; RV32I-FPELIM-NEXT:    addi a0, a0, 491
-; RV32I-FPELIM-NEXT:    sw a0, 44(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 545260
-; RV32I-FPELIM-NEXT:    addi a0, a0, -1967
-; RV32I-FPELIM-NEXT:    sw a0, 40(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 964690
-; RV32I-FPELIM-NEXT:    addi a0, a0, -328
-; RV32I-FPELIM-NEXT:    sw a0, 36(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 335544
-; RV32I-FPELIM-NEXT:    addi a0, a0, 1311
-; RV32I-FPELIM-NEXT:    sw a0, 32(sp)
-; RV32I-FPELIM-NEXT:    lui a0, 688509
-; RV32I-FPELIM-NEXT:    addi a6, a0, -2048
-; RV32I-FPELIM-NEXT:    lui a0, %hi(va5_aligned_stack_callee)
-; RV32I-FPELIM-NEXT:    addi a5, a0, %lo(va5_aligned_stack_callee)
-; RV32I-FPELIM-NEXT:    addi a0, zero, 1
-; RV32I-FPELIM-NEXT:    addi a1, zero, 11
-; RV32I-FPELIM-NEXT:    addi a2, sp, 32
-; RV32I-FPELIM-NEXT:    addi a3, zero, 12
-; RV32I-FPELIM-NEXT:    addi a4, zero, 13
-; RV32I-FPELIM-NEXT:    addi a7, zero, 4
-; RV32I-FPELIM-NEXT:    jalr a5
-; RV32I-FPELIM-NEXT:    lw ra, 60(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 64
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va5_aligned_stack_caller:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -64
-; RV32I-WITHFP-NEXT:    sw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 64
-; RV32I-WITHFP-NEXT:    addi a0, zero, 17
-; RV32I-WITHFP-NEXT:    sw a0, 24(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 16
-; RV32I-WITHFP-NEXT:    sw a0, 20(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 15
-; RV32I-WITHFP-NEXT:    sw a0, 16(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262236
-; RV32I-WITHFP-NEXT:    addi a0, a0, 655
-; RV32I-WITHFP-NEXT:    sw a0, 12(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 377487
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1475
-; RV32I-WITHFP-NEXT:    sw a0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 14
-; RV32I-WITHFP-NEXT:    sw a0, 0(sp)
-; RV32I-WITHFP-NEXT:    lui a0, 262153
-; RV32I-WITHFP-NEXT:    addi a0, a0, 491
-; RV32I-WITHFP-NEXT:    sw a0, -20(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 545260
-; RV32I-WITHFP-NEXT:    addi a0, a0, -1967
-; RV32I-WITHFP-NEXT:    sw a0, -24(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 964690
-; RV32I-WITHFP-NEXT:    addi a0, a0, -328
-; RV32I-WITHFP-NEXT:    sw a0, -28(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 335544
-; RV32I-WITHFP-NEXT:    addi a0, a0, 1311
-; RV32I-WITHFP-NEXT:    sw a0, -32(s0)
-; RV32I-WITHFP-NEXT:    lui a0, 688509
-; RV32I-WITHFP-NEXT:    addi a6, a0, -2048
-; RV32I-WITHFP-NEXT:    lui a0, %hi(va5_aligned_stack_callee)
-; RV32I-WITHFP-NEXT:    addi a5, a0, %lo(va5_aligned_stack_callee)
-; RV32I-WITHFP-NEXT:    addi a0, zero, 1
-; RV32I-WITHFP-NEXT:    addi a1, zero, 11
-; RV32I-WITHFP-NEXT:    addi a2, s0, -32
-; RV32I-WITHFP-NEXT:    addi a3, zero, 12
-; RV32I-WITHFP-NEXT:    addi a4, zero, 13
-; RV32I-WITHFP-NEXT:    addi a7, zero, 4
-; RV32I-WITHFP-NEXT:    jalr a5
-; RV32I-WITHFP-NEXT:    lw s0, 56(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 60(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 64
-; RV32I-WITHFP-NEXT:    ret
-  %1 = call i32 (i32, ...) @va5_aligned_stack_callee(i32 1, i32 11,
-    fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13, i64 20000000000,
-    i32 14, double 2.720000e+00, i32 15, [2 x i32] [i32 16, i32 17])
-  ret void
-}
-
-; A function with no fixed arguments is not valid C, but can be
-; specified in LLVM IR. We must ensure the vararg save area is
-; still set up correctly.
-
-define i32 @va6_no_fixed_args(...) nounwind {
-; RV32I-LABEL: va6_no_fixed_args:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    addi sp, sp, -48
-; RV32I-NEXT:    sw a0, 16(sp)
-; RV32I-NEXT:    sw a7, 44(sp)
-; RV32I-NEXT:    sw a6, 40(sp)
-; RV32I-NEXT:    sw a5, 36(sp)
-; RV32I-NEXT:    sw a4, 32(sp)
-; RV32I-NEXT:    sw a3, 28(sp)
-; RV32I-NEXT:    sw a2, 24(sp)
-; RV32I-NEXT:    sw a1, 20(sp)
-; RV32I-NEXT:    addi a0, sp, 20
-; RV32I-NEXT:    sw a0, 12(sp)
-; RV32I-NEXT:    lw a0, 16(sp)
-; RV32I-NEXT:    addi sp, sp, 48
-; RV32I-NEXT:    ret
-; RV32I-FPELIM-LABEL: va6_no_fixed_args:
-; RV32I-FPELIM:       # %bb.0:
-; RV32I-FPELIM-NEXT:    addi sp, sp, -48
-; RV32I-FPELIM-NEXT:    sw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    sw a7, 44(sp)
-; RV32I-FPELIM-NEXT:    sw a6, 40(sp)
-; RV32I-FPELIM-NEXT:    sw a5, 36(sp)
-; RV32I-FPELIM-NEXT:    sw a4, 32(sp)
-; RV32I-FPELIM-NEXT:    sw a3, 28(sp)
-; RV32I-FPELIM-NEXT:    sw a2, 24(sp)
-; RV32I-FPELIM-NEXT:    sw a1, 20(sp)
-; RV32I-FPELIM-NEXT:    addi a0, sp, 20
-; RV32I-FPELIM-NEXT:    sw a0, 12(sp)
-; RV32I-FPELIM-NEXT:    lw a0, 16(sp)
-; RV32I-FPELIM-NEXT:    addi sp, sp, 48
-; RV32I-FPELIM-NEXT:    ret
-;
-; RV32I-WITHFP-LABEL: va6_no_fixed_args:
-; RV32I-WITHFP:       # %bb.0:
-; RV32I-WITHFP-NEXT:    addi sp, sp, -48
-; RV32I-WITHFP-NEXT:    sw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    sw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    addi s0, sp, 16
-; RV32I-WITHFP-NEXT:    sw a0, 0(s0)
-; RV32I-WITHFP-NEXT:    sw a7, 28(s0)
-; RV32I-WITHFP-NEXT:    sw a6, 24(s0)
-; RV32I-WITHFP-NEXT:    sw a5, 20(s0)
-; RV32I-WITHFP-NEXT:    sw a4, 16(s0)
-; RV32I-WITHFP-NEXT:    sw a3, 12(s0)
-; RV32I-WITHFP-NEXT:    sw a2, 8(s0)
-; RV32I-WITHFP-NEXT:    sw a1, 4(s0)
-; RV32I-WITHFP-NEXT:    addi a0, s0, 4
-; RV32I-WITHFP-NEXT:    sw a0, -12(s0)
-; RV32I-WITHFP-NEXT:    lw a0, 0(s0)
-; RV32I-WITHFP-NEXT:    lw s0, 8(sp)
-; RV32I-WITHFP-NEXT:    lw ra, 12(sp)
-; RV32I-WITHFP-NEXT:    addi sp, sp, 48
-; RV32I-WITHFP-NEXT:    ret
-  %va = alloca i8*, align 4
-  %1 = bitcast i8** %va to i8*
-  call void @llvm.va_start(i8* %1)
-  %2 = va_arg i8** %va, i32
-  call void @llvm.va_end(i8* %1)
-  ret i32 %2
-}
diff --git a/test/CodeGen/RISCV/wide-mem.ll b/test/CodeGen/RISCV/wide-mem.ll
deleted file mode 100644
index 92993f6d1e2..00000000000
--- a/test/CodeGen/RISCV/wide-mem.ll
+++ /dev/null
@@ -1,34 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
-; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
-; RUN:   | FileCheck %s -check-prefix=RV32I
-
-; Check load/store operations on values wider than what is natively supported
-
-define i64 @load_i64(i64 *%a) nounwind {
-; RV32I-LABEL: load_i64:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lw a2, 0(a0)
-; RV32I-NEXT:    lw a1, 4(a0)
-; RV32I-NEXT:    mv a0, a2
-; RV32I-NEXT:    ret
-  %1 = load i64, i64* %a
-  ret i64 %1
-}
-
-@val64 = local_unnamed_addr global i64 2863311530, align 8
-
-; TODO: codegen on this should be improved. It shouldn't be necessary to
-; generate two addi
-define i64 @load_i64_global() nounwind {
-; RV32I-LABEL: load_i64_global:
-; RV32I:       # %bb.0:
-; RV32I-NEXT:    lui a0, %hi(val64)
-; RV32I-NEXT:    addi a0, a0, %lo(val64)
-; RV32I-NEXT:    lw a0, 0(a0)
-; RV32I-NEXT:    lui a1, %hi(val64+4)
-; RV32I-NEXT:    addi a1, a1, %lo(val64+4)
-; RV32I-NEXT:    lw a1, 0(a1)
-; RV32I-NEXT:    ret
-  %1 = load i64, i64* @val64
-  ret i64 %1
-}
diff --git a/test/MC/RISCV/cnop.s b/test/MC/RISCV/cnop.s
deleted file mode 100644
index ff2acee8868..00000000000
--- a/test/MC/RISCV/cnop.s
+++ /dev/null
@@ -1,26 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d - | FileCheck -check-prefix=CHECK-INST %s
-
-# alpha and main are 8 byte alignment
-# but the alpha function's size is 6
-# So assembler will insert a c.nop to make sure 8 byte alignment.
-
-        .text
-       .p2align        3
-       .type   alpha,@function
-alpha:
-# BB#0:
-       addi    sp, sp, -16
-       c.lw    a0, 0(a0)
-# CHECK-INST: c.nop
-.Lfunc_end0:
-       .size   alpha, .Lfunc_end0-alpha
-                                        # -- End function
-       .globl  main
-       .p2align        3
-       .type   main,@function
-main:                                   # @main
-# BB#0:
-.Lfunc_end1:
-       .size   main, .Lfunc_end1-main
-                                        # -- End function
diff --git a/test/MC/RISCV/csr-aliases.s b/test/MC/RISCV/csr-aliases.s
deleted file mode 100644
index cc51e9536d3..00000000000
--- a/test/MC/RISCV/csr-aliases.s
+++ /dev/null
@@ -1,117 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=-f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=-f - \
-# RUN:     | FileCheck -check-prefix=CHECK-EXT-F-OFF %s
-
-
-# CHECK-INST: csrrs t0, 3, zero
-# CHECK-ALIAS: frcsr t0
-# CHECK-EXT-F:  frcsr t0
-# CHECK-EXT-F-OFF: csrr t0, 3
-csrrs t0, 3, zero
-
-# CHECK-INST: csrrw t1, 3, t2
-# CHECK-ALIAS: fscsr t1, t2
-# CHECK-EXT-F-ON: fscsr t1, t2
-# CHECK-EXT-F-OFF: csrrw t1, 3, t2
-csrrw t1, 3, t2
-
-# CHECK-INST: csrrw zero, 3, t2
-# CHECK-ALIAS: fscsr t2
-# CHECK-EXT-F-ON: fscsr t2
-# CHECK-EXT-F-OFF: csrw 3, t2
-csrrw zero, 3, t2
-
-# CHECK-INST: csrrw zero, 3, t2
-# CHECK-ALIAS: fscsr t2
-# CHECK-EXT-F-ON: fscsr t2
-# CHECK-EXT-F-OFF: csrw 3, t2
-csrrw zero, 3, t2
-
-# CHECK-INST: csrrw t0, 2, zero
-# CHECK-ALIAS: fsrm  t0, zero
-# CHECK-EXT-F-ON: fsrm t0, zero
-# CHECK-EXT-F-OFF: csrrw t0, 2, zero
-csrrw t0, 2, zero
-
-# CHECK-INST: csrrw t0, 2, t1
-# CHECK-ALIAS: fsrm t0, t1
-# CHECK-EXT-F-ON: fsrm t0, t1
-# CHECK-EXT-F-OFF: csrrw t0, 2, t1
-csrrw t0, 2, t1
-
-# CHECK-INST: csrrwi t0, 2, 31
-# CHECK-ALIAS: fsrmi t0, 31
-# CHECK-EXT-F-ON: fsrmi t0, 31
-# CHECK-EXT-F-OFF: csrrwi t0, 2, 31
-csrrwi t0, 2, 31
-
-# CHECK-INST: csrrwi zero, 2, 31
-# CHECK-ALIAS: fsrmi 31
-# CHECK-EXT-F-ON: fsrmi 31
-# CHECK-EXT-F-OFF:  csrwi 2, 31
-csrrwi zero, 2, 31
-
-# CHECK-INST: csrrs t0, 1, zero
-# CHECK-ALIAS: frflags t0
-# CHECK-EXT-F-ON: frflags t0
-# CHECK-EXT-F-OFF: csrr t0, 1
-csrrs t0, 1, zero
-
-# CHECK-INST: csrrw t0, 1, t2
-# CHECK-ALIAS: fsflags t0, t2
-# CHECK-EXT-F-ON: fsflags t0, t2
-# CHECK-EXT-F-OFF: csrrw t0, 1, t2
-csrrw t0, 1, t2
-
-# CHECK-INST: csrrw zero, 1, t2
-# CHECK-ALIAS: fsflags t2
-# CHECK-EXT-F-ON: fsflags t2
-# CHECK-EXT-F-OFF: csrw 1, t2
-csrrw zero, 1, t2
-
-# CHECK-INST: csrrwi t0, 1, 31
-# CHECK-ALIAS: fsflagsi t0, 31
-# CHECK-EXT-F: fsflagsi t0, 31
-# CHECK-EXT-F-OFF: csrrwi t0, 1, 31
-csrrwi t0, 1, 31
-
-# CHECK-INST: csrrwi zero, 1, 31
-# CHECK-ALIAS: fsflagsi 31
-# CHECK-EXT-F: fsflagsi 31
-# CHECK-EXT-F-OFF: csrwi 1, 31
-csrrwi zero, 1, 31
-
diff --git a/test/MC/RISCV/elf-flags.s b/test/MC/RISCV/elf-flags.s
deleted file mode 100644
index 1d183aab339..00000000000
--- a/test/MC/RISCV/elf-flags.s
+++ /dev/null
@@ -1,13 +0,0 @@
-# RUN: llvm-mc -triple=riscv32 -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVI %s
-# RUN: llvm-mc -triple=riscv64 -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVI %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+c -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVIC %s
-# RUN: llvm-mc -triple=riscv64 -mattr=+c -filetype=obj < %s | llvm-readobj -file-headers - | FileCheck -check-prefixes=CHECK-RVIC %s
-
-# CHECK-RVI:       Flags [ (0x0)
-# CHECK-RVI-NEXT:  ]
-
-# CHECK-RVIC:       Flags [ (0x1)
-# CHECK-RVIC-NEXT:    EF_RISCV_RVC (0x1)
-# CHECK-RVIC-NEXT:  ]
-
-nop
diff --git a/test/MC/RISCV/elf-header.s b/test/MC/RISCV/elf-header.s
deleted file mode 100644
index 29a7036f2fc..00000000000
--- a/test/MC/RISCV/elf-header.s
+++ /dev/null
@@ -1,42 +0,0 @@
-# RUN: llvm-mc %s -filetype=obj -triple=riscv32 | llvm-readobj -h \
-# RUN:     | FileCheck -check-prefix=RV32 %s
-# RUN: llvm-mc %s -filetype=obj -triple=riscv64 | llvm-readobj -h \
-# RUN:     | FileCheck -check-prefix=RV64 %s
-
-# RV32: Format: ELF32-riscv
-# RV32: Arch: riscv32
-# RV32: AddressSize: 32bit
-# RV32: ElfHeader {
-# RV32:   Ident {
-# RV32:     Magic: (7F 45 4C 46)
-# RV32:     Class: 32-bit (0x1)
-# RV32:     DataEncoding: LittleEndian (0x1)
-# RV32:     FileVersion: 1
-# RV32:     OS/ABI: SystemV (0x0)
-# RV32:     ABIVersion: 0
-# RV32:   }
-# RV32:   Type: Relocatable (0x1)
-# RV32:   Machine: EM_RISCV (0xF3)
-# RV32:   Version: 1
-# RV32:   Flags [ (0x0)
-# RV32:   ]
-# RV32: }
-
-# RV64: Format: ELF64-riscv
-# RV64: Arch: riscv64
-# RV64: AddressSize: 64bit
-# RV64: ElfHeader {
-# RV64:   Ident {
-# RV64:     Magic: (7F 45 4C 46)
-# RV64:     Class: 64-bit (0x2)
-# RV64:     DataEncoding: LittleEndian (0x1)
-# RV64:     FileVersion: 1
-# RV64:     OS/ABI: SystemV (0x0)
-# RV64:     ABIVersion: 0
-# RV64:   }
-# RV64:   Type: Relocatable (0x1)
-# RV64:   Machine: EM_RISCV (0xF3)
-# RV64:   Version: 1
-# RV64:   Flags [ (0x0)
-# RV64:   ]
-# RV64: }
diff --git a/test/MC/RISCV/fixups-compressed.s b/test/MC/RISCV/fixups-compressed.s
deleted file mode 100644
index a97d290f216..00000000000
--- a/test/MC/RISCV/fixups-compressed.s
+++ /dev/null
@@ -1,25 +0,0 @@
-# RUN: llvm-mc %s -triple riscv32 -mattr=+c -show-encoding \
-# RUN:     | FileCheck -check-prefix=CHECK-FIXUP %s
-# RUN: llvm-mc -triple riscv32 -filetype=obj -mattr=+c < %s \
-# RUN:     | llvm-objdump -d - | FileCheck -check-prefix=CHECK-INSTR %s
-# RUN: llvm-mc -filetype=obj -mattr=+c -triple=riscv32 %s \
-# RUN:     | llvm-readobj -r | FileCheck %s -check-prefix=CHECK-REL
-
-.LBB0_2:
-# CHECK-FIXUP:   fixup A - offset: 0, value: .LBB0_2, kind: fixup_riscv_rvc_jump
-# CHECK-INSTR: c.j     0
-c.j     .LBB0_2
-# CHECK:   fixup A - offset: 0, value: func1, kind: fixup_riscv_rvc_jump
-# CHECK-INSTR: c.jal   6
-c.jal   func1
-# CHECK-FIXUP:   fixup A - offset: 0, value: .LBB0_2, kind: fixup_riscv_rvc_branch
-# CHECK-INSTR: c.beqz  a3, -4
-c.beqz  a3, .LBB0_2
-# CHECK-FIXUP:   fixup A - offset: 0, value: .LBB0_2, kind: fixup_riscv_rvc_branch
-# CHECK-INSTR: c.bnez  a5, -6
-c.bnez  a5, .LBB0_2
-
-func1:
-  nop
-
-# CHECK-REL-NOT: R_RISCV
diff --git a/test/MC/RISCV/fixups-diagnostics.s b/test/MC/RISCV/fixups-diagnostics.s
deleted file mode 100644
index d346605221c..00000000000
--- a/test/MC/RISCV/fixups-diagnostics.s
+++ /dev/null
@@ -1,18 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -filetype obj < %s -o /dev/null 2>&1 | FileCheck %s
-
-  jal a0, far_distant # CHECK: :[[@LINE]]:3: error: fixup value out of range
-  jal a0, unaligned # CHECK: :[[@LINE]]:3: error: fixup value must be 2-byte aligned
-
-  beq a0, a1, distant # CHECK: :[[@LINE]]:3: error: fixup value out of range
-  blt t0, t1, unaligned # CHECK: :[[@LINE]]:3: error: fixup value must be 2-byte aligned
-
-  .byte 0
-unaligned:
-  .byte 0
-  .byte 0
-  .byte 0
-
-  .space 1<<12
-distant:
-  .space 1<<20
-far_distant:
diff --git a/test/MC/RISCV/fixups.s b/test/MC/RISCV/fixups.s
deleted file mode 100644
index c76fca51e31..00000000000
--- a/test/MC/RISCV/fixups.s
+++ /dev/null
@@ -1,50 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -riscv-no-aliases < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=CHECK-FIXUP %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INSTR %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 %s \
-# RUN:     | llvm-readobj -r | FileCheck %s -check-prefix=CHECK-REL
-
-# Checks that fixups that can be resolved within the same object file are
-# applied correctly
-
-.LBB0:
-lui t1, %hi(val)
-# CHECK-FIXUP: fixup A - offset: 0, value: %hi(val), kind: fixup_riscv_hi20
-# CHECK-INSTR: lui t1, 74565
-
-lw a0, %lo(val)(t1)
-# CHECK-FIXUP: fixup A - offset: 0, value: %lo(val), kind: fixup_riscv_lo12_i
-# CHECK-INSTR: lw a0, 1656(t1)
-addi a1, t1, %lo(val)
-# CHECK-FIXUP: fixup A - offset: 0, value: %lo(val), kind: fixup_riscv_lo12_i
-# CHECK-INSTR: addi a1, t1, 1656
-sw a0, %lo(val)(t1)
-# CHECK-FIXUP: fixup A - offset: 0, value: %lo(val), kind: fixup_riscv_lo12_s
-# CHECK-INSTR: sw a0, 1656(t1)
-
-jal zero, .LBB0
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB0, kind: fixup_riscv_jal
-# CHECK-INSTR: jal zero, -16
-jal zero, .LBB2
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB2, kind: fixup_riscv_jal
-# CHECK-INSTR: jal zero, 330996
-beq a0, a1, .LBB0
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB0, kind: fixup_riscv_branch
-# CHECK-INSTR: beq a0, a1, -24
-blt a0, a1, .LBB1
-# CHECK-FIXUP: fixup A - offset: 0, value: .LBB1, kind: fixup_riscv_branch
-# CHECK-INSTR: blt a0, a1, 1108
-
-.fill 1104
-
-.LBB1:
-
-.fill 329876
-addi zero, zero, 0
-.LBB2:
-
-.set val, 0x12345678
-
-# CHECK-REL-NOT: R_RISCV
diff --git a/test/MC/RISCV/hilo-constaddr.s b/test/MC/RISCV/hilo-constaddr.s
deleted file mode 100644
index 691401f0bab..00000000000
--- a/test/MC/RISCV/hilo-constaddr.s
+++ /dev/null
@@ -1,39 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple=riscv32 %s \
-# RUN:  | llvm-objdump -d - | FileCheck %s -check-prefix=CHECK-INSTR
-
-# RUN: llvm-mc -filetype=obj -triple=riscv32 %s \
-# RUN:  | llvm-readobj -r | FileCheck %s -check-prefix=CHECK-REL
-
-# Check the assembler can handle hi and lo expressions with a constant 
-# address, and constant expressions involving labels. Test case derived from 
-# test/MC/Mips/hilo-addressing.s
-
-# Check that 1 is added to the high 20 bits if bit 11 of the low part is 1.
-.equ addr, 0xdeadbeef
-  lui t0, %hi(addr)
-  lw ra, %lo(addr)(t0)
-# CHECK-INSTR: lui t0, 912092
-# CHECK-INSTR: lw ra, -273(t0)
-
-# Check that assembler can handle %hi(label1 - label2) and %lo(label1 - label2)
-# expressions.
-
-tmp1:
-  # Emit zeros so that difference between tmp1 and tmp3 is 0x30124 bytes.
-  .fill 0x30124-8
-tmp2:
-  lui t0, %hi(tmp3-tmp1)
-  lw ra, %lo(tmp3-tmp1)(t0)
-# CHECK-INSTR: lui t0, 48
-# CHECK-INSTR: lw ra, 292(t0)
-
-tmp3:
-  lui t1, %hi(tmp2-tmp3)
-  lw sp, %lo(tmp2-tmp3)(t1)
-# CHECK-INSTR: lui t1, 0
-# CHECK-INSTR: lw sp, -8(t1)
-
-# Check that a relocation isn't emitted for %hi(label1 - label2) and
-# %lo(label1 - label2) expressions.
-
-# CHECK-REL-NOT: R_RISCV
diff --git a/test/MC/RISCV/lit.local.cfg b/test/MC/RISCV/lit.local.cfg
deleted file mode 100644
index d0b081e3e8b..00000000000
--- a/test/MC/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,3 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
-
diff --git a/test/MC/RISCV/priv-invalid.s b/test/MC/RISCV/priv-invalid.s
deleted file mode 100644
index 8f421e471f9..00000000000
--- a/test/MC/RISCV/priv-invalid.s
+++ /dev/null
@@ -1,7 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-
-mret 0x10 # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-
-sfence.vma zero, a1, a2 # CHECK: :[[@LINE]]:22: error: invalid operand for instruction
-
-sfence.vma a0, 0x10 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
diff --git a/test/MC/RISCV/priv-valid.s b/test/MC/RISCV/priv-valid.s
deleted file mode 100644
index 88d35f2f9ff..00000000000
--- a/test/MC/RISCV/priv-valid.s
+++ /dev/null
@@ -1,34 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: uret
-# CHECK: encoding: [0x73,0x00,0x20,0x00]
-uret
-
-# CHECK-INST: sret
-# CHECK: encoding: [0x73,0x00,0x20,0x10]
-sret
-
-# CHECK-INST: mret
-# CHECK: encoding: [0x73,0x00,0x20,0x30]
-mret
-
-# CHECK-INST: wfi
-# CHECK: encoding: [0x73,0x00,0x50,0x10]
-wfi
-
-# CHECK-INST: sfence.vma zero, zero
-# CHECK: encoding: [0x73,0x00,0x00,0x12]
-sfence.vma zero, zero
-
-# CHECK-INST: sfence.vma a0, a1
-# CHECK: encoding: [0x73,0x00,0xb5,0x12]
-sfence.vma a0, a1
diff --git a/test/MC/RISCV/relocations.s b/test/MC/RISCV/relocations.s
deleted file mode 100644
index 77421620e68..00000000000
--- a/test/MC/RISCV/relocations.s
+++ /dev/null
@@ -1,97 +0,0 @@
-# RUN: llvm-mc -triple riscv32 -mattr=+c -riscv-no-aliases < %s -show-encoding \
-# RUN:     | FileCheck -check-prefix=INSTR -check-prefix=FIXUP %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-readobj -r | FileCheck -check-prefix=RELOC %s
-
-# Check prefixes:
-# RELOC - Check the relocation in the object.
-# FIXUP - Check the fixup on the instruction.
-# INSTR - Check the instruction is handled properly by the ASMPrinter
-
-.long foo
-# RELOC: R_RISCV_32 foo
-
-.quad foo
-# RELOC: R_RISCV_64 foo
-
-lui t1, %hi(foo)
-# RELOC: R_RISCV_HI20 foo 0x0
-# INSTR: lui t1, %hi(foo)
-# FIXUP: fixup A - offset: 0, value: %hi(foo), kind: fixup_riscv_hi20
-
-lui t1, %hi(foo+4)
-# RELOC: R_RISCV_HI20 foo 0x4
-# INSTR: lui t1, %hi(foo+4)
-# FIXUP: fixup A - offset: 0, value: %hi(foo+4), kind: fixup_riscv_hi20
-
-addi t1, t1, %lo(foo)
-# RELOC: R_RISCV_LO12_I foo 0x0
-# INSTR: addi t1, t1, %lo(foo)
-# FIXUP: fixup A - offset: 0, value: %lo(foo), kind: fixup_riscv_lo12_i
-
-addi t1, t1, %lo(foo+4)
-# RELOC: R_RISCV_LO12_I foo 0x4
-# INSTR: addi t1, t1, %lo(foo+4)
-# FIXUP: fixup A - offset: 0, value: %lo(foo+4), kind: fixup_riscv_lo12_i
-
-sb t1, %lo(foo)(a2)
-# RELOC: R_RISCV_LO12_S foo 0x0
-# INSTR: sb t1, %lo(foo)(a2)
-# FIXUP: fixup A - offset: 0, value: %lo(foo), kind: fixup_riscv_lo12_s
-
-sb t1, %lo(foo+4)(a2)
-# RELOC: R_RISCV_LO12_S foo 0x4
-# INSTR: sb t1, %lo(foo+4)(a2)
-# FIXUP: fixup A - offset: 0, value: %lo(foo+4), kind: fixup_riscv_lo12_s
-
-auipc t1, %pcrel_hi(foo)
-# RELOC: R_RISCV_PCREL_HI20 foo 0x0
-# INSTR: auipc t1, %pcrel_hi(foo)
-# FIXUP: fixup A - offset: 0, value: %pcrel_hi(foo), kind: fixup_riscv_pcrel_hi20
-
-auipc t1, %pcrel_hi(foo+4)
-# RELOC: R_RISCV_PCREL_HI20 foo 0x4
-# INSTR: auipc t1, %pcrel_hi(foo+4)
-# FIXUP: fixup A - offset: 0, value: %pcrel_hi(foo+4), kind: fixup_riscv_pcrel_hi20
-
-addi t1, t1, %pcrel_lo(foo)
-# RELOC: R_RISCV_PCREL_LO12_I foo 0x0
-# INSTR: addi t1, t1, %pcrel_lo(foo)
-# FIXUP: fixup A - offset: 0, value: %pcrel_lo(foo), kind: fixup_riscv_pcrel_lo12_i
-
-addi t1, t1, %pcrel_lo(foo+4)
-# RELOC: R_RISCV_PCREL_LO12_I foo 0x4
-# INSTR: addi t1, t1, %pcrel_lo(foo+4)
-# FIXUP: fixup A - offset: 0, value: %pcrel_lo(foo+4), kind: fixup_riscv_pcrel_lo12_i
-
-sb t1, %pcrel_lo(foo)(a2)
-# RELOC: R_RISCV_PCREL_LO12_S foo 0x0
-# INSTR: sb t1, %pcrel_lo(foo)(a2)
-# FIXUP: fixup A - offset: 0, value: %pcrel_lo(foo), kind: fixup_riscv_pcrel_lo12_s
-
-sb t1, %pcrel_lo(foo+4)(a2)
-# RELOC: R_RISCV_PCREL_LO12_S foo 0x4
-# INSTR: sb t1, %pcrel_lo(foo+4)(a2)
-# FIXUP: fixup A - offset: 0, value: %pcrel_lo(foo+4), kind: fixup_riscv_pcrel_lo12_s
-
-jal zero, foo
-# RELOC: R_RISCV_JAL
-# INSTR: jal zero, foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_jal
-
-bgeu a0, a1, foo
-# RELOC: R_RISCV_BRANCH
-# INSTR: bgeu a0, a1, foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_branch
-
-c.jal foo
-# A compressed jump (c.j) to an unresolved symbol will be relaxed to a (jal).
-# RELOC: R_RISCV_JAL
-# INSTR: c.jal foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_rvc_jump
-
-c.bnez a0, foo
-# A compressed branch (c.bnez) to an unresolved symbol will be relaxed to a (bnez).
-# RELOC: R_RISCV_BRANCH
-# INSTR: c.bnez a0, foo
-# FIXUP: fixup A - offset: 0, value: foo, kind: fixup_riscv_rvc_branch
diff --git a/test/MC/RISCV/rv32-relaxation.s b/test/MC/RISCV/rv32-relaxation.s
deleted file mode 100644
index 66109faf3eb..00000000000
--- a/test/MC/RISCV/rv32-relaxation.s
+++ /dev/null
@@ -1,75 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d - | FileCheck -check-prefix=INSTR %s
-
-FAR_JUMP_NEGATIVE:
-  c.nop
-.space 2000
-
-FAR_BRANCH_NEGATIVE:
-  c.nop
-.space 256
-
-NEAR_NEGATIVE:
-  c.nop
-
-start:
-  c.bnez a0, NEAR
-#INSTR: c.bnez a0, 72
-  c.bnez a0, NEAR_NEGATIVE
-#INSTR: c.bnez a0, -4
-  c.bnez a0, FAR_BRANCH
-#INSTR-NEXT: bnez a0, 326
-  c.bnez a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: bnez a0, -268
-  c.bnez a0, FAR_JUMP
-#INSTR-NEXT: bnez a0, 2320
-  c.bnez a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: bnez a0, -2278
-
-  c.beqz a0, NEAR
-#INSTR-NEXT: c.beqz a0, 52
-  c.beqz a0, NEAR_NEGATIVE
-#INSTR-NEXT: c.beqz a0, -24
-  c.beqz a0, FAR_BRANCH
-#INSTR-NEXT: beqz a0, 306
-  c.beqz a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: beqz a0, -288
-  c.beqz a0, FAR_JUMP
-#INSTR-NEXT: beqz a0, 2300
-  c.beqz a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: beqz a0, -2298
-
-  c.j NEAR
-#INSTR-NEXT: c.j 32
-  c.j NEAR_NEGATIVE
-#INSTR-NEXT: c.j -44
-  c.j FAR_BRANCH
-#INSTR-NEXT: c.j 286
-  c.j FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: c.j -306
-  c.j FAR_JUMP
-#INSTR-NEXT: j 2284
-  c.j FAR_JUMP_NEGATIVE
-#INSTR-NEXT: j -2314
-
-  c.jal NEAR
-#INSTR: c.jal 16
-  c.jal NEAR_NEGATIVE
-#INSTR: c.jal -60
-  c.jal FAR_BRANCH
-#INSTR-NEXT: c.jal 270
-  c.jal FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: c.jal -322
-  c.jal FAR_JUMP
-#INSTR-NEXT: jal 2268
-  c.jal FAR_JUMP_NEGATIVE
-#INSTR-NEXT: jal -2330
-
-NEAR:
-  c.nop
-.space 256
-FAR_BRANCH:
-  c.nop
-.space 2000
-FAR_JUMP:
-  c.nop
diff --git a/test/MC/RISCV/rv32a-invalid.s b/test/MC/RISCV/rv32a-invalid.s
deleted file mode 100644
index 8ee21bc501b..00000000000
--- a/test/MC/RISCV/rv32a-invalid.s
+++ /dev/null
@@ -1,17 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+a < %s 2>&1 | FileCheck %s
-
-# Final operand must have parentheses
-amoswap.w a1, a2, a3 # CHECK: :[[@LINE]]:19: error: invalid operand for instruction
-amomin.w a1, a2, 1 # CHECK: :[[@LINE]]:18: error: invalid operand for instruction
-lr.w a4, a5 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Only .aq, .rl, and .aqrl suffixes are valid
-amoxor.w.rlqa a2, a3, (a4) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.w.aq.rl a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.w. a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-
-# lr only takes two operands
-lr.w s0, (s1), s2 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
-
-# Note: errors for use of RV64A instructions for RV32 are checked in
-# rv64a-valid.s
diff --git a/test/MC/RISCV/rv32a-valid.s b/test/MC/RISCV/rv32a-valid.s
deleted file mode 100644
index fe53fab80ad..00000000000
--- a/test/MC/RISCV/rv32a-valid.s
+++ /dev/null
@@ -1,148 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+a -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+a -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+a < %s \
-# RUN:     | llvm-objdump -mattr=+a -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+a < %s \
-# RUN:     | llvm-objdump -mattr=+a -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: lr.w t0, (t1)
-# CHECK: encoding: [0xaf,0x22,0x03,0x10]
-lr.w t0, (t1)
-# CHECK-INST: lr.w.aq t1, (t2)
-# CHECK: encoding: [0x2f,0xa3,0x03,0x14]
-lr.w.aq t1, (t2)
-# CHECK-INST: lr.w.rl t2, (t3)
-# CHECK: encoding: [0xaf,0x23,0x0e,0x12]
-lr.w.rl t2, (t3)
-# CHECK-INST: lr.w.aqrl t3, (t4)
-# CHECK: encoding: [0x2f,0xae,0x0e,0x16]
-lr.w.aqrl t3, (t4)
-
-# CHECK-INST: sc.w t6, t5, (t4)
-# CHECK: encoding: [0xaf,0xaf,0xee,0x19]
-sc.w t6, t5, (t4)
-# CHECK-INST: sc.w.aq t5, t4, (t3)
-# CHECK: encoding: [0x2f,0x2f,0xde,0x1d]
-sc.w.aq t5, t4, (t3)
-# CHECK-INST: sc.w.rl t4, t3, (t2)
-# CHECK: encoding: [0xaf,0xae,0xc3,0x1b]
-sc.w.rl t4, t3, (t2)
-# CHECK-INST: sc.w.aqrl t3, t2, (t1)
-# CHECK: encoding: [0x2f,0x2e,0x73,0x1e]
-sc.w.aqrl t3, t2, (t1)
-
-# CHECK-INST: amoswap.w a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x27,0x14,0x08]
-amoswap.w a4, ra, (s0)
-# CHECK-INST: amoadd.w a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xa5,0xc6,0x00]
-amoadd.w a1, a2, (a3)
-# CHECK-INST: amoxor.w a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x26,0xd7,0x20]
-amoxor.w a2, a3, (a4)
-# CHECK-INST: amoand.w a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xa6,0xe7,0x60]
-amoand.w a3, a4, (a5)
-# CHECK-INST: amoor.w a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x27,0xf8,0x40]
-amoor.w a4, a5, (a6)
-# CHECK-INST: amomin.w a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xa7,0x08,0x81]
-amomin.w a5, a6, (a7)
-# CHECK-INST: amomax.w s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xab,0x6a,0xa1]
-amomax.w s7, s6, (s5)
-# CHECK-INST: amominu.w s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x2b,0x5a,0xc1]
-amominu.w s6, s5, (s4)
-# CHECK-INST: amomaxu.w s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xaa,0x49,0xe1]
-amomaxu.w s5, s4, (s3)
-
-# CHECK-INST: amoswap.w.aq a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x27,0x14,0x0c]
-amoswap.w.aq a4, ra, (s0)
-# CHECK-INST: amoadd.w.aq a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xa5,0xc6,0x04]
-amoadd.w.aq a1, a2, (a3)
-# CHECK-INST: amoxor.w.aq a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x26,0xd7,0x24]
-amoxor.w.aq a2, a3, (a4)
-# CHECK-INST: amoand.w.aq a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xa6,0xe7,0x64]
-amoand.w.aq a3, a4, (a5)
-# CHECK-INST: amoor.w.aq a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x27,0xf8,0x44]
-amoor.w.aq a4, a5, (a6)
-# CHECK-INST: amomin.w.aq a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xa7,0x08,0x85]
-amomin.w.aq a5, a6, (a7)
-# CHECK-INST: amomax.w.aq s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xab,0x6a,0xa5]
-amomax.w.aq s7, s6, (s5)
-# CHECK-INST: amominu.w.aq s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x2b,0x5a,0xc5]
-amominu.w.aq s6, s5, (s4)
-# CHECK-INST: amomaxu.w.aq s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xaa,0x49,0xe5]
-amomaxu.w.aq s5, s4, (s3)
-
-# CHECK-INST: amoswap.w.rl a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x27,0x14,0x0a]
-amoswap.w.rl a4, ra, (s0)
-# CHECK-INST: amoadd.w.rl a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xa5,0xc6,0x02]
-amoadd.w.rl a1, a2, (a3)
-# CHECK-INST: amoxor.w.rl a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x26,0xd7,0x22]
-amoxor.w.rl a2, a3, (a4)
-# CHECK-INST: amoand.w.rl a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xa6,0xe7,0x62]
-amoand.w.rl a3, a4, (a5)
-# CHECK-INST: amoor.w.rl a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x27,0xf8,0x42]
-amoor.w.rl a4, a5, (a6)
-# CHECK-INST: amomin.w.rl a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xa7,0x08,0x83]
-amomin.w.rl a5, a6, (a7)
-# CHECK-INST: amomax.w.rl s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xab,0x6a,0xa3]
-amomax.w.rl s7, s6, (s5)
-# CHECK-INST: amominu.w.rl s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x2b,0x5a,0xc3]
-amominu.w.rl s6, s5, (s4)
-# CHECK-INST: amomaxu.w.rl s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xaa,0x49,0xe3]
-amomaxu.w.rl s5, s4, (s3)
-
-# CHECK-INST: amoswap.w.aqrl a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x27,0x14,0x0e]
-amoswap.w.aqrl a4, ra, (s0)
-# CHECK-INST: amoadd.w.aqrl a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xa5,0xc6,0x06]
-amoadd.w.aqrl a1, a2, (a3)
-# CHECK-INST: amoxor.w.aqrl a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x26,0xd7,0x26]
-amoxor.w.aqrl a2, a3, (a4)
-# CHECK-INST: amoand.w.aqrl a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xa6,0xe7,0x66]
-amoand.w.aqrl a3, a4, (a5)
-# CHECK-INST: amoor.w.aqrl a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x27,0xf8,0x46]
-amoor.w.aqrl a4, a5, (a6)
-# CHECK-INST: amomin.w.aqrl a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xa7,0x08,0x87]
-amomin.w.aqrl a5, a6, (a7)
-# CHECK-INST: amomax.w.aqrl s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xab,0x6a,0xa7]
-amomax.w.aqrl s7, s6, (s5)
-# CHECK-INST: amominu.w.aqrl s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x2b,0x5a,0xc7]
-amominu.w.aqrl s6, s5, (s4)
-# CHECK-INST: amomaxu.w.aqrl s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xaa,0x49,0xe7]
-amomaxu.w.aqrl s5, s4, (s3)
diff --git a/test/MC/RISCV/rv32c-invalid.s b/test/MC/RISCV/rv32c-invalid.s
deleted file mode 100644
index 8ee7c961237..00000000000
--- a/test/MC/RISCV/rv32c-invalid.s
+++ /dev/null
@@ -1,83 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 -mattr=+c < %s 2>&1 | FileCheck %s
-
-## GPRC
-.LBB:
-c.lw  ra, 4(sp) # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.sw  sp, 4(sp) # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.beqz  t0, .LBB # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.bnez  s8, .LBB # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.addi4spn  s4, sp, 12 # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-c.srli  s7, 12 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.srai  t0, 12 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.andi  t1, 12 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.and  t1, a0 # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-c.or   a0, s8 # CHECK: :[[@LINE]]:12: error: invalid operand for instruction
-c.xor  t2, a0 # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-c.sub  a0, s8 # CHECK: :[[@LINE]]:12: error: invalid operand for instruction
-
-## GPRNoX0
-c.lwsp  x0, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.lwsp  zero, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.jr  x0 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.jalr  zero # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.addi  x0, x0, 1 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.li  zero, 2 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.slli  zero, zero, 4 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.mv  zero, s0 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.mv  ra, x0 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-c.add  ra, ra, x0 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
-c.add  zero, zero, sp # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-## GPRNoX0X2
-c.lui x0, 4 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-c.lui x2, 4 # CHECK: :[[@LINE]]:7: error: invalid operand for instruction
-
-## SP
-c.addi4spn  a0, a0, 12 # CHECK: :[[@LINE]]:17: error: invalid operand for instruction
-c.addi16sp  t0, 16 # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-
-# Out of range immediates
-
-## uimmlog2xlennonzero
-c.slli t0, 64 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 31]
-c.srli a0, 32 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 31]
-c.srai a0, 0  # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 31]
-
-## simm6
-c.li t0, 128 # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-32, 31]
-c.andi a0, -33 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [-32, 31]
-
-## simm6nonzero
-c.addi t0, 0 # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, -33 # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-c.addi t0, 32 # CHECK: :[[@LINE]]:12: error: immediate must be non-zero in the range [-32, 31]
-
-## c_lui_imm
-c.lui t0, 0 # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.lui t0, 32 # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.lui t0, 0xffffdf # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-c.lui t0, 0x1000000 # CHECK: :[[@LINE]]:11: error: immediate must be in [0xfffe0, 0xfffff] or [1, 31]
-
-## uimm8_lsb00
-c.lwsp  ra, 256(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-c.swsp  ra, -4(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-## uimm7_lsb00
-c.lw  s0, -4(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-c.sw  s0, 128(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-
-## simm9_lsb0
-c.bnez  s1, -258 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-256, 254]
-c.beqz  a0, 256 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-256, 254]
-
-## simm12_lsb0
-c.j 2048 # CHECK: :[[@LINE]]:5: error: immediate must be a multiple of 2 bytes in the range [-2048, 2046]
-c.jal -2050 # CHECK: :[[@LINE]]:7: error: immediate must be a multiple of 2 bytes in the range [-2048, 2046]
-
-## uimm10_lsb00nonzero
-c.addi4spn  a0, sp, 0 # CHECK: :[[@LINE]]:21: error: immediate must be a multiple of 4 bytes in the range [4, 1020]
-c.addi4spn  a0, sp, 1024 # CHECK: :[[@LINE]]:21: error: immediate must be a multiple of 4 bytes in the range [4, 1020]
-
-## simm10_lsb0000nonzero
-c.addi16sp  sp, -528 # CHECK: :[[@LINE]]:17: error: immediate must be a multiple of 16 bytes and non-zero in the range [-512, 496]
-c.addi16sp  sp, 512 # CHECK: :[[@LINE]]:17: error: immediate must be a multiple of 16 bytes and non-zero in the range [-512, 496]
-c.addi16sp  sp, 0 # CHECK: :[[@LINE]]:17: error: immediate must be a multiple of 16 bytes and non-zero in the range [-512, 496]
diff --git a/test/MC/RISCV/rv32c-only-valid.s b/test/MC/RISCV/rv32c-only-valid.s
deleted file mode 100644
index 9767ebc6161..00000000000
--- a/test/MC/RISCV/rv32c-only-valid.s
+++ /dev/null
@@ -1,15 +0,0 @@
-# RUN: llvm-mc -triple=riscv32 -mattr=+c -riscv-no-aliases -show-encoding < %s \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c -riscv-no-aliases < %s \
-# RUN:     | llvm-objdump -d - | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv32 \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv64 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# CHECK-INST: c.jal    2046
-# CHECK: encoding: [0xfd,0x2f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.jal    2046
diff --git a/test/MC/RISCV/rv32c-valid.s b/test/MC/RISCV/rv32c-valid.s
deleted file mode 100644
index 449e3be51a7..00000000000
--- a/test/MC/RISCV/rv32c-valid.s
+++ /dev/null
@@ -1,105 +0,0 @@
-# RUN: llvm-mc -triple=riscv32 -mattr=+c -riscv-no-aliases -show-encoding < %s \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -triple=riscv64 -mattr=+c -riscv-no-aliases -show-encoding < %s \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+c < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# TODO: more exhaustive testing of immediate encoding.
-
-# CHECK-INST: c.lwsp  ra, 0(sp)
-# CHECK: encoding: [0x82,0x40]
-c.lwsp  ra, 0(sp)
-# CHECK-INST: c.swsp  ra, 252(sp)
-# CHECK: encoding: [0x86,0xdf]
-c.swsp  ra, 252(sp)
-# CHECK-INST: c.lw    a2, 0(a0)
-# CHECK: encoding: [0x10,0x41]
-c.lw    a2, 0(a0)
-# CHECK-INST: c.sw    a5, 124(a3)
-# CHECK: encoding: [0xfc,0xde]
-c.sw    a5, 124(a3)
-
-# CHECK-INST: c.j     -2048
-# CHECK: encoding: [0x01,0xb0]
-c.j     -2048
-# CHECK-INST: c.jr    a7
-# CHECK: encoding: [0x82,0x88]
-c.jr    a7
-# CHECK-INST: c.jalr  a1
-# CHECK: encoding: [0x82,0x95]
-c.jalr  a1
-# CHECK-INST: c.beqz  a3, -256
-# CHECK: encoding: [0x81,0xd2]
-c.beqz  a3, -256
-# CHECK-INST: c.bnez  a5,  254
-# CHECK: encoding: [0xfd,0xef]
-c.bnez  a5,  254
-
-# CHECK-INST: c.li  a7, 31
-# CHECK: encoding: [0xfd,0x48]
-c.li    a7, 31
-# CHECK-INST: c.addi  a3, -32
-# CHECK: encoding: [0x81,0x16]
-c.addi  a3, -32
-# CHECK-INST: c.addi16sp  sp, -512
-# CHECK: encoding: [0x01,0x71]
-c.addi16sp  sp, -512
-# CHECK-INST: c.addi16sp  sp, 496
-# CHECK: encoding: [0x7d,0x61]
-c.addi16sp  sp, 496
-# CHECK-INST: c.addi4spn  a3, sp, 1020
-# CHECK: encoding: [0xf4,0x1f]
-c.addi4spn      a3, sp, 1020
-# CHECK-INST: c.addi4spn  a3, sp, 4
-# CHECK: encoding: [0x54,0x00]
-c.addi4spn      a3, sp, 4
-# CHECK-INST: c.slli  a1, 1
-# CHECK: encoding: [0x86,0x05]
-c.slli  a1, 1
-# CHECK-INST: c.srli  a3, 31
-# CHECK: encoding: [0xfd,0x82]
-c.srli  a3, 31
-# CHECK-INST: c.srai  a4, 2
-# CHECK: encoding: [0x09,0x87]
-c.srai  a4, 2
-# CHECK-INST: c.andi  a5, 15
-# CHECK: encoding: [0xbd,0x8b]
-c.andi  a5, 15
-# CHECK-INST: c.mv    a7, s0
-# CHECK: encoding: [0xa2,0x88]
-c.mv    a7, s0
-# CHECK-INST: c.and   a1, a2
-# CHECK: encoding: [0xf1,0x8d]
-c.and   a1, a2
-# CHECK-INST: c.or    a2, a3
-# CHECK: encoding: [0x55,0x8e]
-c.or    a2, a3
-# CHECK-INST: c.xor   a3, a4
-# CHECK: encoding: [0xb9,0x8e]
-c.xor   a3, a4
-# CHECK-INST: c.sub   a4, a5
-# CHECK: encoding: [0x1d,0x8f]
-c.sub   a4, a5
-# CHECK-INST: c.nop
-# CHECK: encoding: [0x01,0x00]
-c.nop
-# CHECK-INST: c.ebreak
-# CHECK: encoding: [0x02,0x90]
-c.ebreak
-# CHECK-INST: c.lui   s0, 1
-# CHECK: encoding: [0x05,0x64]
-c.lui   s0, 1
-# CHECK-INST: c.lui   s0, 31
-# CHECK: encoding: [0x7d,0x64]
-c.lui   s0, 31
-# CHECK-INST: c.lui   s0, 1048544
-# CHECK: encoding: [0x01,0x74]
-c.lui   s0, 0xfffe0
-# CHECK-INST: c.lui   s0, 1048575
-# CHECK: encoding: [0x7d,0x74]
-c.lui   s0, 0xfffff
diff --git a/test/MC/RISCV/rv32d-invalid.s b/test/MC/RISCV/rv32d-invalid.s
deleted file mode 100644
index 3c3e265bd28..00000000000
--- a/test/MC/RISCV/rv32d-invalid.s
+++ /dev/null
@@ -1,21 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+d < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## simm12
-fld ft1, -2049(a0) # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-fsd ft2, 2048(a1) # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-
-# Memory operand not formatted correctly
-fld ft1, a0, -200 # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-fsd ft2, a1, 100 # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-
-# Invalid register names
-fld ft15, 100(a0) # CHECK: :[[@LINE]]:5: error: invalid operand for instruction
-fld ft1, 100(a10) # CHECK: :[[@LINE]]:14: error: expected register
-fsgnjn.d fa100, fa2, fa3 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Integer registers where FP regs are expected
-fadd.d a2, a1, a0 # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fcvt.wu.d ft2, a1 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv32d-valid.s b/test/MC/RISCV/rv32d-valid.s
deleted file mode 100644
index 0e54b797c36..00000000000
--- a/test/MC/RISCV/rv32d-valid.s
+++ /dev/null
@@ -1,161 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# Support for the 'D' extension implies support for 'F'
-# CHECK-INST: fadd.s fs10, fs11, ft8
-# CHECK: encoding: [0x53,0xfd,0xcd,0x01]
-fadd.s f26, f27, f28
-
-# CHECK-INST: fld ft0, 12(a0)
-# CHECK: encoding: [0x07,0x30,0xc5,0x00]
-fld f0, 12(a0)
-# CHECK-INST: fld ft1, 4(ra)
-# CHECK: encoding: [0x87,0xb0,0x40,0x00]
-fld f1, +4(ra)
-# CHECK-INST: fld ft2, -2048(a3)
-# CHECK: encoding: [0x07,0xb1,0x06,0x80]
-fld f2, -2048(x13)
-# CHECK-INST: fld ft3, -2048(s1)
-# CHECK: encoding: [0x87,0xb1,0x04,0x80]
-fld f3, %lo(2048)(s1)
-# CHECK-INST: fld ft4, 2047(s2)
-# CHECK: encoding: [0x07,0x32,0xf9,0x7f]
-fld f4, 2047(s2)
-# CHECK-INST: fld ft5, 0(s3)
-# CHECK: encoding: [0x87,0xb2,0x09,0x00]
-fld f5, 0(s3)
-
-# CHECK-INST: fsd ft6, 2047(s4)
-# CHECK: encoding: [0xa7,0x3f,0x6a,0x7e]
-fsd f6, 2047(s4)
-# CHECK-INST: fsd ft7, -2048(s5)
-# CHECK: encoding: [0x27,0xb0,0x7a,0x80]
-fsd f7, -2048(s5)
-# CHECK-INST: fsd fs0, -2048(s6)
-# CHECK: encoding: [0x27,0x30,0x8b,0x80]
-fsd f8, %lo(2048)(s6)
-# CHECK-INST: fsd fs1, 999(s7)
-# CHECK: encoding: [0xa7,0xb3,0x9b,0x3e]
-fsd f9, 999(s7)
-
-# CHECK-INST: fmadd.d fa0, fa1, fa2, fa3, dyn
-# CHECK: encoding: [0x43,0xf5,0xc5,0x6a]
-fmadd.d f10, f11, f12, f13, dyn
-# CHECK-INST: fmsub.d fa4, fa5, fa6, fa7, dyn
-# CHECK: encoding: [0x47,0xf7,0x07,0x8b]
-fmsub.d f14, f15, f16, f17, dyn
-# CHECK-INST: fnmsub.d fs2, fs3, fs4, fs5, dyn
-# CHECK: encoding: [0x4b,0xf9,0x49,0xab]
-fnmsub.d f18, f19, f20, f21, dyn
-# CHECK-INST: fnmadd.d fs6, fs7, fs8, fs9, dyn
-# CHECK: encoding: [0x4f,0xfb,0x8b,0xcb]
-fnmadd.d f22, f23, f24, f25, dyn
-
-# CHECK-INST: fadd.d fs10, fs11, ft8, dyn
-# CHECK: encoding: [0x53,0xfd,0xcd,0x03]
-fadd.d f26, f27, f28, dyn
-# CHECK-INST: fsub.d ft9, ft10, ft11, dyn
-# CHECK: encoding: [0xd3,0x7e,0xff,0x0b]
-fsub.d f29, f30, f31, dyn
-# CHECK-INST: fmul.d ft0, ft1, ft2, dyn
-# CHECK: encoding: [0x53,0xf0,0x20,0x12]
-fmul.d ft0, ft1, ft2, dyn
-# CHECK-INST: fdiv.d ft3, ft4, ft5, dyn
-# CHECK: encoding: [0xd3,0x71,0x52,0x1a]
-fdiv.d ft3, ft4, ft5, dyn
-# CHECK-INST: fsqrt.d ft6, ft7, dyn
-# CHECK: encoding: [0x53,0xf3,0x03,0x5a]
-fsqrt.d ft6, ft7, dyn
-# CHECK-INST: fsgnj.d fs1, fa0, fa1
-# CHECK: encoding: [0xd3,0x04,0xb5,0x22]
-fsgnj.d fs1, fa0, fa1
-# CHECK-INST: fsgnjn.d fa1, fa3, fa4
-# CHECK: encoding: [0xd3,0x95,0xe6,0x22]
-fsgnjn.d fa1, fa3, fa4
-# CHECK-INST: fsgnjx.d fa3, fa2, fa1
-# CHECK: encoding: [0xd3,0x26,0xb6,0x22]
-fsgnjx.d fa3, fa2, fa1
-# CHECK-INST: fmin.d fa5, fa6, fa7
-# CHECK: encoding: [0xd3,0x07,0x18,0x2b]
-fmin.d fa5, fa6, fa7
-# CHECK-INST: fmax.d fs2, fs3, fs4
-# CHECK: encoding: [0x53,0x99,0x49,0x2b]
-fmax.d fs2, fs3, fs4
-
-# CHECK-INST: fcvt.s.d fs5, fs6, dyn
-# CHECK: encoding: [0xd3,0x7a,0x1b,0x40]
-fcvt.s.d fs5, fs6, dyn
-# CHECK-INST: fcvt.d.s fs7, fs8
-# CHECK: encoding: [0xd3,0x0b,0x0c,0x42]
-fcvt.d.s fs7, fs8
-# CHECK-INST: feq.d a1, fs8, fs9
-# CHECK: encoding: [0xd3,0x25,0x9c,0xa3]
-feq.d a1, fs8, fs9
-# CHECK-INST: flt.d a2, fs10, fs11
-# CHECK: encoding: [0x53,0x16,0xbd,0xa3]
-flt.d a2, fs10, fs11
-# CHECK-INST: fle.d a3, ft8, ft9
-# CHECK: encoding: [0xd3,0x06,0xde,0xa3]
-fle.d a3, ft8, ft9
-# CHECK-INST: fclass.d a3, ft10
-# CHECK: encoding: [0xd3,0x16,0x0f,0xe2]
-fclass.d a3, ft10
-
-# CHECK-INST: fcvt.w.d a4, ft11, dyn
-# CHECK: encoding: [0x53,0xf7,0x0f,0xc2]
-fcvt.w.d a4, ft11, dyn
-# CHECK-INST: fcvt.d.w ft0, a5
-# CHECK: encoding: [0x53,0x80,0x07,0xd2]
-fcvt.d.w ft0, a5
-# CHECK-INST: fcvt.d.wu ft1, a6
-# CHECK: encoding: [0xd3,0x00,0x18,0xd2]
-fcvt.d.wu ft1, a6
-
-# Rounding modes
-
-# CHECK-INST: fmadd.d fa0, fa1, fa2, fa3, rne
-# CHECK: encoding: [0x43,0x85,0xc5,0x6a]
-fmadd.d f10, f11, f12, f13, rne
-# CHECK-INST: fmsub.d fa4, fa5, fa6, fa7, rtz
-# CHECK: encoding: [0x47,0x97,0x07,0x8b]
-fmsub.d f14, f15, f16, f17, rtz
-# CHECK-INST: fnmsub.d fs2, fs3, fs4, fs5, rdn
-# CHECK: encoding: [0x4b,0xa9,0x49,0xab]
-fnmsub.d f18, f19, f20, f21, rdn
-# CHECK-INST: fnmadd.d fs6, fs7, fs8, fs9, rup
-# CHECK: encoding: [0x4f,0xbb,0x8b,0xcb]
-fnmadd.d f22, f23, f24, f25, rup
-
-# CHECK-INST: fadd.d fs10, fs11, ft8, rmm
-# CHECK: encoding: [0x53,0xcd,0xcd,0x03]
-fadd.d f26, f27, f28, rmm
-# CHECK-INST: fsub.d ft9, ft10, ft11
-# CHECK: encoding: [0xd3,0x7e,0xff,0x0b]
-fsub.d f29, f30, f31, dyn
-# CHECK-INST: fmul.d ft0, ft1, ft2, rne
-# CHECK: encoding: [0x53,0x80,0x20,0x12]
-fmul.d ft0, ft1, ft2, rne
-# CHECK-INST: fdiv.d ft3, ft4, ft5, rtz
-# CHECK: encoding: [0xd3,0x11,0x52,0x1a]
-fdiv.d ft3, ft4, ft5, rtz
-
-# CHECK-INST: fsqrt.d ft6, ft7, rdn
-# CHECK: encoding: [0x53,0xa3,0x03,0x5a]
-fsqrt.d ft6, ft7, rdn
-# CHECK-INST: fcvt.s.d fs5, fs6, rup
-# CHECK: encoding: [0xd3,0x3a,0x1b,0x40]
-fcvt.s.d fs5, fs6, rup
-# CHECK-INST: fcvt.w.d a4, ft11, rmm
-# CHECK: encoding: [0x53,0xc7,0x0f,0xc2]
-fcvt.w.d a4, ft11, rmm
-# CHECK-INST: fcvt.wu.d a5, ft10, dyn
-# CHECK: encoding: [0xd3,0x77,0x1f,0xc2]
-fcvt.wu.d a5, ft10, dyn
diff --git a/test/MC/RISCV/rv32dc-invalid.s b/test/MC/RISCV/rv32dc-invalid.s
deleted file mode 100644
index 70fb504b1bb..00000000000
--- a/test/MC/RISCV/rv32dc-invalid.s
+++ /dev/null
@@ -1,12 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 -mattr=+c,+d < %s 2>&1 | FileCheck %s
-
-## FPRC
-c.fld  ft3, 8(a5) # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-## uimm9_lsb000
-c.fldsp  fs1, 512(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-c.fsdsp  fs2, -8(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-
-## uimm8_lsb000
-c.fld  fs0, -8(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 248]
-c.fsd  fs1, 256(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 248]
diff --git a/test/MC/RISCV/rv32dc-valid.s b/test/MC/RISCV/rv32dc-valid.s
deleted file mode 100644
index 764bcbd2fb1..00000000000
--- a/test/MC/RISCV/rv32dc-valid.s
+++ /dev/null
@@ -1,29 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+c,+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+c,+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+c\
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN: | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN:     not llvm-mc -triple riscv32 \
-# RUN: -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# CHECK-INST: c.fldsp  fs0, 504(sp)
-# CHECK: encoding: [0x7e,0x34]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fldsp  fs0, 504(sp)
-# CHECK-INST: c.fsdsp  fa7, 504(sp)
-# CHECK: encoding: [0xc6,0xbf]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsdsp  fa7, 504(sp)
-
-# CHECK-INST: c.fld  fa3, 248(a5)
-# CHECK: encoding: [0xf4,0x3f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fld  fa3, 248(a5)
-# CHECK-INST: c.fsd  fa2, 248(a1)
-# CHECK: encoding: [0xf0,0xbd]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsd  fa2, 248(a1)
diff --git a/test/MC/RISCV/rv32f-invalid.s b/test/MC/RISCV/rv32f-invalid.s
deleted file mode 100644
index ed9aaed1bca..00000000000
--- a/test/MC/RISCV/rv32f-invalid.s
+++ /dev/null
@@ -1,34 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+f < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## simm12
-flw ft1, -2049(a0) # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-fsw ft2, 2048(a1) # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-
-# Memory operand not formatted correctly
-flw ft1, a0, -200 # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-fsw ft2, a1, 100 # CHECK: :[[@LINE]]:10: error: immediate must be an integer in the range [-2048, 2047]
-
-# Invalid register names
-flw ft15, 100(a0) # CHECK: :[[@LINE]]:5: error: invalid operand for instruction
-flw ft1, 100(a10) # CHECK: :[[@LINE]]:14: error: expected register
-fsgnjn.s fa100, fa2, fa3 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Integer registers where FP regs are expected
-fmv.x.w fs7, a2 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fmv.w.x a8, ft2 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# Rounding mode when a register is expected
-fmadd.s f10, f11, f12, ree # CHECK: :[[@LINE]]:24: error: invalid operand for instruction
-
-# Invalid rounding modes
-fmadd.s f10, f11, f12, f13, ree # CHECK: :[[@LINE]]:29: error: operand must be a valid floating point rounding mode mnemonic
-fmsub.s f14, f15, f16, f17, 0 # CHECK: :[[@LINE]]:29: error: operand must be a valid floating point rounding mode mnemonic
-fnmsub.s f18, f19, f20, f21, 0b111 # CHECK: :[[@LINE]]:30: error: operand must be a valid floating point rounding mode mnemonic
-
-# Using 'D' instructions for an 'F'-only target
-fadd.d ft0, ft1, ft2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-# Using RV64F instructions for RV32 is tested in rv64f-valid.s
diff --git a/test/MC/RISCV/rv32f-valid.s b/test/MC/RISCV/rv32f-valid.s
deleted file mode 100644
index f5da84ac2bd..00000000000
--- a/test/MC/RISCV/rv32f-valid.s
+++ /dev/null
@@ -1,166 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: flw ft0, 12(a0)
-# CHECK: encoding: [0x07,0x20,0xc5,0x00]
-flw f0, 12(a0)
-# CHECK-INST: flw ft1, 4(ra)
-# CHECK: encoding: [0x87,0xa0,0x40,0x00]
-flw f1, +4(ra)
-# CHECK-INST: flw ft2, -2048(a3)
-# CHECK: encoding: [0x07,0xa1,0x06,0x80]
-flw f2, -2048(x13)
-# CHECK-INST: flw ft3, -2048(s1)
-# CHECK: encoding: [0x87,0xa1,0x04,0x80]
-flw f3, %lo(2048)(s1)
-# CHECK-INST: flw ft4, 2047(s2)
-# CHECK: encoding: [0x07,0x22,0xf9,0x7f]
-flw f4, 2047(s2)
-# CHECK-INST: flw ft5, 0(s3)
-# CHECK: encoding: [0x87,0xa2,0x09,0x00]
-flw f5, 0(s3)
-
-# CHECK-INST: fsw ft6, 2047(s4)
-# CHECK: encoding: [0xa7,0x2f,0x6a,0x7e]
-fsw f6, 2047(s4)
-# CHECK-INST: fsw ft7, -2048(s5)
-# CHECK: encoding: [0x27,0xa0,0x7a,0x80]
-fsw f7, -2048(s5)
-# CHECK-INST: fsw fs0, -2048(s6)
-# CHECK: encoding: [0x27,0x20,0x8b,0x80]
-fsw f8, %lo(2048)(s6)
-# CHECK-INST: fsw fs1, 999(s7)
-# CHECK: encoding: [0xa7,0xa3,0x9b,0x3e]
-fsw f9, 999(s7)
-
-# CHECK-INST: fmadd.s fa0, fa1, fa2, fa3, dyn
-# CHECK: encoding: [0x43,0xf5,0xc5,0x68]
-fmadd.s f10, f11, f12, f13, dyn
-# CHECK-INST: fmsub.s fa4, fa5, fa6, fa7, dyn
-# CHECK: encoding: [0x47,0xf7,0x07,0x89]
-fmsub.s f14, f15, f16, f17, dyn
-# CHECK-INST: fnmsub.s fs2, fs3, fs4, fs5, dyn
-# CHECK: encoding: [0x4b,0xf9,0x49,0xa9]
-fnmsub.s f18, f19, f20, f21, dyn
-# CHECK-INST: fnmadd.s fs6, fs7, fs8, fs9, dyn
-# CHECK: encoding: [0x4f,0xfb,0x8b,0xc9]
-fnmadd.s f22, f23, f24, f25, dyn
-
-# CHECK-INST: fadd.s fs10, fs11, ft8, dyn
-# CHECK: encoding: [0x53,0xfd,0xcd,0x01]
-fadd.s f26, f27, f28, dyn
-# CHECK-INST: fsub.s ft9, ft10, ft11, dyn
-# CHECK: encoding: [0xd3,0x7e,0xff,0x09]
-fsub.s f29, f30, f31, dyn
-# CHECK-INST: fmul.s ft0, ft1, ft2, dyn
-# CHECK: encoding: [0x53,0xf0,0x20,0x10]
-fmul.s ft0, ft1, ft2, dyn
-# CHECK-INST: fdiv.s ft3, ft4, ft5, dyn
-# CHECK: encoding: [0xd3,0x71,0x52,0x18]
-fdiv.s ft3, ft4, ft5, dyn
-# CHECK-INST: fsqrt.s ft6, ft7, dyn
-# CHECK: encoding: [0x53,0xf3,0x03,0x58]
-fsqrt.s ft6, ft7, dyn
-# CHECK-INST: fsgnj.s fs1, fa0, fa1
-# CHECK: encoding: [0xd3,0x04,0xb5,0x20]
-fsgnj.s fs1, fa0, fa1
-# CHECK-INST: fsgnjn.s fa1, fa3, fa4
-# CHECK: encoding: [0xd3,0x95,0xe6,0x20]
-fsgnjn.s fa1, fa3, fa4
-# CHECK-INST: fsgnjx.s fa4, fa3, fa2
-# CHECK: encoding: [0x53,0xa7,0xc6,0x20]
-fsgnjx.s fa4, fa3, fa2
-# CHECK-INST: fmin.s fa5, fa6, fa7
-# CHECK: encoding: [0xd3,0x07,0x18,0x29]
-fmin.s fa5, fa6, fa7
-# CHECK-INST: fmax.s fs2, fs3, fs4
-# CHECK: encoding: [0x53,0x99,0x49,0x29]
-fmax.s fs2, fs3, fs4
-# CHECK-INST: fcvt.w.s a0, fs5, dyn
-# CHECK: encoding: [0x53,0xf5,0x0a,0xc0]
-fcvt.w.s a0, fs5, dyn
-# CHECK-INST: fcvt.wu.s a1, fs6, dyn
-# CHECK: encoding: [0xd3,0x75,0x1b,0xc0]
-fcvt.wu.s a1, fs6, dyn
-# CHECK-INST: fmv.x.w a2, fs7
-# CHECK: encoding: [0x53,0x86,0x0b,0xe0]
-fmv.x.w a2, fs7
-# CHECK-INST: feq.s a1, fs8, fs9
-# CHECK: encoding: [0xd3,0x25,0x9c,0xa1]
-feq.s a1, fs8, fs9
-# CHECK-INST: flt.s a2, fs10, fs11
-# CHECK: encoding: [0x53,0x16,0xbd,0xa1]
-flt.s a2, fs10, fs11
-# CHECK-INST: fle.s a3, ft8, ft9
-# CHECK: encoding: [0xd3,0x06,0xde,0xa1]
-fle.s a3, ft8, ft9
-# CHECK-INST: fclass.s a3, ft10
-# CHECK: encoding: [0xd3,0x16,0x0f,0xe0]
-fclass.s a3, ft10
-# CHECK-INST: fcvt.s.w ft11, a4, dyn
-# CHECK: encoding: [0xd3,0x7f,0x07,0xd0]
-fcvt.s.w ft11, a4, dyn
-# CHECK-INST: fcvt.s.wu ft0, a5, dyn
-# CHECK: encoding: [0x53,0xf0,0x17,0xd0]
-fcvt.s.wu ft0, a5, dyn
-# CHECK-INST: fmv.w.x ft1, a6
-# CHECK: encoding: [0xd3,0x00,0x08,0xf0]
-fmv.w.x ft1, a6
-
-# Rounding modes
-
-# CHECK-INST: fmadd.s fa0, fa1, fa2, fa3, rne
-# CHECK: encoding: [0x43,0x85,0xc5,0x68]
-fmadd.s f10, f11, f12, f13, rne
-# CHECK-INST: fmsub.s fa4, fa5, fa6, fa7, rtz
-# CHECK: encoding: [0x47,0x97,0x07,0x89]
-fmsub.s f14, f15, f16, f17, rtz
-# CHECK-INST: fnmsub.s fs2, fs3, fs4, fs5, rdn
-# CHECK: encoding: [0x4b,0xa9,0x49,0xa9]
-fnmsub.s f18, f19, f20, f21, rdn
-# CHECK-INST: fnmadd.s fs6, fs7, fs8, fs9, rup
-# CHECK: encoding: [0x4f,0xbb,0x8b,0xc9]
-fnmadd.s f22, f23, f24, f25, rup
-# CHECK-INST: fmadd.s fa0, fa1, fa2, fa3, rmm
-# CHECK: encoding: [0x43,0xc5,0xc5,0x68]
-fmadd.s f10, f11, f12, f13, rmm
-# CHECK-INST: fmsub.s fa4, fa5, fa6, fa7
-# CHECK: encoding: [0x47,0xf7,0x07,0x89]
-fmsub.s f14, f15, f16, f17, dyn
-
-# CHECK-INST: fadd.s fs10, fs11, ft8, rne
-# CHECK: encoding: [0x53,0x8d,0xcd,0x01]
-fadd.s f26, f27, f28, rne
-# CHECK-INST: fsub.s ft9, ft10, ft11, rtz
-# CHECK: encoding: [0xd3,0x1e,0xff,0x09]
-fsub.s f29, f30, f31, rtz
-# CHECK-INST: fmul.s ft0, ft1, ft2, rdn
-# CHECK: encoding: [0x53,0xa0,0x20,0x10]
-fmul.s ft0, ft1, ft2, rdn
-# CHECK-INST: fdiv.s ft3, ft4, ft5, rup
-# CHECK: encoding: [0xd3,0x31,0x52,0x18]
-fdiv.s ft3, ft4, ft5, rup
-
-# CHECK-INST: fsqrt.s ft6, ft7, rmm
-# CHECK: encoding: [0x53,0xc3,0x03,0x58]
-fsqrt.s ft6, ft7, rmm
-# CHECK-INST: fcvt.w.s a0, fs5, rup
-# CHECK: encoding: [0x53,0xb5,0x0a,0xc0]
-fcvt.w.s a0, fs5, rup
-# CHECK-INST: fcvt.wu.s a1, fs6, rdn
-# CHECK: encoding: [0xd3,0x25,0x1b,0xc0]
-fcvt.wu.s a1, fs6, rdn
-# CHECK-INST: fcvt.s.w ft11, a4, rtz
-# CHECK: encoding: [0xd3,0x1f,0x07,0xd0]
-fcvt.s.w ft11, a4, rtz
-# CHECK-INST: fcvt.s.wu ft0, a5, rne
-# CHECK: encoding: [0x53,0x80,0x17,0xd0]
-fcvt.s.wu ft0, a5, rne
diff --git a/test/MC/RISCV/rv32fc-invalid.s b/test/MC/RISCV/rv32fc-invalid.s
deleted file mode 100644
index 5af3df17671..00000000000
--- a/test/MC/RISCV/rv32fc-invalid.s
+++ /dev/null
@@ -1,12 +0,0 @@
-# RUN: not llvm-mc -triple=riscv32 -mattr=+c,+f < %s 2>&1 | FileCheck %s
-
-## FPRC
-c.flw  ft3, 8(a5) # CHECK: :[[@LINE]]:8: error: invalid operand for instruction
-
-## uimm8_lsb00
-c.flwsp  fs1, 256(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-c.fswsp  fs2, -4(sp) # CHECK: :[[@LINE]]:15: error: immediate must be a multiple of 4 bytes in the range [0, 252]
-
-## uimm7_lsb00
-c.flw  fs0, -4(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 124]
-c.fsw  fs1, 128(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 4 bytes in the range [0, 124]
diff --git a/test/MC/RISCV/rv32fc-valid.s b/test/MC/RISCV/rv32fc-valid.s
deleted file mode 100644
index 87d86c13799..00000000000
--- a/test/MC/RISCV/rv32fc-valid.s
+++ /dev/null
@@ -1,33 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+c,+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple=riscv32 -mattr=+c,+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+c \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv32 \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv64 -mattr=+c,+f \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-
-# CHECK-INST: c.flwsp  fs0, 252(sp)
-# CHECK: encoding: [0x7e,0x74]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.flwsp  fs0, 252(sp)
-# CHECK-INST: c.fswsp  fa7, 252(sp)
-# CHECK: encoding: [0xc6,0xff]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fswsp  fa7, 252(sp)
-
-# CHECK-INST: c.flw  fa3, 124(a5)
-# CHECK: encoding: [0xf4,0x7f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.flw  fa3, 124(a5)
-# CHECK-INST: c.fsw  fa2, 124(a1)
-# CHECK: encoding: [0xf0,0xfd]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsw  fa2, 124(a1)
diff --git a/test/MC/RISCV/rv32i-aliases-invalid.s b/test/MC/RISCV/rv32i-aliases-invalid.s
deleted file mode 100644
index e0473ca371d..00000000000
--- a/test/MC/RISCV/rv32i-aliases-invalid.s
+++ /dev/null
@@ -1,8 +0,0 @@
-# RUN: not llvm-mc %s -triple=riscv32 -riscv-no-aliases 2>&1 | FileCheck %s
-# RUN: not llvm-mc %s -triple=riscv32 2>&1 | FileCheck %s
-
-# TODO ld
-# TODO sd
-
-negw x1, x2   # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-sext.w x3, x4 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
diff --git a/test/MC/RISCV/rv32i-aliases-valid.s b/test/MC/RISCV/rv32i-aliases-valid.s
deleted file mode 100644
index f4f35c543ac..00000000000
--- a/test/MC/RISCV/rv32i-aliases-valid.s
+++ /dev/null
@@ -1,20 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 \
-# RUN:     | FileCheck -check-prefixes=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefixes=CHECK-ALIAS %s
-
-# CHECK-INST: csrrs t4, 3202, zero
-# CHECK-ALIAS: rdinstreth t4
-rdinstreth x29
-# CHECK-INST: csrrs s11, 3200, zero
-# CHECK-ALIAS: rdcycleh s11
-rdcycleh x27
-# CHECK-INST: csrrs t3, 3201, zero
-# CHECK-ALIAS: rdtimeh t3
-rdtimeh x28
diff --git a/test/MC/RISCV/rv32i-invalid.s b/test/MC/RISCV/rv32i-invalid.s
deleted file mode 100644
index 61c8dfc1826..00000000000
--- a/test/MC/RISCV/rv32i-invalid.s
+++ /dev/null
@@ -1,148 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## fencearg
-fence iorw, iore # CHECK: :[[@LINE]]:13: error: operand must be formed of letters selected in-order from 'iorw'
-fence wr, wr # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence rw, rr # CHECK: :[[@LINE]]:11: error: operand must be formed of letters selected in-order from 'iorw'
-fence 1, rw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-
-## uimm5
-slli a0, a0, 32 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srli a0, a0, -1 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srai a0, a0, -19 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-csrrwi a1, 0x1, -1 # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrsi t1, 999, 32 # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrci x0, 43, -90 # CHECK: :[[@LINE]]:16: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-ori a0, a1, -2049 # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-2048, 2047]
-andi ra, sp, 2048 # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [-2048, 2047]
-
-## uimm12
-csrrw a0, -1, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, 4096, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, -0xf, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrc a0, 0x1000, a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrwi a0, -50, 0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrsi a0, 4097, a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrci a0, 0xffff, a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-
-## simm13_lsb0
-beq t0, t1, -4098 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bne t0, t1, -4097 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-blt t0, t1, 4095 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bge t0, t1, 4096 # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bltu t0, t1, 13 # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bgeu t0, t1, -13 # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-
-## uimm20
-lui a0, -1 # CHECK: :[[@LINE]]:9: error: immediate must be an integer in the range [0, 1048575]
-lui s0, 1048576 # CHECK: :[[@LINE]]:9: error: immediate must be an integer in the range [0, 1048575]
-auipc zero, -0xf # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [0, 1048575]
-
-## simm21_lsb0
-jal gp, -1048578 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, -1048577 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, 1048575 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, 1048576 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, 1 # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-
-# Illegal operand modifier
-## fencearg
-fence %hi(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence %lo(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence %pcrel_hi(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-fence %pcrel_lo(iorw), iorw # CHECK: :[[@LINE]]:7: error: operand must be formed of letters selected in-order from 'iorw'
-
-## uimm5
-slli a0, a0, %lo(1) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srli a0, a0, %lo(a) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-srai a0, a0, %hi(2) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [0, 31]
-csrrwi a1, 0x1, %hi(b) # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrsi t1, 999, %pcrel_hi(3) # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrci x0, 43, %pcrel_hi(c) # CHECK: :[[@LINE]]:16: error: immediate must be an integer in the range [0, 31]
-csrrsi t1, 999, %pcrel_lo(4) # CHECK: :[[@LINE]]:17: error: immediate must be an integer in the range [0, 31]
-csrrci x0, 43, %pcrel_lo(d) # CHECK: :[[@LINE]]:16: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-ori a0, a1, %hi(foo) # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-2048, 2047]
-andi ra, sp, %pcrel_hi(123) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [-2048, 2047]
-xori a2, a3, %hi(345) # CHECK: :[[@LINE]]:14: error: immediate must be an integer in the range [-2048, 2047]
-
-## uimm12
-csrrw a0, %lo(1), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, %lo(a), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrs a0, %hi(2), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrc a0, %hi(b), a0 # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 4095]
-csrrwi a0, %pcrel_hi(3), 0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrsi a0, %pcrel_hi(c), a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrwi a0, %pcrel_lo(4), 0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-csrrsi a0, %pcrel_lo(d), a0 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [0, 4095]
-
-## simm13_lsb0
-beq t0, t1, %lo(1) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bne t0, t1, %lo(a) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-blt t0, t1, %hi(2) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bge t0, t1, %hi(b) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bltu t0, t1, %pcrel_hi(3) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bgeu t0, t1, %pcrel_hi(c) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bltu t0, t1, %pcrel_lo(4) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-bgeu t0, t1, %pcrel_lo(d) # CHECK: :[[@LINE]]:14: error: immediate must be a multiple of 2 bytes in the range [-4096, 4094]
-
-## uimm20
-lui a0, %lo(1) # CHECK: :[[@LINE]]:9: error: immediate must be an integer in the range [0, 1048575]
-auipc a1, %lo(foo) # CHECK: :[[@LINE]]:11: error: immediate must be an integer in the range [0, 1048575]
-
-## simm21_lsb0
-jal gp, %lo(1) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %lo(a) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %hi(2) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %hi(b) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_hi(3) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_hi(c) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_lo(4) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-jal gp, %pcrel_lo(d) # CHECK: :[[@LINE]]:9: error: immediate must be a multiple of 2 bytes in the range [-1048576, 1048574]
-
-# Unrecognized operand modifier
-addi t0, sp, %modifer(255) # CHECK: :[[@LINE]]:15: error: unrecognized operand modifier
-
-# Use of operand modifier on register name
-addi t1, %lo(t2), 1 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Invalid mnemonics
-subs t0, t2, t1 # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-nandi t0, zero, 0 # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-
-# Invalid register names
-addi foo, sp, 10 # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-slti a10, a2, 0x20 # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-slt x32, s0, s0 # CHECK: :[[@LINE]]:5: error: invalid operand for instruction
-
-# RV64I mnemonics
-addiw a0, sp, 100 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-sraw t0, s2, zero # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-# Invalid operand types
-xori sp, 22, 220 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-sub t0, t2, 1 # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-add a1, a2, (a3) # CHECK: :[[@LINE]]:13: error: invalid operand for instruction
-
-# Too many operands
-add ra, zero, zero, zero # CHECK: :[[@LINE]]:21: error: invalid operand for instruction
-sltiu s2, s3, 0x50, 0x60 # CHECK: :[[@LINE]]:21: error: invalid operand for instruction
-
-# Memory operand not formatted correctly
-lw a4, a5, 111 # CHECK: :[[@LINE]]:8: error: immediate must be an integer in the range [-2048, 2047]
-
-# Too few operands
-ori a0, a1 # CHECK: :[[@LINE]]:1: error: too few operands for instruction
-xor s2, s2 # CHECK: :[[@LINE]]:1: error: too few operands for instruction
-
-# Instruction not in the base ISA
-mul a4, ra, s0 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-amomaxu.w s5, s4, (s3) # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-fadd.s ft0, ft1, ft2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
-# Using floating point registers when integer registers are expected
-addi a2, ft0, 24 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv32i-valid.s b/test/MC/RISCV/rv32i-valid.s
deleted file mode 100644
index 5171b5e06f4..00000000000
--- a/test/MC/RISCV/rv32i-valid.s
+++ /dev/null
@@ -1,240 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: lui a0, 2
-# CHECK: encoding: [0x37,0x25,0x00,0x00]
-lui a0, 2
-# CHECK-INST: lui s11, 552960
-# CHECK: encoding: [0xb7,0x0d,0x00,0x87]
-lui s11, (0x87000000>>12)
-# CHECK-INST: lui a0, 0
-# CHECK: encoding: [0x37,0x05,0x00,0x00]
-lui a0, %hi(2)
-# CHECK-INST: lui s11, 552960
-# CHECK: encoding: [0xb7,0x0d,0x00,0x87]
-lui s11, (0x87000000>>12)
-# CHECK-INST: lui s11, 552960
-# CHECK: encoding: [0xb7,0x0d,0x00,0x87]
-lui s11, %hi(0x87000000)
-# CHECK-INST: lui t0, 1048575
-# CHECK: encoding: [0xb7,0xf2,0xff,0xff]
-lui t0, 1048575
-# CHECK-INST: lui gp, 0
-# CHECK: encoding: [0xb7,0x01,0x00,0x00]
-lui gp, 0
-
-# CHECK-INST: auipc a0, 2
-# CHECK: encoding: [0x17,0x25,0x00,0x00]
-auipc a0, 2
-# CHECK-INST: auipc s11, 552960
-# CHECK: encoding: [0x97,0x0d,0x00,0x87]
-auipc s11, (0x87000000>>12)
-# CHECK-INST: auipc t0, 1048575
-# CHECK: encoding: [0x97,0xf2,0xff,0xff]
-auipc t0, 1048575
-# CHECK-INST: auipc gp, 0
-# CHECK: encoding: [0x97,0x01,0x00,0x00]
-auipc gp, 0
-
-# CHECK-INST: jal a2, 1048574
-# CHECK: encoding: [0x6f,0xf6,0xff,0x7f]
-jal a2, 1048574
-# CHECK-INST: jal a3, 256
-# CHECK: encoding: [0xef,0x06,0x00,0x10]
-jal a3, 256
-
-# CHECK-INST: jalr a0, a1, -2048
-# CHECK: encoding: [0x67,0x85,0x05,0x80]
-jalr a0, a1, -2048
-# CHECK-INST: jalr a0, a1, -2048
-# CHECK: encoding: [0x67,0x85,0x05,0x80]
-jalr a0, a1, %lo(2048)
-# CHECK-INST: jalr t2, t1, 2047
-# CHECK: encoding: [0xe7,0x03,0xf3,0x7f]
-jalr t2, t1, 2047
-# CHECK-INST: jalr sp, zero, 256
-# CHECK: encoding: [0x67,0x01,0x00,0x10]
-jalr sp, zero, 256
-
-# CHECK-INST: beq s1, s1, 102
-# CHECK: encoding: [0x63,0x83,0x94,0x06]
-beq s1, s1, 102
-# CHECK-INST: bne a4, a5, -4096
-# CHECK: encoding: [0x63,0x10,0xf7,0x80]
-bne a4, a5, -4096
-# CHECK-INST: blt sp, gp, 4094
-# CHECK: encoding: [0xe3,0x4f,0x31,0x7e]
-blt sp, gp, 4094
-# CHECK-INST: bge s2, ra, -224
-# CHECK: encoding: [0xe3,0x50,0x19,0xf2]
-bge s2, ra, -224
-# CHECK-INST: bltu zero, zero, 0
-# CHECK: encoding: [0x63,0x60,0x00,0x00]
-bltu zero, zero, 0
-# CHECK-INST: bgeu s8, sp, 512
-# CHECK: encoding: [0x63,0x70,0x2c,0x20]
-bgeu s8, sp, 512
-
-# CHECK-INST: lb s3, 4(ra)
-# CHECK: encoding: [0x83,0x89,0x40,0x00]
-lb s3, 4(ra)
-# CHECK-INST: lb s3, 4(ra)
-# CHECK: encoding: [0x83,0x89,0x40,0x00]
-lb s3, +4(ra)
-# CHECK-INST: lh t1, -2048(zero)
-# CHECK: encoding: [0x03,0x13,0x00,0x80]
-lh t1, -2048(zero)
-# CHECK-INST: lh t1, -2048(zero)
-# CHECK: encoding: [0x03,0x13,0x00,0x80]
-lh t1, %lo(2048)(zero)
-# CHECK-INST: lh sp, 2047(a0)
-# CHECK: encoding: [0x03,0x11,0xf5,0x7f]
-lh sp, 2047(a0)
-# CHECK-INST: lw a0, 97(a2)
-# CHECK: encoding: [0x03,0x25,0x16,0x06]
-lw a0, 97(a2)
-# CHECK-INST: lbu s5, 0(s6)
-# CHECK: encoding: [0x83,0x4a,0x0b,0x00]
-lbu s5, 0(s6)
-# CHECK-INST: lhu t3, 255(t3)
-# CHECK: encoding: [0x03,0x5e,0xfe,0x0f]
-lhu t3, 255(t3)
-
-# CHECK-INST: sb a0, 2047(a2)
-# CHECK: encoding: [0xa3,0x0f,0xa6,0x7e]
-sb a0, 2047(a2)
-# CHECK-INST: sh t3, -2048(t5)
-# CHECK: encoding: [0x23,0x10,0xcf,0x81]
-sh t3, -2048(t5)
-# CHECK-INST: sh t3, -2048(t5)
-# CHECK: encoding: [0x23,0x10,0xcf,0x81]
-sh t3, %lo(2048)(t5)
-# CHECK-INST: sw ra, 999(zero)
-# CHECK: encoding: [0xa3,0x23,0x10,0x3e]
-sw ra, 999(zero)
-
-# CHECK-INST: addi ra, sp, 2
-# CHECK: encoding: [0x93,0x00,0x21,0x00]
-addi ra, sp, 2
-# CHECK-INST: slti a0, a2, -20
-# CHECK: encoding: [0x13,0x25,0xc6,0xfe]
-slti a0, a2, -20
-# CHECK-INST: sltiu s2, s3, 80
-# CHECK: encoding: [0x13,0xb9,0x09,0x05]
-sltiu s2, s3, 0x50
-# CHECK-INST: xori tp, t1, -99
-# CHECK: encoding: [0x13,0x42,0xd3,0xf9]
-xori tp, t1, -99
-# CHECK-INST: ori a0, a1, -2048
-# CHECK: encoding: [0x13,0xe5,0x05,0x80]
-ori a0, a1, -2048
-# CHECK-INST: ori a0, a1, -2048
-# CHECK: encoding: [0x13,0xe5,0x05,0x80]
-ori a0, a1, %lo(2048)
-# CHECK-INST: andi ra, sp, 2047
-# CHECK: encoding: [0x93,0x70,0xf1,0x7f]
-andi ra, sp, 2047
-# CHECK-INST: andi ra, sp, 2047
-# CHECK: encoding: [0x93,0x70,0xf1,0x7f]
-andi x1, x2, 2047
-
-# CHECK-INST: slli t3, t3, 31
-# CHECK: encoding: [0x13,0x1e,0xfe,0x01]
-slli t3, t3, 31
-# CHECK-INST: srli a0, a4, 0
-# CHECK: encoding: [0x13,0x55,0x07,0x00]
-srli a0, a4, 0
-# CHECK-INST: srai a2, sp, 15
-# CHECK: encoding: [0x13,0x56,0xf1,0x40]
-srai a2, sp, 15
-
-# CHECK-INST: add ra, zero, zero
-# CHECK: encoding: [0xb3,0x00,0x00,0x00]
-add ra, zero, zero
-# CHECK-INST: add ra, zero, zero
-# CHECK: encoding: [0xb3,0x00,0x00,0x00]
-add x1, x0, x0
-# CHECK-INST: sub t0, t2, t1
-# CHECK: encoding: [0xb3,0x82,0x63,0x40]
-sub t0, t2, t1
-# CHECK-INST: sll a5, a4, a3
-# CHECK: encoding: [0xb3,0x17,0xd7,0x00]
-sll a5, a4, a3
-# CHECK-INST: slt s0, s0, s0
-# CHECK: encoding: [0x33,0x24,0x84,0x00]
-slt s0, s0, s0
-# CHECK-INST: sltu gp, a0, a1
-# CHECK: encoding: [0xb3,0x31,0xb5,0x00]
-sltu gp, a0, a1
-# CHECK-INST: xor s2, s2, s8
-# CHECK: encoding: [0x33,0x49,0x89,0x01]
-xor s2, s2, s8
-# CHECK-INST: xor s2, s2, s8
-# CHECK: encoding: [0x33,0x49,0x89,0x01]
-xor x18, x18, x24
-# CHECK-INST: srl a0, s0, t0
-# CHECK: encoding: [0x33,0x55,0x54,0x00]
-srl a0, s0, t0
-# CHECK-INST: sra t0, s2, zero
-# CHECK: encoding: [0xb3,0x52,0x09,0x40]
-sra t0, s2, zero
-# CHECK-INST: or s10, t1, ra
-# CHECK: encoding: [0x33,0x6d,0x13,0x00]
-or s10, t1, ra
-# CHECK-INST: and a0, s2, s3
-# CHECK: encoding: [0x33,0x75,0x39,0x01]
-and a0, s2, s3
-
-# CHECK-INST: fence iorw, iorw
-# CHECK: encoding: [0x0f,0x00,0xf0,0x0f]
-fence iorw, iorw
-# CHECK-INST: fence io, rw
-# CHECK: encoding: [0x0f,0x00,0x30,0x0c]
-fence io, rw
-# CHECK-INST: fence r, w
-# CHECK: encoding: [0x0f,0x00,0x10,0x02]
-fence r,w
-# CHECK-INST: fence w, ir
-# CHECK: encoding: [0x0f,0x00,0xa0,0x01]
-fence w,ir
-
-# CHECK-INST: fence.i
-# CHECK: encoding: [0x0f,0x10,0x00,0x00]
-fence.i
-
-# CHECK-INST: ecall
-# CHECK: encoding: [0x73,0x00,0x00,0x00]
-ecall
-# CHECK-INST: ebreak
-# CHECK: encoding: [0x73,0x00,0x10,0x00]
-ebreak
-
-# CHECK-INST: csrrw t0, 4095, t1
-# CHECK: encoding: [0xf3,0x12,0xf3,0xff]
-csrrw t0, 0xfff, t1
-# CHECK-INST: csrrs s0, 3072, zero
-# CHECK: encoding: [0x73,0x24,0x00,0xc0]
-csrrs s0, 0xc00, x0
-# CHECK-INST: csrrs s3, 1, s5
-# CHECK: encoding: [0xf3,0xa9,0x1a,0x00]
-csrrs s3, 0x001, s5
-# CHECK-INST: csrrc sp, 0, ra
-# CHECK: encoding: [0x73,0xb1,0x00,0x00]
-csrrc sp, 0x000, ra
-# CHECK-INST: csrrwi a5, 0, 0
-# CHECK: encoding: [0xf3,0x57,0x00,0x00]
-csrrwi a5, 0x000, 0
-# CHECK-INST: csrrsi t2, 4095, 31
-# CHECK: encoding: [0xf3,0xe3,0xff,0xff]
-csrrsi t2, 0xfff, 31
-# CHECK-INST: csrrci t1, 320, 5
-# CHECK: encoding: [0x73,0xf3,0x02,0x14]
-csrrci t1, 0x140, 5
diff --git a/test/MC/RISCV/rv32m-invalid.s b/test/MC/RISCV/rv32m-invalid.s
deleted file mode 100644
index 5e268e8b916..00000000000
--- a/test/MC/RISCV/rv32m-invalid.s
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: not llvm-mc -triple riscv32 -mattr=+m < %s 2>&1 | FileCheck %s
-
-# RV64M instructions can't be used for RV32
-mulw ra, sp, gp # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-divw tp, t0, t1 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-divuw t2, s0, s2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-remw a0, a1, a2 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-remuw a3, a4, a5 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-
diff --git a/test/MC/RISCV/rv32m-valid.s b/test/MC/RISCV/rv32m-valid.s
deleted file mode 100644
index 385c4d86cd3..00000000000
--- a/test/MC/RISCV/rv32m-valid.s
+++ /dev/null
@@ -1,35 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+m -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+m -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+m < %s \
-# RUN:     | llvm-objdump -mattr=+m -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+m < %s \
-# RUN:     | llvm-objdump -mattr=+m -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: mul a4, ra, s0
-# CHECK: encoding: [0x33,0x87,0x80,0x02]
-mul a4, ra, s0
-# CHECK-INST: mulh ra, zero, zero
-# CHECK: encoding: [0xb3,0x10,0x00,0x02]
-mulh x1, x0, x0
-# CHECK-INST: mulhsu t0, t2, t1
-# CHECK: encoding: [0xb3,0xa2,0x63,0x02]
-mulhsu t0, t2, t1
-# CHECK-INST: mulhu a5, a4, a3
-# CHECK: encoding: [0xb3,0x37,0xd7,0x02]
-mulhu a5, a4, a3
-# CHECK-INST: div s0, s0, s0
-# CHECK: encoding: [0x33,0x44,0x84,0x02]
-div s0, s0, s0
-# CHECK-INST: divu gp, a0, a1
-# CHECK: encoding: [0xb3,0x51,0xb5,0x02]
-divu gp, a0, a1
-# CHECK-INST: rem s2, s2, s8
-# CHECK: encoding: [0x33,0x69,0x89,0x03]
-rem s2, s2, s8
-# CHECK-INST: remu s2, s2, s8
-# CHECK: encoding: [0x33,0x79,0x89,0x03]
-remu x18, x18, x24
diff --git a/test/MC/RISCV/rv64-relaxation.s b/test/MC/RISCV/rv64-relaxation.s
deleted file mode 100644
index 018408f575a..00000000000
--- a/test/MC/RISCV/rv64-relaxation.s
+++ /dev/null
@@ -1,64 +0,0 @@
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -d - | FileCheck -check-prefix=INSTR %s
-
-FAR_JUMP_NEGATIVE:
-  c.nop
-.space 2000
-
-FAR_BRANCH_NEGATIVE:
-  c.nop
-.space 256
-
-NEAR_NEGATIVE:
-  c.nop
-
-start:
-  c.bnez a0, NEAR
-#INSTR: c.bnez a0, 56
-  c.bnez a0, NEAR_NEGATIVE
-#INSTR: c.bnez a0, -4
-  c.bnez a0, FAR_BRANCH
-#INSTR-NEXT: bnez a0, 310
-  c.bnez a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: bnez a0, -268
-  c.bnez a0, FAR_JUMP
-#INSTR-NEXT: bnez a0, 2304
-  c.bnez a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: bnez a0, -2278
-
-  c.beqz a0, NEAR
-#INSTR-NEXT: c.beqz a0, 36
-  c.beqz a0, NEAR_NEGATIVE
-#INSTR-NEXT: c.beqz a0, -24
-  c.beqz a0, FAR_BRANCH
-#INSTR-NEXT: beqz a0, 290
-  c.beqz a0, FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: beqz a0, -288
-  c.beqz a0, FAR_JUMP
-#INSTR-NEXT: beqz a0, 2284
-  c.beqz a0, FAR_JUMP_NEGATIVE
-#INSTR-NEXT: beqz a0, -2298
-
-  c.j NEAR
-#INSTR-NEXT: c.j 16
-  c.j NEAR_NEGATIVE
-#INSTR-NEXT: c.j -44
-  c.j FAR_BRANCH
-#INSTR-NEXT: c.j 270
-  c.j FAR_BRANCH_NEGATIVE
-#INSTR-NEXT: c.j -306
-  c.j FAR_JUMP
-#INSTR-NEXT: j 2268
-  c.j FAR_JUMP_NEGATIVE
-#INSTR-NEXT: j -2314
-
-NEAR:
-  c.nop
-
-.space 256
-FAR_BRANCH:
-  c.nop
-
-.space 2000
-FAR_JUMP:
-  c.nop
diff --git a/test/MC/RISCV/rv64a-invalid.s b/test/MC/RISCV/rv64a-invalid.s
deleted file mode 100644
index 7ab89ff9994..00000000000
--- a/test/MC/RISCV/rv64a-invalid.s
+++ /dev/null
@@ -1,14 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 -mattr=+a < %s 2>&1 | FileCheck %s
-
-# Final operand must have parentheses
-amoswap.d a1, a2, a3 # CHECK: :[[@LINE]]:19: error: invalid operand for instruction
-amomin.d a1, a2, 1 # CHECK: :[[@LINE]]:18: error: invalid operand for instruction
-lr.d a4, a5 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-
-# Only .aq, .rl, and .aqrl suffixes are valid
-amoxor.d.rlqa a2, a3, (a4) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.d.aq.rl a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-amoor.d. a4, a5, (a6) # CHECK: :[[@LINE]]:1: error: unrecognized instruction mnemonic
-
-# lr only takes two operands
-lr.d s0, (s1), s2 # CHECK: :[[@LINE]]:16: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv64a-valid.s b/test/MC/RISCV/rv64a-valid.s
deleted file mode 100644
index 3203d6e6d3f..00000000000
--- a/test/MC/RISCV/rv64a-valid.s
+++ /dev/null
@@ -1,190 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+a -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+a < %s \
-# RUN:     | llvm-objdump -mattr=+a -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+a < %s 2>&1 \
-# RUN:     | FileCheck -check-prefix=CHECK-RV32 %s
-
-# CHECK-INST: lr.d t0, (t1)
-# CHECK: encoding: [0xaf,0x32,0x03,0x10]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d t0, (t1)
-# CHECK-INST: lr.d.aq t1, (t2)
-# CHECK: encoding: [0x2f,0xb3,0x03,0x14]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d.aq t1, (t2)
-# CHECK-INST: lr.d.rl t2, (t3)
-# CHECK: encoding: [0xaf,0x33,0x0e,0x12]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d.rl t2, (t3)
-# CHECK-INST: lr.d.aqrl t3, (t4)
-# CHECK: encoding: [0x2f,0xbe,0x0e,0x16]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-lr.d.aqrl t3, (t4)
-
-# CHECK-INST: sc.d t6, t5, (t4)
-# CHECK: encoding: [0xaf,0xbf,0xee,0x19]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d t6, t5, (t4)
-# CHECK-INST: sc.d.aq t5, t4, (t3)
-# CHECK: encoding: [0x2f,0x3f,0xde,0x1d]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d.aq t5, t4, (t3)
-# CHECK-INST: sc.d.rl t4, t3, (t2)
-# CHECK: encoding: [0xaf,0xbe,0xc3,0x1b]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d.rl t4, t3, (t2)
-# CHECK-INST: sc.d.aqrl t3, t2, (t1)
-# CHECK: encoding: [0x2f,0x3e,0x73,0x1e]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-sc.d.aqrl t3, t2, (t1)
-
-# CHECK-INST: amoswap.d a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x37,0x14,0x08]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d a4, ra, (s0)
-# CHECK-INST: amoadd.d a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xb5,0xc6,0x00]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d a1, a2, (a3)
-# CHECK-INST: amoxor.d a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x36,0xd7,0x20]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d a2, a3, (a4)
-# CHECK-INST: amoand.d a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xb6,0xe7,0x60]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d a3, a4, (a5)
-# CHECK-INST: amoor.d a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x37,0xf8,0x40]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d a4, a5, (a6)
-# CHECK-INST: amomin.d a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xb7,0x08,0x81]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d a5, a6, (a7)
-# CHECK-INST: amomax.d s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xbb,0x6a,0xa1]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d s7, s6, (s5)
-# CHECK-INST: amominu.d s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x3b,0x5a,0xc1]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d s6, s5, (s4)
-# CHECK-INST: amomaxu.d s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xba,0x49,0xe1]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d s5, s4, (s3)
-
-
-# CHECK-INST: amoswap.d.aq a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x37,0x14,0x0c]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d.aq a4, ra, (s0)
-# CHECK-INST: amoadd.d.aq a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xb5,0xc6,0x04]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d.aq a1, a2, (a3)
-# CHECK-INST: amoxor.d.aq a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x36,0xd7,0x24]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d.aq a2, a3, (a4)
-# CHECK-INST: amoand.d.aq a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xb6,0xe7,0x64]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d.aq a3, a4, (a5)
-# CHECK-INST: amoor.d.aq a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x37,0xf8,0x44]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d.aq a4, a5, (a6)
-# CHECK-INST: amomin.d.aq a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xb7,0x08,0x85]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d.aq a5, a6, (a7)
-# CHECK-INST: amomax.d.aq s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xbb,0x6a,0xa5]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d.aq s7, s6, (s5)
-# CHECK-INST: amominu.d.aq s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x3b,0x5a,0xc5]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d.aq s6, s5, (s4)
-# CHECK-INST: amomaxu.d.aq s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xba,0x49,0xe5]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d.aq s5, s4, (s3)
-
-# CHECK-INST: amoswap.d.rl a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x37,0x14,0x0a]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d.rl a4, ra, (s0)
-# CHECK-INST: amoadd.d.rl a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xb5,0xc6,0x02]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d.rl a1, a2, (a3)
-# CHECK-INST: amoxor.d.rl a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x36,0xd7,0x22]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d.rl a2, a3, (a4)
-# CHECK-INST: amoand.d.rl a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xb6,0xe7,0x62]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d.rl a3, a4, (a5)
-# CHECK-INST: amoor.d.rl a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x37,0xf8,0x42]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d.rl a4, a5, (a6)
-# CHECK-INST: amomin.d.rl a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xb7,0x08,0x83]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d.rl a5, a6, (a7)
-# CHECK-INST: amomax.d.rl s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xbb,0x6a,0xa3]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d.rl s7, s6, (s5)
-# CHECK-INST: amominu.d.rl s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x3b,0x5a,0xc3]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d.rl s6, s5, (s4)
-# CHECK-INST: amomaxu.d.rl s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xba,0x49,0xe3]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d.rl s5, s4, (s3)
-
-# CHECK-INST: amoswap.d.aqrl a4, ra, (s0)
-# CHECK: encoding: [0x2f,0x37,0x14,0x0e]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoswap.d.aqrl a4, ra, (s0)
-# CHECK-INST: amoadd.d.aqrl a1, a2, (a3)
-# CHECK: encoding: [0xaf,0xb5,0xc6,0x06]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoadd.d.aqrl a1, a2, (a3)
-# CHECK-INST: amoxor.d.aqrl a2, a3, (a4)
-# CHECK: encoding: [0x2f,0x36,0xd7,0x26]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoxor.d.aqrl a2, a3, (a4)
-# CHECK-INST: amoand.d.aqrl a3, a4, (a5)
-# CHECK: encoding: [0xaf,0xb6,0xe7,0x66]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoand.d.aqrl a3, a4, (a5)
-# CHECK-INST: amoor.d.aqrl a4, a5, (a6)
-# CHECK: encoding: [0x2f,0x37,0xf8,0x46]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amoor.d.aqrl a4, a5, (a6)
-# CHECK-INST: amomin.d.aqrl a5, a6, (a7)
-# CHECK: encoding: [0xaf,0xb7,0x08,0x87]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomin.d.aqrl a5, a6, (a7)
-# CHECK-INST: amomax.d.aqrl s7, s6, (s5)
-# CHECK: encoding: [0xaf,0xbb,0x6a,0xa7]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomax.d.aqrl s7, s6, (s5)
-# CHECK-INST: amominu.d.aqrl s6, s5, (s4)
-# CHECK: encoding: [0x2f,0x3b,0x5a,0xc7]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amominu.d.aqrl s6, s5, (s4)
-# CHECK-INST: amomaxu.d.aqrl s5, s4, (s3)
-# CHECK: encoding: [0xaf,0xba,0x49,0xe7]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-amomaxu.d.aqrl s5, s4, (s3)
diff --git a/test/MC/RISCV/rv64c-invalid.s b/test/MC/RISCV/rv64c-invalid.s
deleted file mode 100644
index fdbcaba244f..00000000000
--- a/test/MC/RISCV/rv64c-invalid.s
+++ /dev/null
@@ -1,29 +0,0 @@
-# RUN: not llvm-mc -triple=riscv64 -mattr=+c < %s 2>&1 | FileCheck %s
-
-## GPRC
-c.ld ra, 4(sp) # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-c.sd sp, 4(sp) # CHECK: :[[@LINE]]:6: error: invalid operand for instruction
-c.addw   a0, a7 # CHECK: :[[@LINE]]:14: error: invalid operand for instruction
-c.subw   a0, a6 # CHECK: :[[@LINE]]:14: error: invalid operand for instruction
-
-## GPRNoX0
-c.ldsp  x0, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-c.ldsp  zero, 4(sp) # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# Out of range immediates
-
-## uimmlog2xlennonzero
-c.slli t0, 64 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 63]
-c.srli a0, -1 # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 63]
-c.srai a0, 0  # CHECK: :[[@LINE]]:12: error: immediate must be an integer in the range [1, 63]
-
-## simm6
-c.addiw t0, -33 # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-c.addiw t0, 32 # CHECK: :[[@LINE]]:13: error: immediate must be an integer in the range [-32, 31]
-
-## uimm9_lsb000
-c.ldsp  ra, 512(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-c.sdsp  ra, -8(sp) # CHECK: :[[@LINE]]:13: error: immediate must be a multiple of 8 bytes in the range [0, 504]
-## uimm8_lsb000
-c.ld  s0, -8(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 8 bytes in the range [0, 248]
-c.sd  s0, 256(sp) # CHECK: :[[@LINE]]:11: error: immediate must be a multiple of 8 bytes in the range [0, 248]
diff --git a/test/MC/RISCV/rv64c-valid.s b/test/MC/RISCV/rv64c-valid.s
deleted file mode 100644
index c436fe5414c..00000000000
--- a/test/MC/RISCV/rv64c-valid.s
+++ /dev/null
@@ -1,58 +0,0 @@
-# RUN: llvm-mc -triple=riscv64 -mattr=+c -riscv-no-aliases -show-encoding < %s \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+c < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv64 \
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+c\
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# TODO: more exhaustive testing of immediate encoding.
-
-# CHECK-INST: c.ldsp  ra, 0(sp)
-# CHECK: encoding: [0x82,0x60]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.ldsp  ra, 0(sp)
-# CHECK-INST: c.sdsp  ra, 504(sp)
-# CHECK: encoding: [0x86,0xff]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.sdsp  ra, 504(sp)
-# CHECK-INST: c.ld    a4, 0(a3)
-# CHECK: encoding: [0x98,0x62]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.ld    a4, 0(a3)
-# CHECK-INST: c.sd    a5, 248(a3)
-# CHECK: encoding: [0xfc,0xfe]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.sd    a5, 248(a3)
-
-# CHECK-INST: c.subw   a3, a4
-# CHECK: encoding: [0x99,0x9e]
-c.subw   a3, a4
-# CHECK-INST: c.addw   a0, a2
-# CHECK: encoding: [0x31,0x9d]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.addw   a0, a2
-
-# CHECK-INST: c.addiw  a3, -32
-# CHECK: encoding: [0x81,0x36]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.addiw  a3, -32
-# CHECK-INST: c.addiw  a3, 31
-# CHECK: encoding: [0xfd,0x26]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.addiw  a3, 31
-
-# CHECK-INST: c.slli  s0, 1
-# CHECK: encoding: [0x06,0x04]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.slli  s0, 1
-# CHECK-INST: c.srli  a3, 63
-# CHECK: encoding: [0xfd,0x92]
-c.srli  a3, 63
-# CHECK-INST: c.srai  a2, 63
-# CHECK: encoding: [0x7d,0x96]
-c.srai  a2, 63
diff --git a/test/MC/RISCV/rv64d-aliases-valid.s b/test/MC/RISCV/rv64d-aliases-valid.s
deleted file mode 100644
index f6c5663eac7..00000000000
--- a/test/MC/RISCV/rv64d-aliases-valid.s
+++ /dev/null
@@ -1,27 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fcvt.l.d a0, ft0, dyn
-# CHECK-ALIAS: fcvt.l.d a0, ft0{{[[:space:]]}}
-fcvt.l.d a0, ft0
-# CHECK-INST: fcvt.lu.d a1, ft1, dyn
-# CHECK-ALIAS: fcvt.lu.d a1, ft1{{[[:space:]]}}
-fcvt.lu.d a1, ft1
-# CHECK-INST: fcvt.d.l ft3, a3, dyn
-# CHECK-ALIAS: fcvt.d.l ft3, a3{{[[:space:]]}}
-fcvt.d.l ft3, a3
-# CHECK-INST: fcvt.d.lu ft4, a4, dyn
-# CHECK-ALIAS: fcvt.d.lu ft4, a4{{[[:space:]]}}
-fcvt.d.lu ft4, a4
diff --git a/test/MC/RISCV/rv64d-invalid.s b/test/MC/RISCV/rv64d-invalid.s
deleted file mode 100644
index 0f508aafd9b..00000000000
--- a/test/MC/RISCV/rv64d-invalid.s
+++ /dev/null
@@ -1,11 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 -mattr=+d < %s 2>&1 | FileCheck %s
-
-# Integer registers where FP regs are expected
-fcvt.l.d ft0, a0 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.lu.d ft1, a1 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-fmv.x.d ft2, a2 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fcvt.d.l a3, ft3 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.d.lu a4, ft4 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-fmv.d.x a5, ft5 # CHECK: :[[@LINE]]:9: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv64d-valid.s b/test/MC/RISCV/rv64d-valid.s
deleted file mode 100644
index c8dd5696f47..00000000000
--- a/test/MC/RISCV/rv64d-valid.s
+++ /dev/null
@@ -1,50 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+d < %s 2>&1 \
-# RUN:     | FileCheck -check-prefix=CHECK-RV32 %s
-
-# CHECK-INST: fcvt.l.d a0, ft0, dyn
-# CHECK: encoding: [0x53,0x75,0x20,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.d a0, ft0, dyn
-# CHECK-INST: fcvt.lu.d a1, ft1, dyn
-# CHECK: encoding: [0xd3,0xf5,0x30,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.d a1, ft1, dyn
-# CHECK-INST: fmv.x.d a2, ft2
-# CHECK: encoding: [0x53,0x06,0x01,0xe2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fmv.x.d a2, ft2
-# CHECK-INST: fcvt.d.l ft3, a3, dyn
-# CHECK: encoding: [0xd3,0xf1,0x26,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.l ft3, a3, dyn
-# CHECK-INST: fcvt.d.lu ft4, a4, dyn
-# CHECK: encoding: [0x53,0x72,0x37,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.lu ft4, a4, dyn
-# CHECK-INST: fmv.d.x ft5, a5
-# CHECK: encoding: [0xd3,0x82,0x07,0xf2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fmv.d.x ft5, a5
-
-# Rounding modes
-# CHECK-INST: fcvt.d.l ft3, a3, rne
-# CHECK: encoding: [0xd3,0x81,0x26,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.l ft3, a3, rne
-# CHECK-INST: fcvt.d.lu ft4, a4, rtz
-# CHECK: encoding: [0x53,0x12,0x37,0xd2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.d.lu ft4, a4, rtz
-# CHECK-INST: fcvt.l.d a0, ft0, rdn
-# CHECK: encoding: [0x53,0x25,0x20,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.d a0, ft0, rdn
-# CHECK-INST: fcvt.lu.d a1, ft1, rup
-# CHECK: encoding: [0xd3,0xb5,0x30,0xc2]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.d a1, ft1, rup
diff --git a/test/MC/RISCV/rv64dc-valid.s b/test/MC/RISCV/rv64dc-valid.s
deleted file mode 100644
index c9ef4cbf289..00000000000
--- a/test/MC/RISCV/rv64dc-valid.s
+++ /dev/null
@@ -1,29 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+c,+d -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple=riscv64 -mattr=+c,+d < %s \
-# RUN:     | llvm-objdump -mattr=+d -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv64 -mattr=+c\
-# RUN:     -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN: | FileCheck -check-prefixes=CHECK-NO-EXT %s
-# RUN:     not llvm-mc -triple riscv64 \
-# RUN: -riscv-no-aliases -show-encoding < %s 2>&1 \
-# RUN:     | FileCheck -check-prefixes=CHECK-NO-EXT %s
-
-# CHECK-INST: c.fldsp  fs0, 504(sp)
-# CHECK: encoding: [0x7e,0x34]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fldsp  fs0, 504(sp)
-# CHECK-INST: c.fsdsp  fa7, 504(sp)
-# CHECK: encoding: [0xc6,0xbf]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsdsp  fa7, 504(sp)
-
-# CHECK-INST: c.fld  fa3, 248(a5)
-# CHECK: encoding: [0xf4,0x3f]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fld  fa3, 248(a5)
-# CHECK-INST: c.fsd  fa2, 248(a1)
-# CHECK: encoding: [0xf0,0xbd]
-# CHECK-NO-EXT:  error: instruction use requires an option to be enabled
-c.fsd  fa2, 248(a1)
diff --git a/test/MC/RISCV/rv64f-aliases-valid.s b/test/MC/RISCV/rv64f-aliases-valid.s
deleted file mode 100644
index c9c2a4b6d74..00000000000
--- a/test/MC/RISCV/rv64f-aliases-valid.s
+++ /dev/null
@@ -1,27 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fcvt.l.s a0, ft0, dyn
-# CHECK-ALIAS: fcvt.l.s a0, ft0{{[[:space:]]}}
-fcvt.l.s a0, ft0
-# CHECK-INST: fcvt.lu.s a1, ft1, dyn
-# CHECK-ALIAS: fcvt.lu.s a1, ft1{{[[:space:]]}}
-fcvt.lu.s a1, ft1
-# CHECK-INST: fcvt.s.l ft2, a2, dyn
-# CHECK-ALIAS: fcvt.s.l ft2, a2{{[[:space:]]}}
-fcvt.s.l ft2, a2
-# CHECK-INST: fcvt.s.lu ft3, a3, dyn
-# CHECK-ALIAS: fcvt.s.lu ft3, a3{{[[:space:]]}}
-fcvt.s.lu ft3, a3
diff --git a/test/MC/RISCV/rv64f-invalid.s b/test/MC/RISCV/rv64f-invalid.s
deleted file mode 100644
index 698da796a7e..00000000000
--- a/test/MC/RISCV/rv64f-invalid.s
+++ /dev/null
@@ -1,9 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 -mattr=+f < %s 2>&1 | FileCheck %s
-
-# Integer registers where FP regs are expected
-fcvt.l.s ft0, a0 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.lu.s ft1, a1 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
-
-# FP registers where integer regs are expected
-fcvt.s.l a2, ft2 # CHECK: :[[@LINE]]:10: error: invalid operand for instruction
-fcvt.s.lu a3, ft3 # CHECK: :[[@LINE]]:11: error: invalid operand for instruction
diff --git a/test/MC/RISCV/rv64f-valid.s b/test/MC/RISCV/rv64f-valid.s
deleted file mode 100644
index 69b503bef80..00000000000
--- a/test/MC/RISCV/rv64f-valid.s
+++ /dev/null
@@ -1,38 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -mattr=+f -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: not llvm-mc -triple riscv32 -mattr=+f < %s 2>&1 \
-# RUN:     | FileCheck -check-prefix=CHECK-RV32 %s
-
-# CHECK-INST: fcvt.l.s a0, ft0, dyn
-# CHECK: encoding: [0x53,0x75,0x20,0xc0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.s a0, ft0, dyn
-# CHECK-INST: fcvt.lu.s a1, ft1, dyn
-# CHECK: encoding: [0xd3,0xf5,0x30,0xc0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.s a1, ft1, dyn
-# CHECK-INST: fcvt.s.l ft2, a2, dyn
-# CHECK: encoding: [0x53,0x71,0x26,0xd0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.l ft2, a2, dyn
-# CHECK-INST: fcvt.s.lu ft3, a3, dyn
-# CHECK: encoding: [0xd3,0xf1,0x36,0xd0]
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.lu ft3, a3, dyn
-
-# Rounding modes
-# CHECK-INST: fcvt.l.s a4, ft4, rne
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.l.s a4, ft4, rne
-# CHECK-INST: fcvt.lu.s a5, ft5, rtz
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.lu.s a5, ft5, rtz
-# CHECK-INST: fcvt.s.l ft6, a6, rdn
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.l ft6, a6, rdn
-# CHECK-INST: fcvt.s.lu ft7, a7, rup
-# CHECK-RV32: :[[@LINE+1]]:1: error: instruction use requires an option to be enabled
-fcvt.s.lu ft7, a7, rup
diff --git a/test/MC/RISCV/rv64i-aliases-invalid.s b/test/MC/RISCV/rv64i-aliases-invalid.s
deleted file mode 100644
index f8e3991f1c9..00000000000
--- a/test/MC/RISCV/rv64i-aliases-invalid.s
+++ /dev/null
@@ -1,6 +0,0 @@
-# RUN: not llvm-mc %s -triple=riscv64 -riscv-no-aliases 2>&1 | FileCheck %s
-# RUN: not llvm-mc %s -triple=riscv64 2>&1 | FileCheck %s
-
-rdinstreth x29 # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-rdcycleh x27   # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
-rdtimeh x28    # CHECK: :[[@LINE]]:1: error: instruction use requires an option to be enabled
diff --git a/test/MC/RISCV/rv64i-aliases-valid.s b/test/MC/RISCV/rv64i-aliases-valid.s
deleted file mode 100644
index 953493e147b..00000000000
--- a/test/MC/RISCV/rv64i-aliases-valid.s
+++ /dev/null
@@ -1,20 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-# TODO ld
-# TODO sd
-
-# CHECK-INST: subw t6, zero, ra
-# CHECK-ALIAS: negw t6, ra
-negw x31, x1
-# CHECK-INST: addiw t6, ra, 0
-# CHECK-ALIAS: sext.w t6, ra
-sext.w x31, x1
diff --git a/test/MC/RISCV/rv64i-invalid.s b/test/MC/RISCV/rv64i-invalid.s
deleted file mode 100644
index d35fada3874..00000000000
--- a/test/MC/RISCV/rv64i-invalid.s
+++ /dev/null
@@ -1,20 +0,0 @@
-# RUN: not llvm-mc -triple riscv64 < %s 2>&1 | FileCheck %s
-
-# Out of range immediates
-## uimm5
-slliw a0, a0, 32 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-srliw a0, a0, -1 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-sraiw a0, a0, -19 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-addiw a0, a1, -2049 # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [-2048, 2047]
-ld ra, 2048(sp) # CHECK: :[[@LINE]]:8: error: immediate must be an integer in the range [-2048, 2047]
-
-# Illegal operand modifier
-## uimm5
-slliw a0, a0, %lo(1) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-srliw a0, a0, %lo(a) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-sraiw a0, a0, %hi(2) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [0, 31]
-
-## simm12
-addiw a0, a1, %hi(foo) # CHECK: :[[@LINE]]:15: error: immediate must be an integer in the range [-2048, 2047]
diff --git a/test/MC/RISCV/rv64i-valid.s b/test/MC/RISCV/rv64i-valid.s
deleted file mode 100644
index 57868c41bea..00000000000
--- a/test/MC/RISCV/rv64i-valid.s
+++ /dev/null
@@ -1,99 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: lwu zero, 4(ra)
-# CHECK: encoding: [0x03,0xe0,0x40,0x00]
-lwu x0, 4(x1)
-# CHECK-INST: lwu sp, 4(gp)
-# CHECK: encoding: [0x03,0xe1,0x41,0x00]
-lwu x2, +4(x3)
-# CHECK-INST: lwu tp, -2048(t0)
-# CHECK: encoding: [0x03,0xe2,0x02,0x80]
-lwu x4, -2048(x5)
-# CHECK-INST: lwu t1, -2048(t2)
-# CHECK: encoding: [0x03,0xe3,0x03,0x80]
-lwu x6, %lo(2048)(x7)
-# CHECK-INST: lwu s0, 2047(s1)
-# CHECK: encoding: [0x03,0xe4,0xf4,0x7f]
-lwu x8, 2047(x9)
-
-# CHECK-INST: ld a0, -2048(a1)
-# CHECK: encoding: [0x03,0xb5,0x05,0x80]
-ld x10, -2048(x11)
-# CHECK-INST: ld a2, -2048(a3)
-# CHECK: encoding: [0x03,0xb6,0x06,0x80]
-ld x12, %lo(2048)(x13)
-# CHECK-INST: ld a4, 2047(a5)
-# CHECK: encoding: [0x03,0xb7,0xf7,0x7f]
-ld x14, 2047(x15)
-
-# CHECK-INST: sd a6, -2048(a7)
-# CHECK: encoding: [0x23,0xb0,0x08,0x81]
-sd x16, -2048(x17)
-# CHECK-INST: sd s2, -2048(s3)
-# CHECK: encoding: [0x23,0xb0,0x29,0x81]
-sd x18, %lo(2048)(x19)
-# CHECK-INST: sd s4, 2047(s5)
-# CHECK: encoding: [0xa3,0xbf,0x4a,0x7f]
-sd x20, 2047(x21)
-
-# CHECK-INST: slli s6, s7, 45
-# CHECK: encoding: [0x13,0x9b,0xdb,0x02]
-slli x22, x23, 45
-# CHECK-INST: srli s8, s9, 0
-# CHECK: encoding: [0x13,0xdc,0x0c,0x00]
-srli x24, x25, 0
-# CHECK-INST: srai s10, s11, 31
-# CHECK: encoding: [0x13,0xdd,0xfd,0x41]
-srai x26, x27, 31
-
-# CHECK-INST: addiw t3, t4, -2048
-# CHECK: encoding: [0x1b,0x8e,0x0e,0x80]
-addiw x28, x29, -2048
-# CHECK-INST: addiw t5, t6, 2047
-# CHECK: encoding: [0x1b,0x8f,0xff,0x7f]
-addiw x30, x31, 2047
-
-# CHECK-INST: slliw zero, ra, 0
-# CHECK: encoding: [0x1b,0x90,0x00,0x00]
-slliw zero, ra, 0
-# CHECK-INST: slliw sp, gp, 31
-# CHECK: encoding: [0x1b,0x91,0xf1,0x01]
-slliw sp, gp, 31
-# CHECK-INST: srliw tp, t0, 0
-# CHECK: encoding: [0x1b,0xd2,0x02,0x00]
-srliw tp, t0, 0
-# CHECK-INST: srliw t1, t2, 31
-# CHECK: encoding: [0x1b,0xd3,0xf3,0x01]
-srliw t1, t2, 31
-# CHECK-INST: sraiw s0, s1, 0
-# CHECK: encoding: [0x1b,0xd4,0x04,0x40]
-sraiw s0, s1, 0
-# CHECK-INST: sraiw a0, a1, 31
-# CHECK: encoding: [0x1b,0xd5,0xf5,0x41]
-sraiw a0, a1, 31
-
-# CHECK-INST: addw a2, a3, a4
-# CHECK: encoding: [0x3b,0x86,0xe6,0x00]
-addw a2, a3, a4
-# CHECK-INST: addw a5, a6, a7
-# CHECK: encoding: [0xbb,0x07,0x18,0x01]
-addw a5, a6, a7
-# CHECK-INST: subw s2, s3, s4
-# CHECK: encoding: [0x3b,0x89,0x49,0x41]
-subw s2, s3, s4
-# CHECK-INST: subw s5, s6, s7
-# CHECK: encoding: [0xbb,0x0a,0x7b,0x41]
-subw s5, s6, s7
-# CHECK-INST: sllw s8, s9, s10
-# CHECK: encoding: [0x3b,0x9c,0xac,0x01]
-sllw s8, s9, s10
-# CHECK-INST: srlw s11, t3, t4
-# CHECK: encoding: [0xbb,0x5d,0xde,0x01]
-srlw s11, t3, t4
-# CHECK-INST: sraw t5, t6, zero
-# CHECK: encoding: [0x3b,0xdf,0x0f,0x40]
-sraw t5, t6, zero
diff --git a/test/MC/RISCV/rv64m-valid.s b/test/MC/RISCV/rv64m-valid.s
deleted file mode 100644
index b34666c0310..00000000000
--- a/test/MC/RISCV/rv64m-valid.s
+++ /dev/null
@@ -1,21 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+m -riscv-no-aliases -show-encoding \
-# RUN:     | FileCheck -check-prefixes=CHECK,CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+m < %s \
-# RUN:     | llvm-objdump -mattr=+m -riscv-no-aliases -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-
-# CHECK-INST: mulw ra, sp, gp
-# CHECK: encoding: [0xbb,0x00,0x31,0x02]
-mulw ra, sp, gp
-# CHECK-INST: divw tp, t0, t1
-# CHECK: encoding: [0x3b,0xc2,0x62,0x02]
-divw tp, t0, t1
-# CHECK-INST: divuw t2, s0, s2
-# CHECK: encoding: [0xbb,0x53,0x24,0x03]
-divuw t2, s0, s2
-# CHECK-INST: remw a0, a1, a2
-# CHECK: encoding: [0x3b,0xe5,0xc5,0x02]
-remw a0, a1, a2
-# CHECK-INST: remuw a3, a4, a5
-# CHECK: encoding: [0xbb,0x76,0xf7,0x02]
-remuw a3, a4, a5
diff --git a/test/MC/RISCV/rvd-aliases-valid.s b/test/MC/RISCV/rvd-aliases-valid.s
deleted file mode 100644
index 29601048ec9..00000000000
--- a/test/MC/RISCV/rvd-aliases-valid.s
+++ /dev/null
@@ -1,78 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+d -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+d \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+d \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+d < %s \
-# RUN:     | llvm-objdump -d -mattr=+d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-##===----------------------------------------------------------------------===##
-
-# TODO fld
-# TODO fsd
-
-# CHECK-INST: fsgnj.d ft0, ft1, ft1
-# CHECK-ALIAS: fmv.d ft0, ft1
-fmv.d f0, f1
-# CHECK-INST: fsgnjx.d ft1, ft2, ft2
-# CHECK-ALIAS: fabs.d ft1, ft2
-fabs.d f1, f2
-# CHECK-INST: fsgnjn.d ft2, ft3, ft3
-# CHECK-ALIAS: fneg.d ft2, ft3
-fneg.d f2, f3
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fmadd.d fa0, fa1, fa2, fa3, dyn
-# CHECK-ALIAS: fmadd.d fa0, fa1, fa2, fa3{{[[:space:]]}}
-fmadd.d f10, f11, f12, f13
-# CHECK-INST: fmsub.d fa4, fa5, fa6, fa7, dyn
-# CHECK-ALIAS: fmsub.d fa4, fa5, fa6, fa7{{[[:space:]]}}
-fmsub.d f14, f15, f16, f17
-# CHECK-INST: fnmsub.d fs2, fs3, fs4, fs5, dyn
-# CHECK-ALIAS: fnmsub.d fs2, fs3, fs4, fs5{{[[:space:]]}}
-fnmsub.d f18, f19, f20, f21
-# CHECK-INST: fnmadd.d fs6, fs7, fs8, fs9, dyn
-# CHECK-ALIAS: fnmadd.d fs6, fs7, fs8, fs9{{[[:space:]]}}
-fnmadd.d f22, f23, f24, f25
-# CHECK-INST: fadd.d fs10, fs11, ft8, dyn
-# CHECK-ALIAS: fadd.d fs10, fs11, ft8{{[[:space:]]}}
-fadd.d f26, f27, f28
-# CHECK-INST: fsub.d ft9, ft10, ft11, dyn
-# CHECK-ALIAS: fsub.d ft9, ft10, ft11{{[[:space:]]}}
-fsub.d f29, f30, f31
-# CHECK-INST: fmul.d ft0, ft1, ft2, dyn
-# CHECK-ALIAS: fmul.d ft0, ft1, ft2{{[[:space:]]}}
-fmul.d ft0, ft1, ft2
-# CHECK-INST: fdiv.d ft3, ft4, ft5, dyn
-# CHECK-ALIAS: fdiv.d ft3, ft4, ft5{{[[:space:]]}}
-fdiv.d ft3, ft4, ft5
-# CHECK-INST: fsqrt.d ft6, ft7, dyn
-# CHECK-ALIAS: fsqrt.d ft6, ft7{{[[:space:]]}}
-fsqrt.d ft6, ft7
-# CHECK-INST: fcvt.s.d fs5, fs6, dyn
-# CHECK-ALIAS: fcvt.s.d fs5, fs6{{[[:space:]]}}
-fcvt.s.d fs5, fs6
-# CHECK-INST: fcvt.w.d a4, ft11, dyn
-# CHECK-ALIAS: fcvt.w.d a4, ft11{{[[:space:]]}}
-fcvt.w.d a4, ft11
-# CHECK-INST: fcvt.wu.d a5, ft10, dyn
-# CHECK-ALIAS: fcvt.wu.d a5, ft10{{[[:space:]]}}
-fcvt.wu.d a5, ft10
diff --git a/test/MC/RISCV/rvf-aliases-valid.s b/test/MC/RISCV/rvf-aliases-valid.s
deleted file mode 100644
index d306eb77e09..00000000000
--- a/test/MC/RISCV/rvf-aliases-valid.s
+++ /dev/null
@@ -1,125 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+f -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 -mattr=+f \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 -mattr=+f \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 -mattr=+f < %s \
-# RUN:     | llvm-objdump -d -mattr=+f - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-##===----------------------------------------------------------------------===##
-## Assembler Pseudo Instructions (User-Level ISA, Version 2.2, Chapter 20)
-##===----------------------------------------------------------------------===##
-
-# TODO flw
-# TODO fsw
-
-# CHECK-INST: fsgnj.s ft0, ft1, ft1
-# CHECK-ALIAS: fmv.s ft0, ft1
-fmv.s f0, f1
-# CHECK-INST: fsgnjx.s ft1, ft2, ft2
-# CHECK-ALIAS: fabs.s ft1, ft2
-fabs.s f1, f2
-# CHECK-INST: fsgnjn.s ft2, ft3, ft3
-# CHECK-ALIAS: fneg.s ft2, ft3
-fneg.s f2, f3
-
-# The following instructions actually alias instructions from the base ISA.
-# However, it only makes sense to support them when the F extension is enabled.
-# CHECK-INST: csrrs t0, 3, zero
-# CHECK-ALIAS: frcsr t0
-frcsr x5
-# CHECK-INST: csrrw t1, 3, t2
-# CHECK-ALIAS: fscsr t1, t2
-fscsr x6, x7
-# CHECK-INST: csrrw  zero, 3, t3
-# CHECK-ALIAS: fscsr t3
-fscsr x28
-
-# CHECK-INST: csrrs t4, 2, zero
-# CHECK-ALIAS: frrm t4
-frrm x29
-# CHECK-INST: csrrw  t5, 2, t4
-# CHECK-ALIAS: fsrm t5, t4
-fsrm x30, x29
-# CHECK-INST: csrrw  zero, 2, t6
-# CHECK-ALIAS: fsrm t6
-fsrm x31
-# CHECK-INST: csrrwi a0, 2, 31
-# CHECK-ALIAS: fsrmi a0, 31
-fsrmi x10, 0x1f
-# CHECK-INST: csrrwi  zero, 2, 30
-# CHECK-ALIAS: fsrmi 30
-fsrmi 0x1e
-
-# CHECK-INST: csrrs a1, 1, zero
-# CHECK-ALIAS: frflags a1
-frflags x11
-# CHECK-INST: csrrw a2, 1, a1
-# CHECK-ALIAS: fsflags a2, a1
-fsflags x12, x11
-# CHECK-INST: csrrw zero, 1, a3
-# CHECK-ALIAS: fsflags a3
-fsflags x13
-# CHECK-INST: csrrwi a4, 1, 29
-# CHECK-ALIAS: fsflagsi a4, 29
-fsflagsi x14, 0x1d
-# CHECK-INST: csrrwi zero, 1, 28
-# CHECK-ALIAS: fsflagsi 28
-fsflagsi 0x1c
-
-##===----------------------------------------------------------------------===##
-## Aliases which omit the rounding mode.
-##===----------------------------------------------------------------------===##
-
-# CHECK-INST: fmadd.s fa0, fa1, fa2, fa3, dyn
-# CHECK-ALIAS: fmadd.s fa0, fa1, fa2, fa3{{[[:space:]]}}
-fmadd.s f10, f11, f12, f13
-# CHECK-INST: fmsub.s fa4, fa5, fa6, fa7, dyn
-# CHECK-ALIAS: fmsub.s fa4, fa5, fa6, fa7{{[[:space:]]}}
-fmsub.s f14, f15, f16, f17
-# CHECK-INST: fnmsub.s fs2, fs3, fs4, fs5, dyn
-# CHECK-ALIAS: fnmsub.s fs2, fs3, fs4, fs5{{[[:space:]]}}
-fnmsub.s f18, f19, f20, f21
-# CHECK-INST: fnmadd.s fs6, fs7, fs8, fs9, dyn
-# CHECK-ALIAS: fnmadd.s fs6, fs7, fs8, fs9{{[[:space:]]}}
-fnmadd.s f22, f23, f24, f25
-# CHECK-INST: fadd.s fs10, fs11, ft8, dyn
-# CHECK-ALIAS: fadd.s fs10, fs11, ft8{{[[:space:]]}}
-fadd.s f26, f27, f28
-# CHECK-INST: fsub.s ft9, ft10, ft11, dyn
-# CHECK-ALIAS: fsub.s ft9, ft10, ft11{{[[:space:]]}}
-fsub.s f29, f30, f31
-# CHECK-INST: fmul.s ft0, ft1, ft2, dyn
-# CHECK-ALIAS: fmul.s ft0, ft1, ft2{{[[:space:]]}}
-fmul.s ft0, ft1, ft2
-# CHECK-INST: fdiv.s ft3, ft4, ft5, dyn
-# CHECK-ALIAS: fdiv.s ft3, ft4, ft5{{[[:space:]]}}
-fdiv.s ft3, ft4, ft5
-# CHECK-INST: fsqrt.s ft6, ft7, dyn
-# CHECK-ALIAS: fsqrt.s ft6, ft7{{[[:space:]]}}
-fsqrt.s ft6, ft7
-# CHECK-INST: fcvt.w.s a0, fs5, dyn
-# CHECK-ALIAS: fcvt.w.s a0, fs5{{[[:space:]]}}
-fcvt.w.s a0, fs5
-# CHECK-INST: fcvt.wu.s a1, fs6, dyn
-# CHECK-ALIAS: fcvt.wu.s a1, fs6{{[[:space:]]}}
-fcvt.wu.s a1, fs6
-# CHECK-INST: fcvt.s.w ft11, a4, dyn
-# CHECK-ALIAS: fcvt.s.w ft11, a4{{[[:space:]]}}
-fcvt.s.w ft11, a4
-# CHECK-INST: fcvt.s.wu ft0, a5, dyn
-# CHECK-ALIAS: fcvt.s.wu ft0, a5{{[[:space:]]}}
-fcvt.s.wu ft0, a5
diff --git a/test/MC/RISCV/rvi-aliases-valid.s b/test/MC/RISCV/rvi-aliases-valid.s
deleted file mode 100644
index 72ed72eab27..00000000000
--- a/test/MC/RISCV/rvi-aliases-valid.s
+++ /dev/null
@@ -1,145 +0,0 @@
-# RUN: llvm-mc %s -triple=riscv32 -riscv-no-aliases \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv32 \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc %s -triple=riscv64 -riscv-no-aliases\
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc %s -triple=riscv64 \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv32 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d -riscv-no-aliases - \
-# RUN:     | FileCheck -check-prefix=CHECK-INST %s
-# RUN: llvm-mc -filetype=obj -triple riscv64 < %s \
-# RUN:     | llvm-objdump -d - \
-# RUN:     | FileCheck -check-prefix=CHECK-ALIAS %s
-
-# TODO la
-# TODO lb lh lw
-# TODO sb sh sw
-
-# CHECK-INST: addi zero, zero, 0
-# CHECK-ALIAS: nop
-nop
-# TODO li
-# CHECK-INST: addi t6, zero, 0
-# CHECK-ALIAS: mv t6, zero
-mv x31, zero
-# CHECK-INST: xori t6, ra, -1
-# CHECK-ALIAS: not t6, ra
-not x31, x1
-# CHECK-INST: sub t6, zero, ra
-# CHECK-ALIAS: neg t6, ra
-neg x31, x1
-# CHECK-INST: sltiu t6, ra, 1
-# CHECK-ALIAS: seqz t6, ra
-seqz x31, x1
-# CHECK-INST: sltu t6, zero, ra
-# CHECK-ALIAS: snez t6, ra
-snez x31, x1
-# CHECK-INST: slt t6, ra, zero
-# CHECK-ALIAS: sltz t6, ra
-sltz x31, x1
-# CHECK-INST: slt t6, zero, ra
-# CHECK-ALIAS: sgtz t6, ra
-sgtz x31, x1
-
-# CHECK-INST: beq a0, zero, 512
-# CHECK-ALIAS: beqz a0, 512
-beqz x10, 512
-# CHECK-INST: bne a1, zero, 1024
-# CHECK-ALIAS: bnez a1, 1024
-bnez x11, 1024
-# CHECK-INST: bge zero, a2, 4
-# CHECK-ALIAS: blez a2, 4
-blez x12, 4
-# CHECK-INST: bge a3, zero, 8
-# CHECK-ALIAS: bgez a3, 8
-bgez x13, 8
-# CHECK-INST: blt a4, zero, 12
-# CHECK-ALIAS: bltz a4, 12
-bltz x14, 12
-# CHECK-INST: blt zero, a5, 16
-# CHECK-ALIAS: bgtz a5, 16
-bgtz x15, 16
-
-# Always output the canonical mnemonic for the pseudo branch instructions.
-# CHECK-INST: blt a6, a5, 20
-# CHECK-ALIAS: blt a6, a5, 20
-bgt x15, x16, 20
-# CHECK-INST: bge a7, a6, 24
-# CHECK-ALIAS: bge a7, a6, 24
-ble x16, x17, 24
-# CHECK-INST: bltu s2, a7, 28
-# CHECK-ALIAS: bltu s2, a7, 28
-bgtu x17, x18, 28
-# CHECK-INST: bgeu s3, s2, 32
-# CHECK-ALIAS: bgeu s3, s2, 32
-bleu x18, x19, 32
-
-# CHECK-INST: jal zero, 2044
-# CHECK-ALIAS: j 2044
-j 2044
-# CHECK-INST: jal ra, 2040
-# CHECK-ALIAS: jal 2040
-jal 2040
-# CHECK-INST: jalr zero, s4, 0
-# CHECK-ALIAS: jr s4
-jr x20
-# CHECK-INST: jalr ra, s5, 0
-# CHECK-ALIAS: jalr s5
-jalr x21
-# CHECK-INST: jalr zero, ra, 0
-# CHECK-ALIAS: ret
-ret
-# TODO call
-# TODO tail
-
-# CHECK-INST: fence iorw, iorw
-# CHECK-ALIAS: fence
-fence
-
-# CHECK-INST: csrrs s10, 3074, zero
-# CHECK-ALIAS: rdinstret s10
-rdinstret x26
-# CHECK-INST: csrrs s8, 3072, zero
-# CHECK-ALIAS: rdcycle s8
-rdcycle x24
-# CHECK-INST: csrrs s9, 3073, zero
-# CHECK-ALIAS: rdtime s9
-rdtime x25
-
-# CHECK-INST: csrrs  s0, 336, zero
-# CHECK-ALIAS: csrr s0, 336
-csrr x8, 0x150
-# CHECK-INST: csrrw zero, 320, s1
-# CHECK-ALIAS: csrw 320, s1
-csrw 0x140, x9
-# CHECK-INST: csrrs zero, 4095, s6
-# CHECK-ALIAS: csrs 4095, s6
-csrs 0xfff, x22
-# CHECK-INST: csrrc zero, 4095, s7
-# CHECK-ALIAS: csrc 4095, s7
-csrc 0xfff, x23
-
-# CHECK-INST: csrrwi zero, 336, 15
-# CHECK-ALIAS: csrwi 336, 15
-csrwi 0x150, 0xf
-# CHECK-INST: csrrsi zero, 4095, 16
-# CHECK-ALIAS: csrsi 4095, 16
-csrsi 0xfff, 0x10
-# CHECK-INST: csrrci zero, 320, 17
-# CHECK-ALIAS: csrci 320, 17
-csrci 0x140, 0x11
-
-# CHECK-INST: sfence.vma zero, zero
-# CHECK-ALIAS: sfence.vma
-sfence.vma
-# CHECK-INST: sfence.vma a0, zero
-# CHECK-ALIAS: sfence.vma a0
-sfence.vma a0
diff --git a/test/Object/RISCV/elf-flags.yaml b/test/Object/RISCV/elf-flags.yaml
deleted file mode 100644
index ff8637f000a..00000000000
--- a/test/Object/RISCV/elf-flags.yaml
+++ /dev/null
@@ -1,24 +0,0 @@
-# RUN: yaml2obj %s > %t
-# RUN: llvm-readobj -file-headers %t | FileCheck -check-prefix=OBJ %s
-# RUN: obj2yaml %t | FileCheck -check-prefix=YAML %s
-
-# OBJ: Flags [ (0xD)
-# OBJ-NEXT:   EF_RISCV_FLOAT_ABI_DOUBLE (0x4)
-# OBJ-NEXT:   EF_RISCV_RVC (0x1)
-# OBJ-NEXT:   EF_RISCV_RVE (0x8)
-# OBJ-NEXT: ]
-
-# YAML:      FileHeader:
-# YAML-NEXT:   Class:           ELFCLASS32
-# YAML-NEXT:   Data:            ELFDATA2LSB
-# YAML-NEXT:   Type:            ET_EXEC
-# YAML-NEXT:   Machine:         EM_RISCV
-# YAML-NEXT:   Flags:           [ EF_RISCV_RVC, EF_RISCV_FLOAT_ABI_DOUBLE, EF_RISCV_RVE ]
-
---- !ELF
-FileHeader:
-  Class:           ELFCLASS32
-  Data:            ELFDATA2LSB
-  Type:            ET_EXEC
-  Machine:         EM_RISCV
-  Flags:           [ EF_RISCV_RVC, EF_RISCV_FLOAT_ABI_DOUBLE, EF_RISCV_RVE ]
diff --git a/test/Object/RISCV/lit.local.cfg b/test/Object/RISCV/lit.local.cfg
deleted file mode 100644
index c63820126f8..00000000000
--- a/test/Object/RISCV/lit.local.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-if not 'RISCV' in config.root.targets:
-    config.unsupported = True
diff --git a/tools/llvm-objdump/llvm-objdump.cpp b/tools/llvm-objdump/llvm-objdump.cpp
index 3be2c423bb5..9f590ad8018 100644
--- a/tools/llvm-objdump/llvm-objdump.cpp
+++ b/tools/llvm-objdump/llvm-objdump.cpp
@@ -756,7 +756,6 @@ static std::error_code getRelocationValueString(const ELFObjectFile<ELFT> *Obj,
   case ELF::EM_HEXAGON:
   case ELF::EM_MIPS:
   case ELF::EM_BPF:
-  case ELF::EM_RISCV:
     res = Target;
     break;
   case ELF::EM_WEBASSEMBLY:
diff --git a/tools/llvm-readobj/ELFDumper.cpp b/tools/llvm-readobj/ELFDumper.cpp
index 36cda459225..ac8747a2f32 100644
--- a/tools/llvm-readobj/ELFDumper.cpp
+++ b/tools/llvm-readobj/ELFDumper.cpp
@@ -1011,7 +1011,6 @@ static const EnumEntry<unsigned> ElfMachineType[] = {
   ENUM_ENT(EM_78KOR,         "EM_78KOR"),
   ENUM_ENT(EM_56800EX,       "EM_56800EX"),
   ENUM_ENT(EM_AMDGPU,        "EM_AMDGPU"),
-  ENUM_ENT(EM_RISCV,         "RISC-V"),
   ENUM_ENT(EM_WEBASSEMBLY,   "EM_WEBASSEMBLY"),
   ENUM_ENT(EM_LANAI,         "EM_LANAI"),
   ENUM_ENT(EM_BPF,           "EM_BPF"),
@@ -1293,14 +1292,6 @@ static const EnumEntry<unsigned> ElfHeaderAMDGPUFlags[] = {
   LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_XNACK)
 };
 
-static const EnumEntry<unsigned> ElfHeaderRISCVFlags[] = {
-  LLVM_READOBJ_ENUM_ENT(ELF, EF_RISCV_RVC),
-  LLVM_READOBJ_ENUM_ENT(ELF, EF_RISCV_FLOAT_ABI_SINGLE),
-  LLVM_READOBJ_ENUM_ENT(ELF, EF_RISCV_FLOAT_ABI_DOUBLE),
-  LLVM_READOBJ_ENUM_ENT(ELF, EF_RISCV_FLOAT_ABI_QUAD),
-  LLVM_READOBJ_ENUM_ENT(ELF, EF_RISCV_RVE)
-};
-
 static const EnumEntry<unsigned> ElfSymOtherFlags[] = {
   LLVM_READOBJ_ENUM_ENT(ELF, STV_INTERNAL),
   LLVM_READOBJ_ENUM_ENT(ELF, STV_HIDDEN),
@@ -3756,8 +3747,6 @@ template <class ELFT> void LLVMStyle<ELFT>::printFileHeaders(const ELFO *Obj) {
     else if (e->e_machine == EM_AMDGPU)
       W.printFlags("Flags", e->e_flags, makeArrayRef(ElfHeaderAMDGPUFlags),
                    unsigned(ELF::EF_AMDGPU_MACH));
-    else if (e->e_machine == EM_RISCV)
-      W.printFlags("Flags", e->e_flags, makeArrayRef(ElfHeaderRISCVFlags));
     else
       W.printFlags("Flags", e->e_flags);
     W.printNumber("HeaderSize", e->e_ehsize);
diff --git a/unittests/ADT/TripleTest.cpp b/unittests/ADT/TripleTest.cpp
index c19ad43c723..93606a98076 100644
--- a/unittests/ADT/TripleTest.cpp
+++ b/unittests/ADT/TripleTest.cpp
@@ -295,24 +295,6 @@ TEST(TripleTest, ParsedIDs) {
   EXPECT_EQ(Triple::AMDPAL, T.getOS());
   EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
 
-  T = Triple("riscv32-unknown-unknown");
-  EXPECT_EQ(Triple::riscv32, T.getArch());
-  EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
-  EXPECT_EQ(Triple::UnknownOS, T.getOS());
-  EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
-
-  T = Triple("riscv64-unknown-linux");
-  EXPECT_EQ(Triple::riscv64, T.getArch());
-  EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
-  EXPECT_EQ(Triple::Linux, T.getOS());
-  EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
-
-  T = Triple("riscv64-unknown-freebsd");
-  EXPECT_EQ(Triple::riscv64, T.getArch());
-  EXPECT_EQ(Triple::UnknownVendor, T.getVendor());
-  EXPECT_EQ(Triple::FreeBSD, T.getOS());
-  EXPECT_EQ(Triple::UnknownEnvironment, T.getEnvironment());
-
   T = Triple("armv7hl-suse-linux-gnueabi");
   EXPECT_EQ(Triple::arm, T.getArch());
   EXPECT_EQ(Triple::SUSE, T.getVendor());
@@ -657,16 +639,6 @@ TEST(TripleTest, BitWidthPredicates) {
   EXPECT_FALSE(T.isArch16Bit());
   EXPECT_TRUE(T.isArch32Bit());
   EXPECT_FALSE(T.isArch64Bit());
-
-  T.setArch(Triple::riscv32);
-  EXPECT_FALSE(T.isArch16Bit());
-  EXPECT_TRUE(T.isArch32Bit());
-  EXPECT_FALSE(T.isArch64Bit());
-
-  T.setArch(Triple::riscv64);
-  EXPECT_FALSE(T.isArch16Bit());
-  EXPECT_FALSE(T.isArch32Bit());
-  EXPECT_TRUE(T.isArch64Bit());
 }
 
 TEST(TripleTest, BitWidthArchVariants) {
@@ -758,14 +730,6 @@ TEST(TripleTest, BitWidthArchVariants) {
   EXPECT_EQ(Triple::wasm32, T.get32BitArchVariant().getArch());
   EXPECT_EQ(Triple::wasm64, T.get64BitArchVariant().getArch());
 
-  T.setArch(Triple::riscv32);
-  EXPECT_EQ(Triple::riscv32, T.get32BitArchVariant().getArch());
-  EXPECT_EQ(Triple::riscv64, T.get64BitArchVariant().getArch());
-
-  T.setArch(Triple::riscv64);
-  EXPECT_EQ(Triple::riscv32, T.get32BitArchVariant().getArch());
-  EXPECT_EQ(Triple::riscv64, T.get64BitArchVariant().getArch());
-
   T.setArch(Triple::thumbeb);
   EXPECT_EQ(Triple::thumbeb, T.get32BitArchVariant().getArch());
   EXPECT_EQ(Triple::aarch64_be, T.get64BitArchVariant().getArch());
diff --git a/utils/UpdateTestChecks/asm.py b/utils/UpdateTestChecks/asm.py
index c98dfc9eeac..4a1c9d7b00b 100644
--- a/utils/UpdateTestChecks/asm.py
+++ b/utils/UpdateTestChecks/asm.py
@@ -54,12 +54,6 @@ ASM_FUNCTION_PPC_RE = re.compile(
     r'.Lfunc_end[0-9]+:\n',
     flags=(re.M | re.S))
 
-ASM_FUNCTION_RISCV_RE = re.compile(
-    r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*@(?P=func)\n[^:]*?'
-    r'(?P<body>^##?[ \t]+[^:]+:.*?)\s*'
-    r'.Lfunc_end[0-9]+:\n',
-    flags=(re.M | re.S))
-
 ASM_FUNCTION_SYSTEMZ_RE = re.compile(
     r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*@(?P=func)\n'
     r'[ \t]+.cfi_startproc\n'
@@ -137,16 +131,6 @@ def scrub_asm_mips(asm, args):
   asm = common.SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
   return asm
 
-def scrub_asm_riscv(asm, args):
-  # Scrub runs of whitespace out of the assembly, but leave the leading
-  # whitespace in place.
-  asm = common.SCRUB_WHITESPACE_RE.sub(r' ', asm)
-  # Expand the tabs used for indentation.
-  asm = string.expandtabs(asm, 2)
-  # Strip trailing whitespace.
-  asm = common.SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
-  return asm
-
 def scrub_asm_systemz(asm, args):
   # Scrub runs of whitespace out of the assembly, but leave the leading
   # whitespace in place.
@@ -189,8 +173,6 @@ def build_function_body_dictionary_for_triple(args, raw_tool_output, triple, pre
       'mips': (scrub_asm_mips, ASM_FUNCTION_MIPS_RE),
       'powerpc64': (scrub_asm_powerpc64, ASM_FUNCTION_PPC_RE),
       'powerpc64le': (scrub_asm_powerpc64, ASM_FUNCTION_PPC_RE),
-      'riscv32': (scrub_asm_riscv, ASM_FUNCTION_RISCV_RE),
-      'riscv64': (scrub_asm_riscv, ASM_FUNCTION_RISCV_RE),
       's390x': (scrub_asm_systemz, ASM_FUNCTION_SYSTEMZ_RE),
   }
   handlers = None
-- 
2.16.2

